# data file for the Fltk User Interface Designer (fluid)
version 1.0400
use_FL_COMMAND
header_name {.h}
code_name {.cpp}
comment {// ==============================
// File:			TFLSettings
// Project:			Einstein
//
// Copyright 2003-2022 by Paul Guyot (pguyot@kallisys.net).
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
// ==============================
// $Id$
// ==============================
} {in_source in_header
}

decl {class TFLApp;} {public global
}

decl {\#include "TFLSettings.h"} {public global
}

decl {\#include "TFLApp.h"} {public global
}

decl {\#include "TFLAppUI.h"} {private local
}

decl {\#include "Emulator/Platform/TPlatformManager.h"} {private local
}

decl {\#include "app/Version.h"} {private global
}

decl {\#include "app/FLTK/TFLTabs.h"} {private global
}

declblock {\#if TARGET_OS_WIN32} {open after {\#endif}
} {
  decl {\#include "winsock2.h"} {private local
  }
}

decl {\#include <string.h>} {private local
}

decl {\#include <stdint.h>} {private local
}

decl {\#include <FL/filename.H>} {private local
}

decl {\#include <FL/Fl_Native_File_Chooser.H>} {private local
}

decl {\#include <FL/Fl.H>} {private local
}

decl {\#include <FL/fl_draw.H>} {private local
}

declblock {\#if TARGET_OS_MAC} {open public after {\#endif}
} {
  decl {\#include <FL/Fl_Sys_Menu_Bar.H>} {public global
  }
}

Function {cb_keepInSlot0(Fl_Menu_Item* mi, void* user_data)} {open private return_type void
} {
  code {if (mi->value()) {
      mi->clear();
      gApp->UserActionKeepPCCardInSlot(-1, (int)(intptr_t)user_data);
    } else {
      mi->set();
      gApp->UserActionKeepPCCardInSlot(0, (int)(intptr_t)user_data);
    }} {}
}

Function {cb_keepInSlot1(Fl_Menu_Item* mi, void* user_data)} {open private return_type void
} {
  code {if (mi->value()) {
      mi->clear();
      gApp->UserActionKeepPCCardInSlot(-1, (int)(intptr_t)user_data);
    } else {
      mi->set();
      gApp->UserActionKeepPCCardInSlot(1, (int)(intptr_t)user_data);
    }} {}
}

Function {cb_changePCCard0(Fl_Widget*, void* user_data)} {open private return_type void
} {
  code {gApp->UserActionPCCard(0, (intptr_t)user_data);} {}
}

Function {cb_changePCCard1(Fl_Widget*, void* user_data)} {open private return_type void
} {
  code {gApp->UserActionPCCard(1, (intptr_t)user_data);} {selected
  }
}

Function {expand(std::string &inCmd)} {open private return_type {std::string}
} {
  code {switch (inCmd[0]) {
  case 'U':
    return gApp->GetSettings()->mUnnaPath + inCmd.substr(1);
  case 'M':
    return gApp->GetSettings()->mMessagepadOrgPath + inCmd.substr(1);
  case ':':
    return inCmd.substr(1);
  case 'S':
    auto ix = inCmd.find("\\n");
    if (ix==std::string::npos)
      return inCmd.substr(1);
    else
      return inCmd.substr(1, ix) + "...";
}
return std::string();} {}
}

Function {make_tooltip(StringList *inCmdList)} {open private return_type {char *}
} {
  code {std::string text;
// Count the entries
int n = 0;
for (auto &&cmd: *inCmdList) {
  auto link = expand(cmd);
  if (!link.empty()) {
    n++;
  }
}
// Generate a long string. If we have more than 4 lines, print 1,2,...,n-1,n
int min = n+1, max = n+1;
if (n>6) { min=3; max = n-3; }
n = 0;
for (auto &&cmd: *inCmdList) {
  auto link = expand(cmd);
  if (!link.empty()) {
    if (n<min || n>=max) {
      if (!text.empty())
        text.append("\\n");
      text.append(link);
    } else if (n==min) {
      text.append("\\n...");
    }
    n++;
  }
}
return strdup(text.c_str());} {}
}

Function {makeInstaller()} {open
} {
  Fl_Window wInstallerWindow {
    label {Install Essentials} open
    xywh {462 302 300 400} type Double hide resizable hotspot size_range {300 200 300 0}
  } {
    Fl_Scroll {} {open
      xywh {0 0 300 400} resizable
    } {
      Fl_Pack wInstallerList {open
        xywh {0 0 280 400} resizable
      } {}
    }
  }
}

Function {addInstallerTitle(const char *inTitle)} {open
} {
  code {wInstallerList->begin();} {}
  Fl_Window {} {open
    xywh {454 209 280 30} type Double labelfont 1 labelsize 22 align 16
    code0 {o->label(inTitle);}
    class Fl_Group visible
  } {
    Fl_Box {} {
      label label
      xywh {0 0 280 30} box FLAT_BOX color 36 labelsize 20 labelcolor 7
      code0 {o->label(inTitle);}
    }
  }
}

Function {addInstallerGroup(const char *inTitle)} {open
} {
  code {wInstallerList->begin();} {}
  Fl_Window {} {open
    xywh {454 275 280 30} type Double labelfont 1 labelsize 22 align 16
    code0 {o->label(inTitle);}
    class Fl_Group visible
  } {
    Fl_Box {} {
      label label
      xywh {10 5 260 25} labelsize 16 align 20
      code0 {o->label(inTitle);}
    }
  }
}

Function {addInstallerText(const char *inText)} {open
} {
  code {wInstallerList->begin();} {}
  Fl_Window wInstallerTextGroup {open
    xywh {458 341 280 25} type Double labelfont 1 labelsize 22 align 16
    class Fl_Group visible
  } {
    Fl_Box {} {
      label label
      xywh {10 3 260 20} box FLAT_BOX labelsize 12 align 149
      code0 {o->label(inText);}
      code1 {fl_font(FL_HELVETICA, 12);}
      code2 {int ww = o->w(), hh = 0; fl_measure(inText, ww, hh, 1);}
      code3 {wInstallerTextGroup->resize(0, 0, wInstallerTextGroup->w(), hh+6); o->resize(10, 3, o->w(), hh);}
    }
  }
}

Function {addInstallerPackage(const char *inTitle, StringList *inCmdList)} {open
} {
  code {wInstallerList->begin();} {}
  Fl_Window {} {open
    xywh {460 466 280 25} type Double labelfont 1 labelsize 22 align 16
    class Fl_Group visible
  } {
    Fl_Button {} {
      label Install
      user_data inCmdList
      callback {StringList *cmdList = (StringList*)v;
for (auto &&cmd: *cmdList) {
  if (cmd[0]=='W') {
    const char *warning = cmd.c_str()+1;
    if (fl_choice("%s", nullptr, "Cancel", "Proceed", warning)!=2) {
      return;
    }
  } else if (cmd[0]=='S') {
    gApp->GetPlatformManager()->EvalNewtonScript(cmd.c_str()+1);
  } else {
    auto link = expand(cmd);
    if (!link.empty())
      gApp->InstallPackagesFromURI(link.c_str());
  }
}}
      xywh {10 3 70 20} labelsize 12
      code0 {o->tooltip(make_tooltip(inCmdList));}
    }
    Fl_Box {} {
      xywh {85 3 175 20} labelsize 13 align 20
      code0 {o->label(inTitle);}
    }
  }
}

Function {addInstallerLink(const char *inTitle, StringList *inLinkList)} {open
} {
  code {wInstallerList->begin();} {}
  Fl_Window {} {open
    xywh {458 402 280 25} type Double labelfont 1 labelsize 22 align 16
    class Fl_Group visible
  } {
    Fl_Button {} {
      label {@ext  Read}
      user_data inLinkList
      callback {StringList *linkList = (StringList*)v;
for (auto &&link: *linkList) {
  auto fullLink = expand(link);
  if (!fullLink.empty()) {
    char errmsg[512];
    if (!fl_open_uri(fullLink.c_str(), errmsg, sizeof(errmsg))) {
      fl_alert("Error: %s", errmsg);
    }
  }
}}
      xywh {10 3 70 20} labelsize 12
      code0 {o->tooltip(make_tooltip(inLinkList));}
    }
    Fl_Box {} {
      xywh {85 3 175 20} labelsize 13 align 20
      code0 {o->label(inTitle);}
    }
  }
}

Function {addInstallerScript(const char *inTitle, StringList *inScriptList)} {open
} {
  code {wInstallerList->begin();} {}
  Fl_Window {} {open
    xywh {455 524 280 30} type Double labelfont 1 labelsize 22 labelcolor 3 align 16
    class Fl_Group visible
  } {
    Fl_Button {} {
      user_data inScriptList
      callback {StringList *scriptList = (StringList*)v;
for (auto &&cmd: *scriptList) {
  if (cmd[0]=='W') {
    const char *warning = cmd.c_str()+1;
    if (fl_choice("%s", nullptr, "Cancel", "Proceed", warning)!=2) {
      return;
    }
  } else if (cmd[0]=='S') {
    gApp->GetPlatformManager()->EvalNewtonScript(cmd.c_str()+1);
  }
}}
      xywh {40 4 200 22} labelsize 12
      code0 {o->label(inTitle);}
      code1 {o->tooltip(make_tooltip(inScriptList));}
    }
  }
}

class TFLSettingsUI {open : {public TFLSettings}
} {
  Function {TFLSettingsUI()} {} {
    code {// create the setting dialog so we have it available for the user
mSettingsPanel = CreateSettingsPanel();
wAbout = nullptr;} {}
  }
  Function {CreateSettingsPanel()} {
    comment override open
  } {
    Fl_Window {} {
      label {Einstein Settings}
      callback {if (wQuit->visible()){
    exit(0);
} else {
    revertDialog();
    mSettingsPanel->hide();
}} open
      xywh {512 675 450 455} type Double visible
    } {
      Fl_Menu_Button RMB {
        label {RMB Menu}
        xywh {4 1 10 10} labelsize 12 hide deactivate
      } {
        MenuItem {} {
          label {Install Package...}
          callback {gApp->UserActionInstallPackage();}
          xywh {12 12 100 20} labelsize 12
        }
        MenuItem {} {
          label Backlight
          callback {gApp->UserActionToggleBacklight();}
          xywh {12 12 100 20} labelsize 12 divider
        }
        Submenu {} {
          label Reset open
          xywh {12 12 100 20} labelsize 12 hide deactivate
        } {
          MenuItem {} {
            label {Soft Reset}
            xywh {12 12 100 20} labelsize 12 deactivate
          }
          MenuItem {} {
            label {Deep Reset}
            xywh {12 12 100 20} labelsize 12 deactivate
          }
          MenuItem {} {
            label {Reset w/o Extensions}
            xywh {12 12 100 20} labelsize 12 deactivate
          }
          MenuItem {} {
            label {Power Drain Reset}
            xywh {12 12 100 20} labelsize 12 deactivate
          }
          MenuItem {} {
            label {Hard Reset (Brain Wipe)}
            xywh {12 12 100 20} labelsize 12 deactivate
          }
          MenuItem {} {
            label {Cold Boot}
            xywh {12 12 100 20} labelsize 12 deactivate
          }
        }
        MenuItem {} {
          label {Settings...}
          callback {gApp->UserActionShowSettingsPanel();}
          xywh {12 12 100 20} labelsize 12
        }
        MenuItem {} {
          label {About...}
          callback {gApp->UserActionShowAboutPanel();}
          xywh {12 12 100 20} labelsize 12 divider
        }
        MenuItem {} {
          label Power
          callback {gApp->UserActionTogglePower();}
          xywh {12 12 100 20} labelsize 12
        }
      }
      Fl_Tabs {} {open
        xywh {10 10 430 400} box BORDER_BOX
        code0 {o->box((Fl_Boxtype)(FL_FREE_BOXTYPE+2));}
        class TFLTabs
      } {
        Fl_Group {} {
          label {  MessagePad  }
          comment {Add a field to select a REx, choose matching PC Cards per slot} open
          xywh {10 35 430 375}
        } {
          Fl_Group {} {open
            xywh {120 50 275 25}
          } {
            Fl_Input wMPConfigName {
              label {Configuration: }
              tooltip {give this MessagePad configuration a name} xywh {120 50 160 25} color 54 deactivate
              code0 {o->value("default");}
            }
            Fl_Button wMPConfigMenuButton {
              label {@2>}
              tooltip {choose another configuration for editing} xywh {280 50 25 25} labelcolor 40 deactivate
            }
            Fl_Button wMPConfigAddButton {
              label {+}
              tooltip {add another hardware configuration} xywh {305 50 25 25} labelfont 4 labelsize 18 deactivate
            }
            Fl_Button wMPConfigRemoveButton {
              label {-}
              tooltip {delete this hardware configuration} xywh {330 50 25 25} labelfont 4 labelsize 18 deactivate
            }
          }
          Fl_Group {} {open
            xywh {22 90 408 77} box FLAT_BOX labelsize 12 align 5
          } {
            Fl_Input wROMName {
              label {Newton ROM: }
              callback {char buf[FL_PATH_MAX + 1];
buf[0] = 0;
strncpy(buf, wROMPath->label(), FL_PATH_MAX);
char *name = (char*)fl_filename_name(buf);
if (name) {
  *name = 0;
  strncat(buf, wROMName->value(), FL_PATH_MAX);
  wROMPath->copy_label(buf);
  wROMDetails->copy_label(GetROMDetails(buf));
}}
              xywh {120 95 235 20} color 54 labelsize 13 textsize 12
            }
            Fl_Box wROMPath {
              label {/here/goes/the/path/and/filename/of/the/ROM}
              xywh {120 115 310 15} labelsize 11 align 212
            }
            Fl_Box wROMDetails {
              label {ROM file found
Enjoy Einstein}
              xywh {120 132 310 35} labelsize 12 align 212
            }
            Fl_Button wROMPathChoose {
              label {Choose...}
              callback {const char *filename = gApp->ChooseExistingFile(
	"Choose ROM file",
	nullptr,
	wROMPath->label()
);
if (filename) {
    wROMName->value(fl_filename_name(filename));
    wROMPath->copy_label(filename);
    wROMDetails->copy_label(GetROMDetails(filename));
}}
              tooltip {Select a Newton ROM image file.
Einstein does not include any ROMs.} xywh {355 95 75 20} labelsize 12
            }
          }
          Fl_Group {} {open
            xywh {22 179 408 46} box FLAT_BOX labelsize 12 align 5
          } {
            Fl_Input wFlashName {
              label {System Flash: }
              callback {char buf[FL_PATH_MAX + 1];
buf[0] = 0;
strncpy(buf, wFlashPath->label(), FL_PATH_MAX);
char *name = (char*)fl_filename_name(buf);
if (name) {
  *name = 0;
  strncat(buf, wFlashName->value(), FL_PATH_MAX);
  wFlashPath->copy_label(buf);
}}
              xywh {120 180 160 20} color 54 labelsize 13 textsize 12
            }
            Fl_Box wFlashPath {
              label {/here/goes/the/path/and/filename/of/the/FlashFile}
              xywh {120 200 310 15} labelsize 11 align 212
            }
            Fl_Button wFlashPathCreate {
              label {Create...}
              callback {const char *filename = gApp->ChooseNewFile(
	"Create a new Flash Memory file",
	nullptr,
	wFlashPath->label()
);
if (filename) {
    wFlashName->value(fl_filename_name(filename));
    wFlashPath->copy_label(filename);
}}
              tooltip {Create a new Flash RAM image file.} xywh {280 180 75 20} labelsize 12
            }
            Fl_Button wFlashPathChoose {
              label {Choose...}
              callback {const char *filename = gApp->ChooseExistingFile(
	"Choose an existing Flash Memory file",
	nullptr,
	wFlashPath->label()
);
if (filename) {
    wFlashName->value(fl_filename_name(filename));
    wFlashPath->copy_label(filename);
}}
              tooltip {Select an existing Flash RAM image file.} xywh {355 180 75 20} labelsize 12
            }
          }
          Fl_Group {} {open
            xywh {22 230 408 20} box FLAT_BOX labelsize 12 align 5
          } {
            Fl_Choice wRAMSizeChoice {
              label {System RAM: } open
              tooltip {select the system memory size (heap)} xywh {120 230 180 20} down_box BORDER_BOX labelsize 13 textsize 12
            } {
              MenuItem {} {
                label {1MB (MP2000/eMate)}
                user_data 16 user_data_type long
                xywh {12 12 100 20} labelsize 12
              }
              MenuItem {} {
                label {4MB (MP2100)}
                user_data 64 user_data_type long
                xywh {0 0 100 20} labelsize 12
              }
              MenuItem {} {
                label 8MB
                user_data 128 user_data_type long
                xywh {20 20 100 20} labelsize 12 deactivate
              }
              MenuItem {} {
                label {15.9MB (maximum)}
                user_data 255 user_data_type long
                xywh {32 32 100 20} labelsize 12 deactivate
              }
            }
          }
          Fl_Choice {} {
            label {User Interface: } open
            xywh {120 270 180 20} down_box BORDER_BOX deactivate
          } {
            MenuItem {} {
              label MP2x00
              xywh {0 0 100 20}
            }
            MenuItem {} {
              label {eMate 300}
              xywh {0 0 100 20}
            }
          }
          Fl_Box wRestartWarning {
            label {Setting changes apply only after a  restart}
            xywh {30 378 386 20} box FLAT_BOX labelfont 1 labelsize 12 align 16 hide
          }
          Fl_Check_Button wFetchDateAndTime {
            label {Fetch date and time from host}
            xywh {120 300 196 20} down_box DOWN_BOX labelsize 13
          }
        }
        Fl_Group {} {
          label {  User Interface  } open
          xywh {10 35 430 375} hide
        } {
          Fl_Group {} {open
            xywh {20 90 408 222} box FLAT_BOX labelsize 12 align 5
          } {
            Fl_Input wWidth {
              label {Screen Size: }
              tooltip {Screen width in pixels,
Original screen size is 320x480} xywh {120 90 80 20} type Int color 54 labelsize 13 textsize 12
            }
            Fl_Input wHeight {
              label {x }
              tooltip {Screen height in pixels,
Original screen size is 320x480} xywh {215 90 80 20} type Int color 54 labelsize 12 textsize 12
            }
            Fl_Check_Button wFullScreen {
              label {Full screen}
              xywh {120 120 308 20} down_box DOWN_BOX labelsize 13 deactivate
            }
            Fl_Check_Button wHideMouse {
              label {Hide mouse pointer}
              tooltip {Hide mouse pointer over MessagePad screen
Used on pen or touch screen devices.} xywh {120 145 208 20} down_box DOWN_BOX labelsize 13
            }
            Fl_Check_Button wLaunchMonitorAtBoot {
              label {Launch Monitor at Boot}
              xywh {120 170 196 20} down_box DOWN_BOX labelsize 13
            }
            Fl_Check_Button wBreakAtROMBoot {
              label {Break at ROMBoot}
              xywh {145 195 196 20} down_box DOWN_BOX labelsize 13 deactivate
            }
            Fl_Check_Button wShowMenubar {
              label Menubar
              xywh {120 220 196 20} down_box DOWN_BOX labelsize 13
            }
            Fl_Check_Button wShowToolbar {
              label Toolbar
              xywh {120 245 196 20} down_box DOWN_BOX labelsize 13
            }
            Fl_Box {} {
              label {Show:}
              xywh {20 220 94 20} labelsize 13 align 24
            }
            Fl_Box {} {
              label {add screen scale}
              xywh {112 186 204 28} hide
            }
            Fl_Box {} {
              label {toggle menubar, toolbar, and functionkey bar}
              xywh {122 212 204 28} hide
            }
            Fl_Box {} {
              label {maybe developer menu, novice menu, expert menu?}
              xywh {128 240 204 28} hide
            }
            Fl_Box {} {
              label {Show at startup: machine choice, settings, last open machine}
              xywh {132 278 204 28} hide
            }
            Fl_Input_Choice wScale {
              label {Scale:} open
              xywh {340 90 60 20} labelsize 12 textsize 12
            } {
              MenuItem {} {
                label 100
                user_data 100 user_data_type long
                xywh {0 0 31 20}
              }
              MenuItem {} {
                label 125
                user_data 125 user_data_type long
                xywh {0 0 31 20}
              }
              MenuItem {} {
                label 150
                user_data 150 user_data_type long
                xywh {0 0 31 20}
              }
              MenuItem {} {
                label 175
                user_data 175 user_data_type long
                xywh {0 0 31 20}
              }
              MenuItem {} {
                label 200
                user_data 200 user_data_type long
                xywh {0 0 31 20}
              }
            }
            Fl_Box {} {
              label {%}
              xywh {400 90 1 20} labelsize 12 align 8
            }
          }
          Fl_Group {} {open
            xywh {120 50 275 25}
          } {
            Fl_Input wUIConfigName {
              label {Configuration: }
              tooltip {give this User Interface configuration a name} xywh {120 50 160 25} color 54 deactivate
              code0 {o->value("default");}
            }
            Fl_Button wUIConfigMenuButton {
              label {@2>}
              tooltip {choose another configuration for editing} xywh {280 50 25 25} labelcolor 40 deactivate
            }
            Fl_Button wUIConfigAddButton {
              label {+}
              tooltip {add another interface configuration} xywh {305 50 25 25} labelfont 4 labelsize 18 deactivate
            }
            Fl_Button wUIConfigRemoveButton {
              label {-}
              tooltip {delete this interface configuration} xywh {330 50 25 25} labelfont 4 labelsize 18 deactivate
            }
          }
        }
        Fl_Group {} {
          label {  PC Cards  } open
          xywh {10 35 430 375} hide
        } {
          Fl_Browser wPCCardList {
            label {PCMCIA Cards:}
            callback {\#if 0
int ix = wPCCardList->value()-1;
if (ix==-1) {
	wPCCardListRemove->deactivate();
	wPCCardProperties->deactivate();
} else {
	TFLPCCardSettings *card = mCardList[ix];
	if (strcmp(card->GetUUID(), TFLPCCardSettings::kNetworkUUID)==0)
		wPCCardListRemove->deactivate();
	else
		wPCCardListRemove->activate();
	wPCCardProperties->activate();
	wPCCardName->value( card->GetName() );
}
\#endif}
            xywh {120 50 235 165} type Hold color 54 labelsize 12 align 4 when 1 textsize 12
          }
          Fl_Menu_Bar {} {open
            xywh {120 215 25 25}
          } {
            Submenu {} {
              label {+} open
              xywh {0 0 100 20}
            } {
              MenuItem {} {
                label {Add existing PCCard Image...}
                callback {char imageFilename[FL_PATH_MAX];
char buf[FL_PATH_MAX];
char *imageName = nullptr;
const char *a;
const char *suggestedName;
const char *fn;
const char *e;
TFLPCCardSettings* card;

char path[FL_PATH_MAX];
strcpy(path, wFlashPath->label());
char *nn = (char*)fl_filename_name(path);
if (nn) *nn = 0;

a = gApp->ChooseExistingFile("Select a PCCard Image file", "*.pccard", path);
if (!a) goto cleanup;
strcpy(imageFilename, a);

suggestedName = "";
fn = fl_filename_name(imageFilename);
if (fn) {
  strcpy(buf, fn);
  fl_filename_setext(buf, FL_PATH_MAX, "");
  suggestedName = buf;
}

// TODO: we could preset the name with either the filename or whatever name we extract from the image
e = fl_input("Please enter a name for your PCCard Image", suggestedName);
if (!e) goto cleanup;
imageName = strdup(e);

card = TFLPCCardSettings::LinkLinearPCCard(imageName, imageFilename);
wPCCardList->add(imageName, card);

cleanup:
if (imageName) free(imageName);}
                xywh {0 0 100 20} labelsize 12
              }
              MenuItem {} {
                label {New 2MB Flash Card...}
                user_data 2 user_data_type long
                callback {char imageFilename[FL_PATH_MAX];
  char buf[FL_PATH_MAX];
  char *imageName = nullptr;
  int size = (int)(long)v;
  const char *a;
  const char *suggestedName;
  const char *fn;
  const char *e;
  TFLPCCardSettings* card;

  char path[FL_PATH_MAX];
  strcpy(path, wFlashPath->label());
  char *nn = (char*)fl_filename_name(path);
  if (nn) *nn = 0;

  a = gApp->ChooseNewFile("Create a PCCard Image file", "*.pccard", path);
  if (!a) goto cleanup;
  strcpy(imageFilename, a);
  if (fl_access(imageFilename, 6)!=0)
  {
    fl_filename_setext(imageFilename, FL_PATH_MAX, ".pccard");
  }

  suggestedName = "";
  fn = fl_filename_name(imageFilename);
  if (fn) {
    strcpy(buf, fn);
    fl_filename_setext(buf, FL_PATH_MAX, "");
    suggestedName = buf;
  }

  // TODO: we could preset the name with either the filename or whatever name we extract from the image
  e = fl_input("Please enter a name for your PCCard Image", suggestedName);
  if (!e) goto cleanup;
  imageName = strdup(e);

  card = TFLPCCardSettings::NewLinearPCCard(imageName, imageFilename, size);
  wPCCardList->add(imageName, card);

  cleanup:
  if (imageName) free(imageName);}
                xywh {10 10 100 20} labelsize 12
              }
              MenuItem {} {
                label {New 4MB Flash Card...}
                user_data 4 user_data_type long
                callback cb_New
                xywh {20 20 100 20} labelsize 12
              }
              MenuItem {} {
                label {New 8MB Flash Card...}
                user_data 8 user_data_type long
                callback cb_New
                xywh {0 0 100 20} labelsize 12
              }
              MenuItem {} {
                label {New 16MB Flash Card...}
                user_data 16 user_data_type long
                callback cb_New
                xywh {0 0 100 20} labelsize 12
              }
              MenuItem {} {
                label {New 24MB Flash Card...}
                user_data 24 user_data_type long
                callback cb_New
                xywh {10 10 100 20} labelsize 12
              }
              MenuItem {} {
                label {New 32MB Flash Card...}
                user_data 32 user_data_type long
                callback cb_New
                xywh {20 20 100 20} labelsize 12
              }
              MenuItem {} {
                label {Create Image from snapshot...}
                callback {char imageFilename[FL_PATH_MAX];
char *dataFilename = nullptr;
char *cisFilename = nullptr;
char *imageName = nullptr;
const char *b;
const char *c;
const char *e;
const char *a;
int ret;
TFLPCCardSettings* card;

char path[FL_PATH_MAX];
strcpy(path, wFlashPath->label());
char *nn = (char*)fl_filename_name(path);
if (nn) *nn = 0;

b = gApp->ChooseExistingFile("PCMCIA Card Data Snapshot", nullptr, path);
if (!b) goto cleanup;
dataFilename = strdup(b);

c = gApp->ChooseExistingFile("PCMCIA Card CIS snapshot", nullptr, nullptr);
if (!c) goto cleanup;
cisFilename = strdup(c);

e = fl_input("Please enter a name for your PCCard Image");
if (!e) goto cleanup;
imageName = strdup(e);

strncat(path, imageName, sizeof(path)-1);

a = gApp->ChooseNewFile("Create this PCMCIA Image file", "*.pccard", path);
if (!a) goto cleanup;
strncpy(imageFilename, a, sizeof(imageFilename));
if (    fl_access(imageFilename, 6)!=0
     || strcmp(imageFilename, dataFilename)==0
     || strcmp(imageFilename, cisFilename)==0 )
{
  fl_filename_setext(imageFilename, FL_PATH_MAX, ".pccard");
}

ret = gApp->UserActionPCMCIAImageFromSnapshot(imageFilename, dataFilename, cisFilename, imageName);
if (ret!=0) goto cleanup;

card = TFLPCCardSettings::LinkLinearPCCard(imageName, imageFilename);
wPCCardList->add(imageName, card);

cleanup:
//if (imageFilename) free(imageFilename);
if (dataFilename) free(dataFilename);
if (cisFilename) free(cisFilename);
if (imageName) free(imageName);}
                xywh {0 0 100 20} labelsize 12
              }
            }
          }
          Fl_Button wPCCardListRemove {
            label {-}
            user_data this
            callback {int ix = wPCCardList->value();
if (ix>0 && ix<=wPCCardList->size()) {
  wPCCardList->remove(ix);
}}
            tooltip {remove and delete a PCMCIA card} xywh {145 215 25 25} labelfont 4 labelsize 18
          }
          Fl_Button wPCCardMoveUp {
            label {@-28>}
            user_data this
            callback {int ix = wPCCardList->value();
if (ix>1) {
  wPCCardList->swap(ix, ix-1);
  wPCCardList->value(ix-1);
  wPCCardList->do_callback();
}}
            xywh {170 215 25 25} labelfont 4 labelsize 18
          }
          Fl_Button wPCCardMoveDown {
            label {@-22>}
            user_data this
            callback {int ix = wPCCardList->value();
if (ix>0 && ix<wPCCardList->size()) {
  wPCCardList->swap(ix, ix+1);
  wPCCardList->value(ix+1);
  wPCCardList->do_callback();
}}
            xywh {195 215 25 25} labelfont 4 labelsize 18
          }
          Fl_Menu_Bar {} {open
            xywh {220 215 25 25}
          } {
            Submenu {} {
              label {...} open
              xywh {10 10 100 20}
            } {
              MenuItem wPCCardEditName {
                label {Edit Card Name...}
                callback {int ix = wPCCardList->value();
if (ix>0 && ix<=wPCCardList->size()) {
  const char *oldName = wPCCardList->text(ix);
  const char *newName = fl_input("Please enter a new name for you PCCard", oldName);
  if (newName)
    wPCCardList->text(ix, newName);
}}
                xywh {10 10 100 20} labelsize 12
              }
              MenuItem wPCCardEditTag {
                label {Edit Card Tag...}
                callback {int ix = wPCCardList->value();
if (ix>0 && ix<=wPCCardList->size()) {
  TFLPCCardSettings *card = (TFLPCCardSettings*)wPCCardList->data(ix);
  const char *oldTag = card->GetTag();
  const char *newTag = fl_input(
  	"Please enter a new Tag for you PCCard\\n\\n"
  	"Tags should be at most four upper case\\n"
  	"characters long.\\n", oldTag);
  if (newTag)
    card->SetTag(newTag);
}}
                xywh {20 20 100 20} labelsize 12
              }
              MenuItem wPCCardEditPath {
                label {Edit Card Image Path...}
                callback {int ix = wPCCardList->value();
TFLPCCardSettings *card = (TFLPCCardSettings*)wPCCardList->data(ix);
if (ix>0 && card->GetType()==TFLPCCardSettings::CardType::kLinear) {
  const char *oldPath = card->GetImagePath();
  const char *newPath = gApp->ChooseExistingFile(
    "Please select another PCCard Image", "*.pccard", oldPath
  );
  if (newPath)
    card->SetImagePath(newPath);
}}
                xywh {10 10 100 20} labelsize 12
              }
            }
          }
        }
        Fl_Group {} {
          label {  Resources  } open
          xywh {10 35 430 375} hide
        } {
          Fl_Input_Choice wUnnaPath {
            label {UNNA Database: } open
            tooltip {United Network of Newton Archives} xywh {172 80 210 20} color 54 labelsize 13 textsize 12
            code0 {o->value("http://www.unna.org/");}
          } {
            MenuItem {} {
              label {http://www.unna.org/}
              xywh {0 0 100 20} labelsize 12
            }
            MenuItem {} {
              label {http://vermont.unna.org/}
              xywh {0 0 100 20} labelsize 12
            }
            MenuItem {} {
              label {http://philly.unna.org/}
              xywh {0 0 100 20} labelsize 12
            }
          }
          Fl_Button wUnnaPathChoose {
            label {@fileopen}
            callback {const char *filename = gApp->ChooseExistingDirectory(
	"Choose UNNA directory",
	nullptr,
	wUnnaPath->label()
);
if (filename) {
    wUnnaPath->value(filename);
}}
            tooltip {Select a local copy of the UNNA archive} xywh {382 80 42 20} labelsize 12 labelcolor 3
          }
          Fl_Input_Choice wMessagepadOrgPath {
            label {messagepad.org: } open
            xywh {172 115 252 20} color 54 labelsize 13 textsize 12
            code0 {o->value("http://www.messagepad.org/");}
          } {
            MenuItem {} {
              label {http://www.messagepad.org/}
              xywh {36 36 100 20} labelsize 12
            }
          }
          Fl_Input_Choice wGitRepoPath {
            label {Git Repository: } open
            xywh {172 150 252 20} color 54 labelsize 13 textsize 12
            code0 {o->value("https://github.com/pguyot/Einstein.git");}
          } {
            MenuItem {} {
              label {https://github.com/pguyot/Einstein.git}
              xywh {36 36 100 20} labelsize 12
            }
          }
          Fl_Box {} {
            label {Advanced tools for creating native functions in NewtonScript packaeges and ROM patches}
            xywh {172 280 252 36} labelsize 12 align 128
          }
          Fl_Input wDevAsmPath {
            label {ARM cross assembler: }
            tooltip {full path to ARM cross assembler} xywh {172 320 210 20} labelsize 13 textsize 12
          }
          Fl_Button wDevAsmPathChoose {
            label {@fileopen}
            callback {const char *filename = gApp->ChooseExistingFile(
	"Choose ARM cross assembler",
	nullptr,
	wDevAsmPath->value()
);
if (filename) {
    wDevAsmPath->value(filename);
}}
            xywh {382 320 42 20} labelsize 12 labelcolor 3
          }
          Fl_Input wDevObjCopyPath {
            label {ARM objcopy: }
            tooltip {full path to ARM cross objcopy tool} xywh {172 344 210 20} labelsize 13 textsize 12
          }
          Fl_Button wDevObjCopyPathChoose {
            label {@fileopen}
            callback {const char *filename = gApp->ChooseExistingFile(
	"Choose ARM cross objcopy",
	nullptr,
	wDevObjCopyPath->value()
);
if (filename) {
    wDevObjCopyPath->value(filename);
}}
            tooltip {Select a local copy of the UNNA archive} xywh {382 344 42 20} labelsize 12 labelcolor 3
          }
          Fl_Input wDevObjDumpPath {
            label {ARM objdump: }
            tooltip {full path to ARM cross objdump tool} xywh {172 368 210 20} labelsize 13 textsize 12
          }
          Fl_Button wDevObjDumpPathChoose {
            label {@fileopen}
            callback {const char *filename = gApp->ChooseExistingFile(
	"Choose ARM cross objdump",
	nullptr,
	wDevObjDumpPath->value()
);
if (filename) {
    wDevObjDumpPath->value(filename);
}}
            xywh {382 368 42 20} labelsize 12 labelcolor 3
          }
        }
      }
      Fl_Check_Button wDontShow {
        label {Don't show at startup}
        xywh {24 422 140 21} down_box DOWN_BOX labelsize 12
      }
      Fl_Button wQuit {
        label Quit
        callback {exit(0);}
        xywh {217 420 95 25} color 50 labelsize 12
      }
      Fl_Button wStart {
        label Start
        callback {applyDialog();
savePreferences();
mSettingsPanel->hide();}
        xywh {322 420 95 25} color 50 labelsize 12
        code0 {Fl::focus(wStart);}
      }
      Fl_Button wRevert {
        label Revert
        callback {revertDialog();
mSettingsPanel->redraw();}
        xywh {217 420 95 25} color 50 labelsize 12 hide
      }
      Fl_Button wSave {
        label Save
        callback {applyDialog();
savePreferences();
mSettingsPanel->hide();}
        xywh {322 420 95 25} color 50 labelsize 12 hide
      }
      Fl_Box {} {
        xywh {10 410 430 5}
        code0 {o->box((Fl_Boxtype)(FL_FREE_BOXTYPE+2));}
      }
    }
  }
  Function {updateMenus()} {open return_type void
  } {
    code {\#define MENU_FONT FL_NORMAL_LABEL, FL_HELVETICA, 14, 0
\#define MENU_HEADLINE FL_NORMAL_LABEL, FL_HELVETICA_BOLD_ITALIC, 14, 0

  if (wNetworkTool) wNetworkTool->clearTopID();
  if (wNetworkTool) wNetworkTool->clearBottomID();

  Fl_Menu_Item* slot0menu = (Fl_Menu_Item*)calloc(mCardList.size() + 6, sizeof(Fl_Menu_Item));
  if (wPCCardSlot0->user_data()) ::free(wPCCardSlot0->user_data());
  wPCCardSlot0->flags |= FL_SUBMENU_POINTER;
  wPCCardSlot0->user_data(slot0menu);
  slot0menu[0] = { "Eject Card", 0/* shortcut */, cb_changePCCard0, (void*)-1, FL_MENU_INVISIBLE, MENU_FONT };
  slot0menu[1] = { "Keep in Slot", 0/* shortcut */, (Fl_Callback*)cb_keepInSlot0, (void*)-1, FL_MENU_INVISIBLE | FL_MENU_TOGGLE | FL_MENU_DIVIDER, MENU_FONT };
  slot0menu[2] = { "Insert Card:", 0/* shortcut */, nullptr /* callback */, nullptr /* user_data */, FL_MENU_INACTIVE, MENU_HEADLINE };
  slot0menu[3] = { "Replace Card:", 0/* shortcut */, nullptr /* callback */, nullptr /* user_data */, FL_MENU_INVISIBLE | FL_MENU_INACTIVE, MENU_HEADLINE };
  TPlatformManager *pm = gApp->GetPlatformManager();
  TPCMCIACard *c0 = nullptr;
  if (pm) {
    c0 = gApp->GetPlatformManager()->GetPCCard(0);
    if (c0) {
      slot0menu[0].flags &= ~FL_MENU_INVISIBLE;
      slot0menu[1].flags &= ~FL_MENU_INVISIBLE;
      slot0menu[2].flags |= FL_MENU_INVISIBLE;
      slot0menu[3].flags &= ~FL_MENU_INVISIBLE;
    } else {
      slot0menu[0].flags |= FL_MENU_INVISIBLE;
      slot0menu[1].flags |= FL_MENU_INVISIBLE;
      slot0menu[2].flags &= ~FL_MENU_INVISIBLE;
      slot0menu[3].flags |= FL_MENU_INVISIBLE;
    }
  }

  Fl_Menu_Item* slot1menu = (Fl_Menu_Item*)calloc(mCardList.size() + 6, sizeof(Fl_Menu_Item));
  if (wPCCardSlot1->user_data()) ::free(wPCCardSlot1->user_data());
  wPCCardSlot1->flags |= FL_SUBMENU_POINTER;
  wPCCardSlot1->user_data(slot1menu);
  slot1menu[0] = { "Eject Card", 0/* shortcut */, cb_changePCCard1, (void*)-1, FL_MENU_INVISIBLE, MENU_FONT };
  slot1menu[1] = { "Keep in Slot", 0/* shortcut */, (Fl_Callback*)cb_keepInSlot1, (void*)-1, FL_MENU_INVISIBLE | FL_MENU_TOGGLE | FL_MENU_DIVIDER, MENU_FONT };
  slot1menu[2] = { "Insert Card:", 0/* shortcut */, nullptr /* callback */, nullptr /* user_data */, FL_MENU_INACTIVE, MENU_HEADLINE };
  slot1menu[3] = { "Replace Card:", 0/* shortcut */, nullptr /* callback */, nullptr /* user_data */, FL_MENU_INVISIBLE | FL_MENU_INACTIVE, MENU_HEADLINE };
  TPCMCIACard *c1 = nullptr;
  if (pm) {
    c1 = gApp->GetPlatformManager()->GetPCCard(1);
    if (c1) {
      slot1menu[0].flags &= ~FL_MENU_INVISIBLE;
      slot1menu[1].flags &= ~FL_MENU_INVISIBLE;
      slot1menu[2].flags |= FL_MENU_INVISIBLE;
      slot1menu[3].flags &= ~FL_MENU_INVISIBLE;
    } else {
      slot1menu[0].flags |= FL_MENU_INVISIBLE;
      slot1menu[1].flags |= FL_MENU_INVISIBLE;
      slot1menu[2].flags &= ~FL_MENU_INVISIBLE;
      slot1menu[3].flags |= FL_MENU_INVISIBLE;
    }
  }

  for (size_t i=0; i<mCardList.size(); i++) {
  	TFLPCCardSettings *card = mCardList[i];
  	slot0menu[i+4] = { card->GetName(), 0, cb_changePCCard0, (void*)i, 0 /* flags */, MENU_FONT };
  	slot1menu[i+4] = { card->GetName(), 0, cb_changePCCard1, (void*)i, 0 /* flags */, MENU_FONT };
    if (c0 && c0==card->Card()) {
        slot0menu[i+4].labelfont_ |= 1;
        slot1menu[i+4].flags |= FL_MENU_INACTIVE;
        if (card->KeepInSlot()==0) slot0menu[1].set();
        if (wNetworkTool) wNetworkTool->setTopID(card->GetTag());
        slot0menu[1].user_data((void*)i);
    }
    if (c1 && c1==card->Card()) {
        slot1menu[i+4].labelfont_ |= 1;
        slot0menu[i+4].flags |= FL_MENU_INACTIVE;
        if (card->KeepInSlot()==1) slot1menu[1].set();
        if (wNetworkTool) wNetworkTool->setBottomID(card->GetTag());
        slot1menu[1].user_data((void*)i);
    }
  }
\#if TARGET_OS_MAC
  if (wSysMenubar) {
    wSysMenubar->update();
  }
\#endif} {}
  }
  Function {revertDialog()} {open return_type void
  } {
    code {char buf[32];

// ---- MessagePad

wROMName->value(fl_filename_name(ROMPath));
wROMPath->copy_label(ROMPath);
wROMDetails->copy_label(GetROMDetails(wROMPath->label()));

wFlashName->value(fl_filename_name(FlashPath));
wFlashPath->copy_label(FlashPath);

if (RAMSize<=16)
	wRAMSizeChoice->value(0);
else if (RAMSize<=64)
	wRAMSizeChoice->value(1);
else if (RAMSize<=128)
	wRAMSizeChoice->value(1);
else
	wRAMSizeChoice->value(1);

wFetchDateAndTime->value(mFetchDateAndTime);

// ---- User Interface

snprintf(buf, 31, "%d", screenWidth);
wWidth->value(buf);
snprintf(buf, 31, "%d", screenHeight);
wHeight->value(buf);
snprintf(buf, 31, "%d", screenScale);
wScale->value(buf);
wFullScreen->value(fullScreen);
wHideMouse->value(hideMouse);
wLaunchMonitorAtBoot->value(mLaunchMonitorAtBoot);
wBreakAtROMBoot->value(mBreakAtROMBoot);
wShowMenubar->value(mShowMenubar);
wShowToolbar->value(mShowToolbar);

// ---- PC Cards

wPCCardList->clear();
for (size_t i=0; i<mCardList.size(); i++) {
	TFLPCCardSettings *card = mCardList[i];
	wPCCardList->add(card->GetName(), card);
}
wPCCardList->value(0);
wPCCardList->do_callback();

// ---- Resources

wUnnaPath->value(mUnnaPath);
wMessagepadOrgPath->value(mMessagepadOrgPath);
wGitRepoPath->value(mGitRepoPath);

wDevAsmPath->value(mDevAsmPath);
wDevObjCopyPath->value(mDevObjCopyPath);
wDevObjDumpPath->value(mDevObjDumpPath);

// ---- Dialog

wDontShow->value(dontShow);

updateMenus();} {}
  }
  Function {applyDialog()} {open return_type void
  } {
    code {// ---- MessagePad

free(ROMPath);
ROMPath = strdup(wROMPath->label());

free(FlashPath);
FlashPath = strdup(wFlashPath->label());

mFetchDateAndTime = wFetchDateAndTime->value();

const Fl_Menu_Item *m = wRAMSizeChoice->mvalue();
if (m)
	RAMSize = (int)m->argument();

// ---- User Interface

screenWidth = atoi(wWidth->value());
screenHeight = atoi(wHeight->value());
screenScale = atoi(wScale->value());
if (screenScale<=10)
	screenScale = 100;
fullScreen = wFullScreen->value();
hideMouse = wHideMouse->value();
mLaunchMonitorAtBoot = wLaunchMonitorAtBoot->value();
mBreakAtROMBoot = wBreakAtROMBoot->value();
mShowMenubar = wShowMenubar->value();
mShowToolbar = wShowToolbar->value();

// ---- PC Cards

startUpdateCardList();
for (int i=0; i<wPCCardList->size(); i++) {
	const char* name = wPCCardList->text(i + 1);
	TFLPCCardSettings* card = (TFLPCCardSettings*)wPCCardList->data(i + 1);
	updateNextCard(name, card);
}
endUpdateCardList();

// ---- Resources

free(mUnnaPath);
mUnnaPath = strdup(wUnnaPath->value());
free(mMessagepadOrgPath);
mMessagepadOrgPath = strdup(wMessagepadOrgPath->value());
free(mGitRepoPath);
mGitRepoPath = strdup(wGitRepoPath->value());

free(mDevAsmPath);
mDevAsmPath = strdup(wDevAsmPath->value());
free(mDevObjCopyPath);
mDevObjCopyPath = strdup(wDevObjCopyPath->value());
free(mDevObjDumpPath);
mDevObjDumpPath = strdup(wDevObjDumpPath->value());

// Dialog

dontShow = wDontShow->value();

updateMenus();} {}
  }
  Function {runningMode()} {open return_type void
  } {
    code {wRestartWarning->show();
wQuit->hide();
wStart->hide();
wRevert->show();
wSave->show();} {}
  }
  Function {close_window_cb(Fl_Widget*, void *user)} {private return_type void
  } {
    code {Fl_Window *win = (Fl_Window*)user;
win->hide();} {}
  }
  Function {createAboutDialog()} {open
  } {
    code {static const char *gLicenseText =
"<html><body>\\n"

"<h2>Licenses</h2>\\n"

"<h3>Einstein</h3>\\n"
"<p>\\n"
"Einstein is released under the GNU General Public License Version 2.\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://github.com/pguyot/Einstein/blob/master/LICENSE\\">LICENSE</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"

"<h3>GNUE newt/0</h3>\\n"
"<p>\\n"
"NEWT/0 is copyrighted free software by Makoto Nukui <gnue@so-kukan.com>. \\n"
"You can redistribute it and/or modify it under either the terms of the GPL \\n"
"version 2 (...).\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://github.com/gnue/NEWT0/blob/master/COPYING/COPYING.txt\\">COPYING.txt</a></li>\\n"
"<li>see: <a href=\\"https://github.com/gnue/NEWT0/blob/master/COPYING/LEGAL.txt\\">LEGAL.txt</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"

"<h3><a href=\\"http://www.fltk.org/\\">FLTK</a></h3>\\n"
"<p>\\n"
"FLTK is provided under the terms of the GNU Library Public "
"License, Version 2 with exceptions that allow for static "
"linking.\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://www.fltk.org/doc-1.4/license.html\\">license.html</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"

"<h3>libjpeg</h3>\\n"
"<p>\\n"
"This software is based in part on the work of the Independent JPEG Group.\\n"
"The software is supplied \\"as is\\". (...) Permission is hereby granted to use, copy, modify, and distribute this\\n"
"software (or portions thereof) for any purpose, without fee, subject to (...) conditions.\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://github.com/fltk/fltk/blob/master/jpeg/README\\">README</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"

"<h3>libpng</h3>\\n"
"<p>\\n"
"The software is supplied \\"as is\\". (...) Permission is hereby granted to use, copy, modify, and distribute\\n"
"this software, or portions hereof, for any purpose, without fee,\\n"
"subject to (...) restrictions\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://github.com/fltk/fltk/blob/master/png/LICENSE\\">LICENSE</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"

"<h3>zlib</h3>\\n"
"<p>\\n"
"This software is provided 'as-is', without any express or implied\\n"
"warranty. (...) Permission is granted to anyone to use this software for any purpose,\\n"
"including commercial applications, and to alter it and redistribute it\\n"
"freely, subject to (...) restrictions.\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://github.com/fltk/fltk/tree/master/zlib/README\\">README</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"

"<h3>HTTPRequest</h3>\\n"
"<p>\\n"
"This is free and unencumbered software released into the public domain.\\n"
"Anyone is free to copy, modify, publish, use, compile, sell, or\\n"
"distribute this software, either in source code form or as a compiled\\n"
"binary, for any purpose, commercial or non-commercial, and by any\\n"
"means.\\n"
"<ul>\\n"
"<li>see: <a href=\\"https://github.com/elnormous/HTTPRequest/blob/master/UNLICENSE\\">UNLICENSE</a></li>\\n"
"<li>Retrieved 2022-01-03</li>\\n"
"</ul></p>\\n"


"</body></html\\n";} {}
    code {static const char *gThanksText =
"<html><body>\\n"

"<h2>Contributors to Einstein</h2>\\n"

"<h4><a href=\\"https://github.com/pguyot\\">Paul Guyot</a></li></h4>\\n"
"Paul is the original author of Einstein. He introduced his \\"Newton Platform\\" at WWNC 2004.\\n"
"At WWNC 2006, he released Einstein Emulator as binaries for OS X and Zaurus.\\n"
"Releasing Einstein as an OpenSource project at WWNC 2007 in Tokyo made\\n"
"the emulator available to everyone. Later he added LLVM JIT translation and network emulation.\\n"

"<h4><a href=\\"https://github.com/MatthiasWM\\">Matthias Melcher</a></li></h4>\\n"
"Matthias ported Einstein to MSWindows, and later to iOS and Android.\\n"
"He has since unified the build process and added a full user interface\\n"
"for macOS, Windows, and Linux under FLTK.\\n"
"He added serial port and PCCard emulation and a minimal NewtonScript IDE.\\n"

"<h4><a href=\\"https://github.com/panicsteve\\">Steven Frank</a></li></h4>\\n"
"Steven updated Einstein for iOS and for native macOS,\\n"
"and he improved the debugging Monitor on macOS.\\n"

"<h4><a href=\\"https://github.com/ekoeppen\\">Eckhart K&ouml;ppen</a></li></h4>\\n"
"Eckhart and Paul added halfword operations to JIT to allow newer C compiler output\\n"
"to run on the emulator. He is working on more system conforming serial port drivers."

"<h4><a href=\\"https://github.com/chuma\\">Victor Rehorst</a></li></h4>\\n"
"Victor contributed the original CMake build files and PulseAudio fixes for Linux.\\n"
"He continues to build Einstein on Fedora Linux, and contribute where and when he can.\\n"

"<h4><a href=\\"https://github.com/jake-b\\">Jake Bordens</a></li></h4>\\n"
"Jake added CI to Einstein.\\n"

"<h4><a href=\\"https://github.com/turbolent\\">Bastian M&uuml;ller</a></li></h4>\\n"
"Bastian has fixed some aspects of the Android build.\\n"

"<p>...and many others who contributed before joining GitHub, who provided ideas,\\n"
"found missing documentation, and helped keeping the MessagePad alive.\\n"

"</body></html\\n";} {}
    Fl_Window wAbout {
      label {About Einstein}
      user_data wAbout
      callback {o->hide();} open
      xywh {451 216 340 260} type Double resizable non_modal size_range {340 260 340 0} visible
    } {
      Fl_Group {} {open
        xywh {10 30 320 180} hide resizable
      } {}
      Fl_Tabs {} {open
        xywh {10 10 320 200} box BORDER_BOX
        code0 {o->box((Fl_Boxtype)(FL_FREE_BOXTYPE+2));}
        class TFLTabs
      } {
        Fl_Group {} {
          label About open
          xywh {10 30 320 180} resizable
        } {
          Fl_Box {} {
            image {../../Resources/icons/EinsteinApp64.png} compress_image 0 xywh {133 47 69 75}
          }
          Fl_Box {} {
            label {Einstein Platform}
            xywh {72 123 190 25} labelfont 1
            code0 {o->label(PROJECT_NAME);}
          }
          Fl_Box {} {
            label {Version xxxx.xx.xx}
            xywh {72 150 190 20} labelsize 11
            code0 {o->label("Version " PROJECT_VER);}
          }
          Fl_Box {} {
            label {Copyright 2003-2024 by Paul Guyot and others}
            xywh {20 172 295 20} labelsize 11
            code0 {o->label(COPYRIGHT_STRING);}
          }
          Fl_Box {} {
            xywh {20 200 292 10} resizable
          }
        }
        Fl_Group {} {
          label Licenses open
          xywh {10 30 320 180} hide
        } {
          Fl_Help_View {} {
            xywh {10 31 320 179} box FLAT_BOX color 49 resizable
            code0 {o->value(gLicenseText);}
          }
        }
        Fl_Group {} {
          label Contributors open
          xywh {10 30 320 180} hide
        } {
          Fl_Help_View {} {
            xywh {10 31 320 179} box FLAT_BOX color 49 resizable
            code0 {o->value(gThanksText);}
          }
        }
      }
      Fl_Box {} {
        xywh {10 210 320 5}
        code0 {o->box((Fl_Boxtype)(FL_FREE_BOXTYPE+2));}
      }
      Fl_Button {} {
        label Close
        user_data wAbout
        callback {o->window()->hide();}
        xywh {220 224 95 20} labelsize 12
      }
    }
  }
  Function {HandlePopupMenu()} {
    comment override return_type void
  } {
    code {const Fl_Menu_Item *choice = TFLSettingsUI::menu_RMB->popup(Fl::event_x(), Fl::event_y());
if (choice && choice->callback()) {
    choice->callback_(RMB, choice->user_data_);
}} {}
  }
  declblock {\#if TARGET_OS_MAC} {open public after {\#endif}
  } {
    decl {Fl_Sys_Menu_Bar *wSysMenubar = nullptr;} {public local
    }
  }
}

comment {
// ======================================================== //
// Of course the code works. It just compiled, didn't it?   //
// --helixcode123, 11/8/2001 on slashdot.                   //
// ======================================================== //

} {in_source in_header
}
