<!--This file created 8/6/97 11:59 AM by Claris Home Page version 2.0--><HTML><HEAD>   <TITLE>Newton 2.x OS Q&amp;As</TITLE>   <META NAME=GENERATOR CONTENT="Claris Home Page 2.0">   <X-SAS-WINDOW TOP=49 BOTTOM=874 LEFT=530 RIGHT=1060></HEAD><BODY BGCOLOR="#FFFFFF"><P><CENTER><IMG SRC="pictures/newtninc.gif" WIDTH=187 HEIGHT=42BORDER=0 ALIGN=bottom></CENTER></P><H1><CENTER>Newton 2.x OS Q&amp;As</CENTER></H1><H4><CENTER>Copyright &copy; 1997 Newton, Inc. All Rights Reserved.Newton, Newton Technology, Newton Works, the Newton, Inc. logo, theNewton Technology logo, the Light Bulb logo and MessagePad aretrademarks of Newton, Inc. and may be registered in the U.S.A. andother countries. Windows is a registered trademark of Microsoft Corp.All other trademarks and company names are the intellectual propertyof their respective owners.</CENTER></H4><P><CENTER><BR>This document addresses Newton 2.x OS development issues that are notavailable in the currently printed documentation. Please note thatthis information is subject to change as the Newton technology anddevelopment environment evolve. If you have suggestions on how toimprove the quality or accessibility of the Newton Q&amp;As, pleaseemail J. Christopher Bell at bell@newton.apple.com. For the mostrecent version of the Q&amp;As on the World Wide Web, check the URL:<CODE><A HREF="http://www.newton-inc.com/dev/techinfo/qa/qa.htm">http://www.newton-inc.com/dev/techinfo/qa/qa.htm</A></CODE><BR>If you want one archive of Q&amp;As to download to your desktopcomputer, download the<A HREF="ftp://ftp.newton-inc.com/pub/developers/techinfo/qa/qa.zip">Windowsarchive</A> or<A HREF="ftp://ftp.newton-inc.com/pub/developers/techinfo/qa/qa.sea.hqx">MacOS archive</A>. This document was exported on 7/23/97.</CENTER></P><H2><A HREF="applicat.htm">Application Design</A></H2><UL>   <A HREF="#How_to_Prevent_an_Application_from_Becoming_a_Backdrop">How   to Prevent an Application from Becoming a Backdrop (8/8/93)<BR>      </A><A HREF="#The_Newton_Device_Reboots_When_Turned_On">The Newton   Device Reboots When Turned On (8/9/93)<BR>      </A><A HREF="#Optimizing_Base_View_Functions">Optimizing Base View   Functions (9/15/93)<BR>      </A><A HREF="#Code_Optimization">Code Optimization (9/15/93)<BR>      </A><A HREF="#Global_Name_Scope">Global Name Scope (6/7/94)<BR>      </A><A HREF="#How_to_Prevent_an_Application_From_Opening">How to   Prevent an Application From Opening (6/9/94)<BR>      </A><A HREF="#How_to_Create_a_Polite_Backdrop_Application">How to   Create a Polite Backdrop Application (1/19/96)<BR>      </A><A HREF="#How_to_Respond_to_Changes_From_a_Keyboard">How to   Respond to Changes From a Keyboard (2/6/96)<BR>      </A><A HREF="#How_to_Test_Your_Application">How to Test Your   Application (2/7/96)<BR>      </A><A HREF="#How_To_Make_An_Application_the_Backdrop">How To Make   An Application the Backdrop (8/23/96)<BR>      </A><A HREF="#Children_of_Exported_Protos_Are_Missing">Children of   Exported Protos Are Missing (9/20/96)<BR>      </A><A HREF="#How_to_Override_the_Standard_Button_Bar">How to   Override the Standard Button Bar (11/22/96)<BR>      </A><A HREF="#Creating_Large_Strings">Creating Large Strings   (1/3/97)<BR>      </A><A HREF="#Strategy_for_Saving_Modified_Data">Strategy for   Saving Modified Data (4/8/97)<BR>      </A><A HREF="#Detecting/Preventing_Package_Installation">Detecting/Preventing   Package Installation (4/18/97)<BR>      </A><B><A HREF="#Creating_About_Slips_for_Extensions">NEW:   </B>Creating About Slips for Extensions (4/27/97)<BR>      </A><B><A HREF="#Adding_a_DeletionScript_to_Your_Project">NEW:   </B>Adding a DeletionScript to Your Project (5/12/97)<BR>      </A></UL><H2><A HREF="builtina.htm">Built-In Apps and System Data</A></H2><UL>   <A HREF="#There_Is_No_ProtoFormulasPanel">There Is No   ProtoFormulasPanel (2/5/96)<BR>      </A><A HREF="#ProtoPrefsRollItem_Undocumented_Slots">ProtoPrefsRollItem   Undocumented Slots (2/6/96)<BR>      </A><A HREF="#SetEntryAlarm_Does_Not_Handle_Events">SetEntryAlarm   Does Not Handle Events (2/6/96)<BR>      </A><A HREF="#How_to_Avoid_CardFile_Extensions_"   still _needs _the _card ">How to Avoid CardFile Extensions "Still   needs the card" (5/9/96)<BR>      </A><A HREF="#How_to_Find_Distance_Between_Two_Points_on_the_Earth">How   to Find Distance Between Two Points on the Earth (6/7/96)<BR>      </A><A HREF="#Avoiding_Query_Bug_in_GetExtraIcons_Call">Avoiding   Query Bug in GetExtraIcons Call (8/2/96)<BR>      </A><A HREF="#How_to_Get_Labels_for_Custom_Names_Fields">How to   Get Labels for Custom Names Fields (8/13/96)<BR>      </A><A HREF="#How_to_Add_Confidential_Owner_Data">How to Add   Confidential Owner Data (10/1/96)<BR>      </A><A HREF="#Adding_Notes_to_Closed_Notes_Application">Adding   Notes to Closed Notes Application (1/14/97)<BR>      </A><A HREF="#TapAction_Slot_Requires_Text_Slot_to_be_Present">TapAction   Slot Requires Text Slot to be Present (1/15/97)<BR>      </A><A HREF="#Getting_the_Current_Set_of_Multi-User_Names">Getting   the Current Set of Multi-User Names (3/17/97)<BR>      </A><B><A HREF="#Registering_an_Auxillary_Button_for_Newton_Works">NEW:   </B>Registering an Auxillary Button for Newton Works (5/12/97)<BR>      </A><B><A HREF="#How_to_Create_Newton_Works_Documents">NEW:   </B>How to Create Newton Works Documents (5/15/97)<BR>      </A><B><A HREF="#Reading/Modifying_Newton_Works_Data">NEW:   </B>Reading/Modifying Newton Works Data (5/15/97)<BR>      </A><B><A HREF="#Opening_a_Specified_Document_in_Works">NEW:   </B>Opening a Specified Document in Works (5/27/97)<BR>      </A><B><A HREF="#Creating_a_Works_Word_Processor_Document_with_Data">NEW:   </B>Creating a Works Word Processor Document with Data   (6/9/97)<BR>      </A><B><A HREF="#Unregistering_Stamps_in_Newton_Works_Draw">NEW:   </B>Unregistering Stamps in Newton Works Draw (7/2/97)<BR>      </A></UL><H2><A HREF="controls.htm">Controls and Other Protos</A></H2><UL>   <A HREF="#How_to_Set_the_Letter_in_AZTab_Protos">How to Set the   Letter in AZTab Protos (3/26/96)<BR>      </A><A HREF="#Return_Value_of_ProtoSoupOverview's_HitItem_Message">Return   Value of ProtoSoupOverview's HitItem Message (1/6/97)<BR>      </A><A HREF="#Don't_Use_ROM_UpArrowBitmap">Don't Use   ROM_UpArrowBitmap (3/28/97)<BR>      </A><B><A HREF="#Dragging_a_View_Based_on_ProtoTXView">NEW:   </B>Dragging a View Based on ProtoTXView (7/8/97)<BR>      </A></UL><H2><A HREF="datastor.htm">Data Storage (Soups)</A></H2><UL>   <A HREF="#FrameDirty_is_Deep,_But_Can_Be_Fooled">FrameDirty is   Deep, But Can Be Fooled (8/19/94)<BR>      </A><A HREF="#Limits_on_Soup_Entry_Size">Limits on Soup Entry Size   (2/12/96)<BR>      </A><A HREF="#Choosing_EntryFlushXMit_and_EntryChangeXMit">Choosing   EntryFlushXMit and EntryChangeXMit (4/17/96)<BR>      </A><A HREF="#Limit_on_Soup_Name_Length">Limit on Soup Name Length   (12/10/96)<BR>      </A><A HREF="#How_to_Use_Begin_and_End_Symbols_with_WhichEnd">How   to Use Begin and End Symbols with WhichEnd (1/8/97)<BR>      </A><A HREF="#EntryChange_on_Modified_Tags_Array_Throws_-48022">EntryChange   on Modified Tags Array Throws -48022 (1/15/97)<BR>      </A><A HREF="#How_to_Avoid_Resets_When_Using_VBOs">How to Avoid   Resets When Using VBOs (2/27/97)<BR>      </A><B><A HREF="#Why_Xmit_Functions_Seem_to_Leak_Memory">CHANGED:   </B>Why Xmit Functions Seem to Leak Memory (5/5/97)<BR>      </A></UL><H2><A HREF="desktopc.htm">Desktop Connectivity (DILs)</A></H2><UL>   <A HREF="#Differences_between_MNP,_Modem,_Modem-MNP,_and_Real_Modems">Differences   between MNP, Modem, Modem-MNP, and Real Modems (2/5/96)<BR>      </A><A HREF="#CDPipeInit_Returning_-28102_on_MacOS_Computers">CDPipeInit   Returning -28102 on MacOS Computers (2/13/96)<BR>      </A><A HREF="#Getting_Serial_Port_Names_on_MacOS_Computers">Getting   Serial Port Names on MacOS Computers (2/13/96)<BR>      </A><A HREF="#Corruption_of_Some_Binary_Objects">Corruption of   Some Binary Objects (5/13/96)<BR>      </A><A HREF="#Error_-28801_or_-28706_from_FDget">Error -28801 or   -28706 from FDget (5/13/96)<BR>      </A><A HREF="#Using_CDPipeListen_Asynchronously_in_Windows_Applications">Using   CDPipeListen Asynchronously in Windows Applications (7/15/96)<BR>      </A><A HREF="#Unicode_Strings_and_Memory_Buffers">Unicode Strings   and Memory Buffers (8/26/96)<BR>      </A></UL><H2><A HREF="digitalb.htm">Digital Books</A></H2><UL>   <A HREF="#BookMaker_Page_Limitations_">BookMaker Page Limitations?   (11/19/93)<BR>      </A></UL><H2><A HREF="drawinga.htm">Drawing and Graphics</A></H2><UL>   <A HREF="#Drawing_Text_on_a_Slanted_Baseline">Drawing Text on a   Slanted Baseline (9/15/93)<BR>      </A><A HREF="#LCD_Contrast_and_Grey_Texture_Drawing">LCD Contrast   and Grey Texture Drawing (11/10/93)<BR>      </A><A HREF="#Destination_Rectangles_and_ScaleShape">Destination   Rectangles and ScaleShape (3/11/94)<BR>      </A><A HREF="#How_to_Rotate_Bitmaps_Left">How to Rotate Bitmaps   Left (3/5/96)<BR>      </A><A HREF="#Newton_Bitmap_Formats">Newton Bitmap Formats   (5/14/96)<BR>      </A><A HREF="#Difference_Between_LockScreen_and_RefreshViews">Difference   Between LockScreen and RefreshViews (1/15/97)<BR>      </A><A HREF="#Drawing_White_Text_on_a_Filled_Background">Drawing   White Text on a Filled Background (1/15/97)<BR>      </A><A HREF="#Interaction_Between_Transfer_Modes_and_Gray_Patterns">Interaction   Between Transfer Modes and Gray Patterns (1/15/97)<BR>      </A><A HREF="#Limitations_of_GrayShrink">Limitations of GrayShrink   (3/4/97)<BR>      </A><A HREF="#Limitations_of_MungeBitmap">Limitations of   MungeBitmap (4/3/97)<BR>      </A><B><A HREF="#Leave_Extra_Space_for_Text_When_Printing">NEW:   </B>Leave Extra Space for Text When Printing (5/7/97)<BR>      </A></UL><H2><A HREF="endpoint.htm">Endpoints &amp; Comm Tools</A></H2><UL>   <A HREF="#What_is_Error_Code_-18003">What is Error Code -18003   (3/8/94)<BR>      </A><A HREF="#Newton_Remote_Control_IR_(Infra-red)_API">Newton   Remote Control IR (Infra-red) API (6/9/94)<BR>      </A><A HREF="#Communications_With_No_Terminating_Conditions">Communications   With No Terminating Conditions (6/9/94)<BR>      </A><A HREF="#What_Really_Happens_During_Instantiate_&_Connect">What   Really Happens During Instantiate &amp; Connect (6/14/94)<BR>      </A><A HREF="#Unicode-ASCII_Translation_Issues">Unicode-ASCII   Translation Issues (6/16/94)<BR>      </A><A HREF="#How_To_Specify_No_Connect/Listen_Options">How To   Specify No Connect/Listen Options (2/1/96)<BR>      </A><A HREF="#Why_Synchronous_Comms_Are_Evil">Why Synchronous   Comms Are Evil (2/1/96)<BR>      </A><A HREF="#Maximum_Speeds_with_the_Serial_Port">Maximum Speeds   with the Serial Port (9/19/96)<BR>      </A><A HREF="#Why_Are_User_Modem_Settings_Ignored">Why Are User   Modem Settings Ignored (1/15/97)<BR>      </A><A HREF="#Handling_a_-36006_Error_When_Disconnecting">Handling   a -36006 Error When Disconnecting (1/17/97)<BR>      </A><A HREF="#InputSpec_Input_Form_'Frame_or_'Binary_Buffer_Bug">InputSpec   Input Form 'Frame or 'Binary Buffer Bug (1/22/97)<BR>      </A><A HREF="#How_to_Debug_Communication_Endpoint_Code">How to   Debug Communication Endpoint Code (3/21/97)<BR>      </A><A HREF="#XOn/XOff_Software_Flow_Control_Options">XOn/XOff   Software Flow Control Options (4/3/97)<BR>      </A><A HREF="#Sharp_IR_Protocol">Sharp IR Protocol (4/9/97)<BR>      </A><B><A HREF="#Using_Procrastinated_Actions_from_an_InputScript">NEW:   </B>Using Procrastinated Actions from an InputScript (7/2/97)<BR>      </A><B><A HREF="#Using_the_EventHandler_Event_Time_Slot">NEW:   </B>Using the EventHandler Event Time Slot (7/2/97)<BR>      </A></UL><H2><A HREF="errors.htm">Errors</A></H2><UL>   <B><A HREF="#What_Is_a_Nasty_Practice">NEW: </B>What Is a Nasty   Practice (5/12/97)<BR>      </A></UL><H2><A HREF="hardware.htm">Hardware &amp; OS</A></H2><UL>   <A HREF="#IR_Port_Hardware_Specs">IR Port Hardware Specs   (6/15/94)<BR>      </A><A HREF="#Serial_Cable_Specs">Serial Cable Specs (8/9/94)<BR>      </A><A HREF="#IR_Hardware_Info">IR Hardware Info (9/6/94)<BR>      </A><A HREF="#How_Much_Power_Can_a_PCMCIA_Card_Draw">How Much   Power Can a PCMCIA Card Draw (3/31/95)<BR>      </A><A HREF="#Do-it-Yourself_Package_Installation">Do-it-Yourself   Package Installation (8/26/96)<BR>      </A><A HREF="#Serial_Port_Hardware_Specs">Serial Port Hardware   Specs (4/9/97)<BR>      </A><B><A HREF="#Programmatically_Aligning_the_Pen">NEW:   </B>Programmatically Aligning the Pen (7/2/97)<BR>      </A></UL><H2><A HREF="localiza.htm">Localization</A></H2><UL>   <A HREF="#StringToDateFrame_&_StringToTime_Don't_Use_Seconds">StringToDateFrame   &amp; StringToTime Don't Use Seconds (5/9/96)<BR>      </A><A HREF="#How_GetDateStringSpec_Uses_Its_Element_Array">How   GetDateStringSpec Uses Its Element Array (3/31/97)<BR>      </A></UL><H2><A HREF="miscella.htm">Miscellaneous</A></H2><UL>   <A HREF="#Unicode_Character_Information">Unicode Character   Information (9/15/93)<BR>      </A><A HREF="#Using_the_Icon_Editor_in_NTK_1_6_4">Using the Icon   Editor in NTK 1.6.4 (4/18/97)<BR>      </A><B><A HREF="#Current_Versions_of_MessagePad_Devices">CHANGED:   </B>Current Versions of MessagePad Devices (7/22/97)<BR>      </A></UL><H2><A HREF="newtapp.htm">NewtApp</A></H2><UL>   <A HREF="#Creating_Preferences_in_a_NewtApp-based_Application">Creating   Preferences in a NewtApp-based Application (1/31/96)<BR>      </A><A HREF="#Creating_an_About_Slip_in_a_NewtApp-based_Application">Creating   an About Slip in a NewtApp-based Application (1/31/96)<BR>      </A><A HREF="#NewtSoup_FillNewSoup_Uses_Only_Internal_Store">NewtSoup   FillNewSoup Uses Only Internal Store (2/5/96)<BR>      </A><A HREF="#Setting_the_User_Visible_Name_With_NewtSoup">Setting   the User Visible Name With NewtSoup (2/6/96)<BR>      </A><A HREF="#How_to_Control_Sort_Order_in_NewtApp">How to Control   Sort Order in NewtApp (5/10/96)<BR>      </A><A HREF="#How_to_Avoid_NewtApp_"   please _insert _the _card " _errors>How to Avoid NewtApp "Please   Insert the Card" Errors (5/10/96)<BR>      </A><A HREF="#Customizing_Filters_with_Labelled_Input_Lines">Customizing   Filters with Labelled Input Lines (9/4/96)<BR>      </A><A HREF="#Using_Custom_Help_Books_in_a_NewtApp-based_Application">Using   Custom Help Books in a NewtApp-based Application (12/2/96)<BR>      </A><A HREF="#Creating_a_Large_newtEditView/newtROEditView">Creating   a Large newtEditView/newtROEditView (12/2/96)<BR>      </A><A HREF="#How_to_Use_ForceNewEntry_with_NewtApp">How to Use   ForceNewEntry with NewtApp (12/2/96)<BR>      </A><A HREF="#How_to_Programmatically_Open_the_Header_Slip">How to   Programmatically Open the Header Slip (1/3/97)<BR>      </A><A HREF="#Programmatically_Changing_the_Default_ViewDef">Programmatically   Changing the Default ViewDef (1/3/97)<BR>      </A><A HREF="#How_to_Properly_Declare_NewtApp_Views">How to   Properly Declare NewtApp Views (1/6/97)<BR>      </A><A HREF="#How_to_Create_Custom_Overviews_with_NewtApp">How to   Create Custom Overviews with NewtApp (1/8/97)<BR>      </A><A HREF="#How_to_Store_Prefs_in_a_NewtApp-based_Application">How   to Store Prefs in a NewtApp-based Application (1/17/97)<BR>      </A><A HREF="#A_CheckAll_Button_for_NewtApp_Overviews">A CheckAll   Button for NewtApp Overviews (3/4/97)<BR>      </A><A HREF="#Creating_a_Simple_NewtApp">Creating a Simple NewtApp   (4/7/97)<BR>      </A><B><A HREF="#Registering_Soup_Change_Notifications_in_NewtApp">NEW:   </B>Registering Soup Change Notifications in NewtApp (5/15/97)<BR>      </A></UL><H2><A HREF="newtonct.htm">Newton C++ Tools</A></H2><UL>   <A HREF="#Packed_Structures_in_C++_Tools">Packed Structures in C++   Tools (2/28/97)<BR>      </A></UL><H2><A HREF="newtonto.htm">Newton ToolKit</A></H2><UL>   <A HREF="#NTK,_Picture_Slots_and_ROM_PICTs">NTK, Picture Slots and   ROM PICTs (12/19/93)<BR>      </A><A HREF="#Recognition_Problems_with_the_Inspector_Window_Open">Recognition   Problems with the Inspector Window Open (3/8/94)<BR>      </A><A HREF="#Accessing_Views_Between_Layout_Windows">Accessing   Views Between Layout Windows (6/7/94)<BR>      </A><A HREF="#Dangers_of_StrCompare,_StrEqual_at_Compile_Time">Dangers   of StrCompare, StrEqual at Compile Time (6/9/94)<BR>      </A><A HREF="#Profiler_and_Frames_of_Functions">Profiler and   Frames of Functions (7/10/95)<BR>      </A><A HREF="#NTK_1_6_Heap/Partition_Memory_Issues">NTK 1.6   Heap/Partition Memory Issues (11/24/95)<BR>      </A><A HREF="#NTK_Search_and_Memory_Hoarding">NTK Search and   Memory Hoarding (11/24/95)<BR>      </A><A HREF="#NTK_Stack_Overflow_During_Compilation">NTK Stack   Overflow During Compilation (11/24/95)<BR>      </A><A HREF="#Unit_Import/Export_and_Interpackage_References">Unit   Import/Export and Interpackage References (11/25/95)<BR>      </A><A HREF="#Store_parts_and_PowerPC-native_NTK">Store parts and   PowerPC-native NTK (5/15/96)<BR>      </A><B><A HREF="#Using_Strings_as_Hex_Data_and_Windows_NTK">CHANGED:   </B>Using Strings as Hex Data and Windows NTK (7/18/97)<BR>      </A></UL><H2><A HREF="newtonsc.htm">NewtonScript</A></H2><UL>   <A HREF="#Nested_Frames_and_Inheritance">Nested Frames and   Inheritance (10/9/93)<BR>      </A><A HREF="#Symbol_Hacking">Symbol Hacking (11/11/93)<BR>      </A><A HREF="#Check_for_Application_Base_View_Slots">Check for   Application Base View Slots (3/6/94)<BR>      </A><A HREF="#Performance_of_Exceptions_vs_Return_Codes">Performance   of Exceptions vs Return Codes (6/9/94)<BR>      </A><A HREF="#NewtonScript_Object_Sizes">NewtonScript Object Sizes   (6/30/94)<BR>      </A><A HREF="#Symbols_vs_Path_Expressions_and_Equality">Symbols vs   Path Expressions and Equality (7/11/94)<BR>      </A><A HREF="#Function_Size_and_"   closed _over " _environment>Function Size and "Closed Over"   Environment (7/18/94)<BR>      </A><A HREF="#TrueSize_Incorrect_for_Soup_Entries">TrueSize   Incorrect for Soup Entries (2/6/96)<BR>      </A><A HREF="#Floating_Point_Numbers_Are_Approximations">Floating   Point Numbers Are Approximations (3/28/97)<BR>      </A><A HREF="#Real_Numbers_in_NewtonScript">Real Numbers in   NewtonScript (3/28/97)<BR>      </A></UL><H2><A HREF="pickersp.htm">Pickers, Popups and Overviews</A></H2><UL>   <A HREF="#Determining_Which_ProtoSoupOverview_Item_Is_Hit">Determining   Which ProtoSoupOverview Item Is Hit (2/5/96)<BR>      </A><A HREF="#Displaying_the_ProtoSoupOverview_Vertical_Divider">Displaying   the ProtoSoupOverview Vertical Divider (2/5/96)<BR>      </A><A HREF="#Validation_and_Editing_in_ProtoListPicker">Validation   and Editing in ProtoListPicker (4/1/96)<BR>      </A><A HREF="#Picker_List_is_Too_Short">Picker List is Too Short   (4/29/96)<BR>      </A><A HREF="#Tabs_Do_Not_Work_With_ProtoTextList">Tabs Do Not   Work With ProtoTextList (5/8/96)<BR>      </A><A HREF="#How_to_Avoid_Problems_with_ProtoNumberPicker">How to   Avoid Problems with ProtoNumberPicker (8/23/96)<BR>      </A><A HREF="#Single_Selection_in_ProtoListPicker-based_Views">Single   Selection in ProtoListPicker-based Views (9/20/96)<BR>      </A><A HREF="#How_to_Change_Font_or_LineHeight_in_ProtoListPicker">How   to Change Font or LineHeight in ProtoListPicker (9/20/96)<BR>      </A><A HREF="#How_to_Preselect_Items_in_ProtoListPicker">How to   Preselect Items in ProtoListPicker (9/20/96)<BR>      </A><A HREF="#How_to_Get_ProtoSoupOverview_Selections">How to Get   ProtoSoupOverview Selections (10/3/96)<BR>      </A><A HREF="#Dynamically_Adding_to_ProtoTextList_Confuses_Scrolling">Dynamically   Adding to ProtoTextList Confuses Scrolling (1/15/97)<BR>      </A><B><A HREF="#ProtoPicker_Lists_are_Sometimes_Blank">NEW:   </B>ProtoPicker Lists are Sometimes Blank (5/16/97)<BR>      </A><B><A HREF="#ProtoPeoplePicker_Name_Display_Changed_in_Newton_2_1">NEW:   </B>ProtoPeoplePicker Name Display Changed in Newton 2.1   (7/2/97)<BR>      </A><B><A HREF="#Setting_Default_Choices_for_Country_or_State_Pickers">NEW:   </B>Setting Default Choices for Country or State Pickers   (7/15/97)<BR>      </A></UL><H2><A HREF="recognit.htm">Recognition</A></H2><UL>   <A HREF="#Custom_Recognizers">Custom Recognizers (2/8/96)<BR>      </A><A HREF="#How_to_Save_and_Restore_Recognition_Settings">How to   Save and Restore Recognition Settings (4/9/96)<BR>      </A><A HREF="#Opening_the_Corrector_Window">Opening the Corrector   Window (3/17/97)<BR>      </A></UL><H2><A HREF="routing.htm">Routing</A></H2><UL>   <A HREF="#Printing_Resolution_72DPI/300DPI">Printing Resolution   72DPI/300DPI (2/8/94)<BR>      </A><A HREF="#PICT_Printing_Limitations">PICT Printing Limitations   (6/9/94)<BR>      </A><A HREF="#Printing_Fonts_with_a_PostScript_Printer">Printing   Fonts with a PostScript Printer (7/26/94)<BR>      </A><A HREF="#Printing_Does_Not_Have_Access_to_My_Application_Slots">Printing   Does Not Have Access to My Application Slots (11/27/95)<BR>      </A><A HREF="#How_to_Open_the_Call_Slip_or_Other_Route_Slips">How   to Open the Call Slip or Other Route Slips (12/19/95)<BR>      </A><A HREF="#Routing_Multiple_Items">Routing Multiple Items   (5/15/96)<BR>      </A><A HREF="#When_to_Call_Inherited_ProtoPrintFormat_ViewSetupFormScript">When   to Call Inherited ProtoPrintFormat ViewSetupFormScript   (1/6/97)<BR>      </A><A HREF="#Limitations_with_NewtOverview_Data_Class">Limitations   with NewtOverview Data Class (1/8/97)<BR>      </A><B><A HREF="#Beam_is_Partially_Available_for_Text_Routing">NEW:   </B>Beam is Partially Available for Text Routing (5/22/97)<BR>      </A><B><A HREF="#Page_Sizes_Cannot_Be_Determined_Before_Printing_Begins">NEW:   </B>Page Sizes Cannot Be Determined Before Printing Begins   (7/10/97)<BR>      </A><B><A HREF="#Not_All_Drawing_Modes_Work_with_a_PostScript_Printer">CHANGED:   </B>Not All Drawing Modes Work with a PostScript Printer   (7/16/97)<BR>      </A></UL><H2><A HREF="sound.htm">Sound</A></H2><UL>   <A HREF="#Finding_and_Adding_Alert_Sounds_">Finding and Adding   Alert Sounds (1/23/97)<BR>      </A></UL><H2><A HREF="statione.htm">Stationery</A></H2><UL>   <A HREF="#Limits_on_Stationery_Popups">Limits on Stationery Popups   (4/30/96)<BR>      </A><A HREF="#Dynamically_Changing_the_Height_of_Stationery">Dynamically   Changing the Height of Stationery (11/19/96)<BR>      </A><A HREF="#Properly_Registering_a_ViewDef">Properly Registering   a ViewDef (1/3/97)<BR>      </A></UL><H2><A HREF="systemse.htm">System Services, Find, and Filing</A></H2><UL>   <A HREF="#Preventing_Selections_in_the_Find_Overview">Preventing   Selections in the Find Overview (2/5/96)<BR>      </A><A HREF="#Creating_Custom_Finders">Creating Custom Finders   (2/5/96)<BR>      </A><A HREF="#How_to_Interpret_Return_Value_of_BatteryStatus">How   to Interpret Return Value of BatteryStatus (5/6/96)<BR>      </A><A HREF="#How_to_Create_Application-specific_Folders">How to   Create Application-specific Folders (5/14/96)<BR>      </A><A HREF="#Changing_ProtoStatusButton_Text_in_ProtoStatusTemplate">Changing   ProtoStatusButton Text in ProtoStatusTemplate (1/15/97)<BR>      </A></UL><H2><A HREF="textandi.htm">Text and Ink Input and Display</A></H2><UL>   <A HREF="#ProtoPhoneExpando_Bug_in_Setup1_Method">ProtoPhoneExpando   Bug in Setup1 Method (2/6/96)<BR>      </A><A HREF="#Pictures_in_clEditViews">Pictures in clEditViews   (2/6/96)<BR>      </A><A HREF="#Horizontal_Scrolling,_Clipping,_and_Text_Views">Horizontal   Scrolling, Clipping, and Text Views (2/7/96)<BR>      </A><A HREF="#How_to_Intercept_Keyboard_Events">How to Intercept   Keyboard Events (5/6/96)<BR>      </A><A HREF="#How_to_Keep_Multiple_Keyboards_Open">How to Keep   Multiple Keyboards Open (8/30/96)<BR>      </A><A HREF="#Adding_a_Local_Keyboard_to_a_ProtoKeyboardButton-based_Button">Adding   a Local Keyboard to a ProtoKeyboardButton-based Button   (1/14/97)<BR>      </A><A HREF="#Getting_Digital_Ink_to_the_Desktop">Getting Digital   Ink to the Desktop (1/17/97)<BR>      </A><A HREF="#Constraints_on_Keyboards_Sizing_to_the_View">Constraints   on Keyboards Sizing to the View (4/7/97)<BR>      </A><B><A HREF="#Using_a_Keyboard_Equivalent_to_Close_a_Subview">NEW:   </B>Using a Keyboard Equivalent to Close a Subview (5/12/97)<BR>      </A><B><A HREF="#Finding_a_KeyCommand_by_KeyMessage">NEW:   </B>Finding a KeyCommand by KeyMessage (6/16/97)<BR>      </A></UL><H2><A HREF="transpor.htm">Transports</A></H2><UL>   <A HREF="#Adding_Child_Views_to_a_ProtoTransportHeader-based_View">Adding   Child Views to a ProtoTransportHeader-based View (1/19/96)<BR>      </A><A HREF="#How_to_Omit_Default_Transport_Preference_Views">How   to Omit Default Transport Preference Views (5/6/96)<BR>      </A><A HREF="#How_to_Stop_ProtoAddressPicker_Memory">How to Stop   ProtoAddressPicker Memory (9/20/96)<BR>      </A><A HREF="#ReceiveRequest_Requests_Incorrect_After_Using_RemoveTempItems">ReceiveRequest   Requests Incorrect After Using RemoveTempItems (10/1/96)<BR>      </A><A HREF="#Filing_Sent_Entries_in_the_Out_Box">Filing Sent   Entries in the Out Box (1/14/97)<BR>      </A><A HREF="#Documentation_on_the_InboxFiling_Preference">Documentation   on the InboxFiling Preference (1/15/97)<BR>      </A><B><A HREF="#Adding_an_Auto_Put_Away_Transport_Preference">NEW:   </B>Adding an Auto Put Away Transport Preference (5/14/97)<BR>      </A></UL><H2><A HREF="utilityf.htm">Utility Functions</A></H2><UL>   <A HREF="#What_Happened_to_FormattedNumberStr">What Happened to   FormattedNumberStr (2/12/96)<BR>      </A><A HREF="#Backlight_API">Backlight API (4/19/96)<BR>      </A><A HREF="#Unusual_Sort_Order/Case_Sensitivity_in_Swedish_Locale_">Unusual   Sort Order/Case Sensitivity in Swedish Locale (1/16/97)<BR>      </A><A HREF="#Time_Zones,_GMT,_Daylight_Savings,_and_Newton_Time">Time   Zones, GMT, Daylight Savings, and Newton Time (3/4/97)<BR>      </A><A HREF="#Square_Root_of_Negative_Number_Bug">Square Root of   Negative Number Bug (3/4/97)<BR>      </A><A HREF="#Making_Use_of_the_Serial_Number_Chip">Making Use of   the Serial Number Chip (4/3/97)<BR>      </A><A HREF="#Programmatically_Cancelling_a_Confirm_Slip">Programmatically   Cancelling a Confirm Slip (4/3/97)<BR>      </A></UL><H2><A HREF="views.htm">Views</A></H2><UL>   <A HREF="#How_to_Save_the_Contents_of_clEditView">How to Save the   Contents of clEditView (10/4/93)<BR>      </A><A HREF="#Adding_Editable_Text_to_clEditViews">Adding Editable   Text to clEditViews (6/9/94)<BR>      </A><A HREF="#TieViews_and_Untying_Them">TieViews and Untying Them   (6/9/94)<BR>      </A><A HREF="#Immediate_Children_of_the_Root_View_Are_Special">Immediate   Children of the Root View Are Special (11/17/94)<BR>      </A><A HREF="#ViewIdleScripts_and_clParagraphViews">ViewIdleScripts   and clParagraphViews (8/1/95)<BR>      </A><A HREF="#FilterDialog_and_ModalDialog_Limitations">FilterDialog   and ModalDialog Limitations (2/5/96)<BR>      </A><A HREF="#Using_Proportional_View_Alignment_Correctly">Using   Proportional View Alignment Correctly (6/20/96)<BR>      </A><A HREF="#Drag_and_Drop_Caches_the_Background_Bitmap">Drag and   Drop Caches the Background Bitmap (7/15/96)<BR>      </A><A HREF="#Default_and_Close_Keys_in_Confirm_Slips">Default and   Close Keys in Confirm Slips (2/28/97)<BR>      </A><A HREF="#Screen_Rotation_and_Linked_Views_or_BuildContext_Slips">Screen   Rotation and Linked Views or BuildContext Slips (3/10/97)<BR>      </A><A HREF="#How_to_Get_Data_From_a_ProtoTXView_Externalized_Data">How   to Get Data From a ProtoTXView Externalized Data (4/3/97)<BR>      </A><A HREF="#Extracting_All_Text_from_a_ProtoTXView_Object">Extracting   All Text from a ProtoTXView Object (4/3/97)<BR>      </A><B><A HREF="#Finding_the_Caret_In_a_clParagraphView-based_View">NEW:   </B>Finding the Caret In a clParagraphView-based View   (5/12/97)<BR>      </A><B><A HREF="#Scrollers_Sometimes_Go_Too_Fast">NEW:   </B>Scrollers Sometimes Go Too Fast (6/9/97)<BR>      </A></UL><H2>Application Design</H2><P><A NAME="How_to_Prevent_an_Application_from_Becoming_a_Backdrop"></A></P><H3><HR>How to Prevent an Application from Becoming a Backdrop (8/8/93)</H3><DL>   <DD>Q: Is there a way an application can request not to be a   backdrop application?<BR>      <BR>      A: Yes, adding a non-<CODE>nil</CODE> <CODE>'noBackdrop</CODE>   slot to the base view will stop an application from becoming a   backdrop application.</DL><P><A NAME="The_Newton_Device_Reboots_When_Turned_On"></A></P><H3><HR>The Newton Device Reboots When Turned On (8/9/93)</H3><DL>   <DD>Q: My application has a really tight loop which can take more   than a dozen seconds to finish. If the user turns off the Newton   while my application is running, nothing happens at first, but   finally the Newton turns off. The Newton device reboots when   turned on. Why?<BR>      <BR>      A: The reboot is happening because of a design goal. When the   Newton OS learns the user wants to do a power off, the OS checks   with the running application and says "Please get ready to shut   down." If there is no response within about ten seconds the OS   assumes that the process could be in an infinite loop. Since the   user wants to turn off the Newton device, the OS terminates the   application. When powering back up, there is no real clean state   to return to, so the OS causes a reboot.<BR>      <BR>      To work around this problem break up long processes so they can   run in an <CODE>viewIdleScript</CODE>. In general, applications   should release the CPU now and then so the OS can do clean up   operations.</DL><P><A NAME="Optimizing_Base_View_Functions"></A></P><H3><HR>Optimizing Base View Functions (9/15/93)</H3><DL>   <DD><BR>      Q: I've got this really tight loop that executes a "global"   function. The function isn't really global, it's defined in my   base view and the lookup time to find it slows down my code. Is   there anything I can do to optimize it?<BR>      <BR>      A: If the function does not use inheritance or   "<CODE>self</CODE>", you can speed things up by doing the lookup   explicitly once before executing the loop, and using the call   statement to execute the function within the body of the loop.<BR>      <BR>      Here's some code you can try inside the Inspector window:<BR>            <PRE><CODE>    f1 := {myFn: func() 42};    f2 := {_parent: f1};    f3 := {_parent: f2};    f4 := {_parent: f3};    f5 := {_parent: f4};    f5.test1 := func ()        for i:=1 to 2000 do call myFn with ();    f5.test2 := func() begin         local fn := myFn;         for i:=1 to 2000 do call fn with ();         end&nbsp;    /* executes with a noticeable delay */    f5:test1();&nbsp;    /* executes noticeably faster */    f5:test2();&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Use this technique only for functions that don't use   inheritance or the self keyword.<BR>      <BR>      Note for MacOS programmers: this trick is analogous to the MacOS   programming technique of using <CODE>GetTrapAddress</CODE> to get   a trap's real address and calling it directly to avoid the   overhead of trap dispatch.<BR>      </P></DL><P><A NAME="Code_Optimization"></A></P><H3><HR>Code Optimization (9/15/93)</H3><DL>   <DD>Q: Does the compiler in the Newton Toolkit reorder expressions   or fold floating point constants? Can the order of evaluation be   forced (as with ANSI C)?<BR>      <BR>      A: The current version of the compiler doesn't do any serious   optimization, such as eliminating subexpressions, or reordering   functions; however, this may change in future products. (Note: NTK   1.6 added constant folding, so for example <CODE>2+3</CODE> will   be replaced with <CODE>5</CODE> by the compiler.) In the meantime,   you need to write your code as clearly as possible without relying   too heavily on the ordering of functions inside expressions.<BR>      <BR>      The current version of the NTK compiler dead-strips conditional   statements from your application code if the boolean expression is   a simple constant. This feature allows you to compile your code   conditionally.<BR>      <BR>      For example, if you define a <CODE>kDebugMode </CODE>constant in   your project and have in your application a statement conditioned   by the value of <CODE>kDebugMode</CODE>, the NTK compiler removes   the entire if/then statement from your application code when the   value of <CODE>kDebugMode </CODE>is NIL.<BR>      <BR>            <PRE><CODE>constant kDebugMode := true;         // define in Project Dataif kDebugMode then Print(...);     // in application code</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      When you change the value of the <CODE>kDebugMode </CODE>constant   to NIL, then the compiler strips out the entire if/then statement.   </P></DL><P><A NAME="Global_Name_Scope"></A></P><H3><HR>Global Name Scope (6/7/94)</H3><DL>   <DD>Q: What is the scope of global variables and functions?<BR>      <BR>      A: In NewtonScript, global functions and variables are true   globals. This means that if you create global functions and global   variables, you might get name clashes with other possible globals.   As this system is dynamic, you can't do any pre-testing of   existing global names.<BR>      <BR>      Here are two recommended solutions in order to avoid name space   problems:<BR>      <BR>      Use your signature in any slot you create that is outside of the   domain of your own application.<BR>      <BR>      Unless you really want a true global function or variable, place   the variable or function inside your base view template. You are   actually able to call this function or access this variable from   other applications, because the base view is declared to the root   level.<BR>      <BR>      If you really need to access the function or variable from a view   that is not a descendent of your base view (like a floater that is   a child of the root view), you might do something like:<BR>      <BR>            <PRE><CODE>    if getroot().|MyBaseView:MySIG| then        begin            getroot().|MyBaseView:MySIG|:TestThisView();            local s := getroot().|MyBaseView:MySIG|.BlahSize;        end;</CODE></PRE></DL><P><A NAME="How_to_Prevent_an_Application_From_Opening"></A></P><H3><HR>How to Prevent an Application From Opening (6/9/94)</H3><DL>   <DD>Q: I do not want my application to open sometimes, for example   because the screen size is too small, or because the Newton OS   version is wrong. What's the best way to prevent it?<BR>      <BR>      A: Check for whatever constraints or requirements you need early,   if not in the <CODE>installScript</CODE>, then in the   <CODE>viewSetupFormScript</CODE> for the application's base view.   In your case, you can do some math on the frame returned from   <CODE>GetAppParams </CODE>to see if the screen is large enough to   support your application.<BR>      <BR>      If you do not want the application to open, do the following:<BR>      &#149;Call <CODE>Notify</CODE> to tell the user why your   application cannot run.<BR>      &#149;Set the base view's <CODE>viewBounds</CODE> so it does not   appear, use<BR>      <CODE>RelBounds(-10, -10, 0, 0)</CODE> so the view will be   off-screen.<BR>      &#149;Possibly set (and check) a flag so expensive startup things   do not happen.<BR>      &#149;Possibly set the base view's <CODE>viewChildren </CODE>and   <CODE>stepChildren </CODE>slots to NIL.<BR>      &#149;call <CODE>AddDeferredSend(self, 'Close, nil)</CODE> to   close the view.</DL><P><A NAME="How_to_Create_a_Polite_Backdrop_Application"></A></P><H3><HR>How to Create a Polite Backdrop Application (1/19/96)</H3><DL>   <DD>Q: How do I get backdrop behavior in my application?<BR>      <BR>      A: Backdrop behavior is given to you for free. If your   applications close box is based on <CODE>protoCloseBox </CODE>or   <CODE>protoLargeCloseBox </CODE>then your close box will   automatically hide itself if your application is the backdrop   application. If you also use <CODE>newtStatusBar </CODE>as your   status bar proto, the appropriate buttons will shift to fill the   gap left by the missing close box. Note that you do not have to   use the NewtApp framework to use the <CODE>newtStatusBar   </CODE>proto.<BR>      <BR>      The system will automatically override the <CODE>Close </CODE>and   <CODE>Hide </CODE>methods so your application cannot be   closed.<BR>      <BR>      If you need to know which application is the backdrop application,   you can find the appSymbol of the current backdrop app with   <CODE>GetUserConfig('blessedApp)</CODE>.<BR>      <BR>      Here are some tips on being a polite backdrop application:<BR>      &#149;Your application should be full-screen. (Set "Styles" as the   backdrop to see why.)<BR>      &#149;A polite backdrop application will also add the registered   auxiliary buttons to its status bar. See the "Using Auxiliary   Buttons" in the Newton Programmers Guide (Chapter 18.)</DL><P><A NAME="How_to_Respond_to_Changes_From_a_Keyboard"></A></P><H3><HR>How to Respond to Changes From a Keyboard (2/6/96)</H3><DL>   <DD>Q: I open a custom keyboard to edit my view. How can I tell   that the keyboard has been closed so that I can process the   potentially modified contents of the view?<BR>      <BR>      A: The <CODE>viewChangedScript </CODE>for the view will be called   each time the user does something to modify the view. For   keyboards, this means the script is called each time the user taps   a key. This is the only notification that is provided to indicate   the view contents have changed.<BR>      <BR>      There are no hooks you can use to tell you when standard keyboards   have closed. If you implement your own keyboard, you could provide   a <CODE>viewQuitScript </CODE>or other custom code to explicitly   notify the target that the keyboard is going away, but we do not   recommend this. (There may be a hardware keyboard attached, a   system keyboard may be open, or the user may be writing into your   view. It is a mistake to assume that the only way to modify your   view is through your own keyboard.)<BR>      <BR>      If the processing you need to do is lengthy and would interfere   with normal typing on the keyboard, you can arrange it so the   processing won't start for a few seconds. This usually gives the   user time to type another key, which can then further delay the   processing.<BR>      <BR>      To make this "watchdog timer" happen, use the idle mechanism as   your timer. Put the code to process the changes in the   <CODE>viewIdleScript </CODE>(or call it from the   <CODE>viewIdleScript</CODE>.) In the   <CODE>viewChangedScript</CODE>, if the <CODE>'text</CODE> slot has   changed, use <CODE>:SetupIdle(&lt;delay&gt;)</CODE> to arrange for   the <CODE>viewIdleScript </CODE>to be called in a little   while.<BR>      <BR>      If <CODE>:SetupIdle(&lt;delay&gt;)</CODE> happens again before the   first delay goes by (perhaps because the user typed another key,)   the idle script will be called after the new delay. The older one   is ignored. <CODE>SetupIdle </CODE>resets the timer each time it's   called.<BR>      <BR>      Don't forget to have the <CODE>viewIdleScript </CODE>return   <CODE>NIL </CODE>so it won't be called repeatedly.<BR>   </DL><P><A NAME="How_to_Test_Your_Application"></A></P><H3><HR>How to Test Your Application (2/7/96)</H3><DL>   <DD>Q: Before I ship my application, what should I test?<BR>      <BR>      A: Although there is no complete answer, the following is a quick   outline of things that should be tested to ensure compatibility   with the Newton OS. Items that are OS or Locale specific are   noted. Also note that this list only covers current Apple   MessagePad devices.<BR>      <BR>      This is something to help you think of other areas to test.   Covering the areas in this list should improve the stability of   your application, but is not guaranteed to make it stable and   fool-proof.<BR>      <BR>      This list does not cover the functionality of the application   itself. That is, it is not a test plan for your application.<BR>      <BR>      1. Versions (Latest supported system updates)<BR>      See Current versions of MessagePad devices in the Misc.   Q&amp;A<BR>      <BR>      2. Basic Functional Testing<BR>      2.1. Launch and use app from internal RAM, memory card, locked   memory card, in rotated mode<BR>      <BR>      3. Data Manipulation<BR>      3.1. Create and store data in internal RAM<BR>      3.2. Create and store data to memory card<BR>      3.3. Delete data from internal RAM<BR>      3.4. Delete data from memory card<BR>      3.5. Move data from internal RAM to memory card and vice versa<BR>      3.6. Duplicate data<BR>      3.7. Find data with app frontmost<BR>      3.8. Find data in app using Find All from paperroll<BR>      3.9. Find data in all editable fields<BR>      3.10. Check the app name in the Find slip when "Selected" is   checked, and check that the app name is correct for the radio   button in the Find slip<BR>      3.11. If the app implements custom find, make sure other types of   find (selected and everywhere) still work.<BR>      3.12. Select and Copy data to and from clipboard<BR>      3.13. Backup to memory card and restore to different Newton   device. Verify that data is intact.<BR>      3.14. Backup via NBU and restore to different Newton device.   Verify that data is intact.<BR>      3.15. File data into folders (if supported.)<BR>      <BR>      4. Communications<BR>      4.1. Print data to serial printer and network printer<BR>      4.2. Fax data<BR>      4.3. Beam data to another 2.x Newton device<BR>      4.4. Beam data to a 1.x Newton<BR>      4.5. Backup and restore data and app to memory card<BR>      4.6. Backup and restore data and app with NBU<BR>      <BR>      5. Exception Testing (all of the following should cause   exceptions)<BR>      5.1. Create new data to locked memory card<BR>      5.2. Delete data from locked memory card<BR>      5.3. Move data from internal memory to locked card<BR>      5.4. Beam data to a Newton device that does not have the expected   application<BR>      5.5. With application running from memory card, unlock card with   application open.<BR>      5.6. With application installed on memory card, unlock card with   application closed.<BR>      5.7. Install application on memory card, run application, create   data, close application, remove memory card.<BR>      5.8. Turn power off while application is running (PowerOff   handler?)<BR>      5.9. Attempt to create new data with store memory full.<BR>      5.10. Run application with low frames heap (us HeapShow to reserve   memory)<BR>      5.11. If appropriate, run application with low system heap.<BR>      <BR>      6. Misc.<BR>      6.1. Does application work if soup is entirely deleted from   Storage folder in Extras?<BR>      6.2. Delete application. Does any part stay behind? (icons? menus?   etc.)<BR>      6.3. Check store memory and frames heap, install application,   check store memory and frames heap. Do this several times and   check for consistency<BR>      6.4. Do 6.3. and also check store and frames memory after removing   application. Is all/most of the memory restored?<BR>      6.5. Check frames heap. Launch &amp; use application. Check heap.   Close application. Check heap.<BR>      6.6. Does the application add anything to the Preferences App?<BR>      6.7. Does the application add Prefs and Help to the "i" icon?<BR>      6.8. Does the application add anything to Assist, How Do I?<BR>      6.9. Launch with pager card installed<BR>      6.10. Check layout issues on MP100 vs. MP110 screen sizes (if   application runs in 1.x.)<BR>      6.11. If multiple applications are bundled together, open all at   the same time, check to see that the applications together aren't   using too much frames heap.<BR>      6.12. Open, use, and close the application many times. Check   frames heap afterward to check for leaks.<BR>      6.13. If application has multiple components and components can be   removed separately, verify that application does the right thing   when components are missing.<BR>      6.14. Test application immediately after cold resets and warm   resets.<BR>      <BR>      7. Compatibility<BR>      7.1. After application is installed and run, do the built-in   applications work:<BR>      Names, Dates, To Do List, Connection, InBox, OutBox, Calls,   Calculator, Formulas, Time Zones, Clock, Styles, Help, Prefs,   Owner Info, Setup, Writing Practice.<BR>      7.2. If the application can be the backdrop (this is the default   case)<BR>      7.2.1 Do the built-in applications continue to work? The list is   as in 7.1. and Extras.<BR>      7.2.2 Do printing and faxing work?<BR>      7.2.3 Run through the other tests in this document with your   application as backdrop.<BR>      7.3. If the application can operate in the rotated mode<BR>      7.3.1. Perform all tests with the application in rotated mode as   well.<BR>      7.3.2. Check that screen layouts look correct.</DL><P><A NAME="How_To_Make_An_Application_the_Backdrop"></A></P><H3><HR>How To Make An Application the Backdrop (8/23/96)</H3><DL>   <DD>Q: Is there a way to programmatically change the backdrop   application?<BR>      <BR>      A: Yes, but only if the "new" backdrop application is one of your   applications. Do not set another application to be the backdrop   application. <CODE>GetRoot():BlessApp(appSymbol) </CODE>will close   the current backdrop application and open the new backdrop   application if necessary. Note that <CODE>appSymbol</CODE> must be   a valid application symbol of a current installed and active   application. <CODE>BlessApp</CODE> does NOT verify that an   application can become the backdrop (for instance, it doesn't   check the <CODE>'noBackdrop</CODE> flag for an application). For   this reason, <CODE>BlessApp</CODE> must only be used on your own   applications. See the Newton DTS Q&amp;A, "How to Prevent an   Application from Becoming a Backdrop" for more information about   the <CODE>'noBackdrop</CODE> flag.<BR>      <BR>      Do not call <CODE>BlessApp</CODE> from within a part's   <CODE>installScript</CODE> or <CODE>removeScript</CODE>. If you   want to do something like this, use a delayed call to use   <CODE>BlessApp</CODE>.<BR>      <BR>   </DL><P><A NAME="Children_of_Exported_Protos_Are_Missing"></A></P><H3><HR>Children of Exported Protos Are Missing (9/20/96)</H3><DL>   <DD>Q: I have a template that is based on a user proto imported by   my package. When the view based on my template opens, none of the   exported proto's children show up. What is going on?<BR>      <BR>      A: When you create children of templates in Newton Toolkit, they   are collected in the <CODE>stepChildren</CODE> slot of the base   view of the template file. If both the exported and importing   template have children, they will both have a   <CODE>stepChildren</CODE> slot. The result is that the   <CODE>stepChildren</CODE> slot of the importing prototemplate is   masking the one in the exported proto. The instantiated view does   not collect all the children from the entire proto chain (though   NTK does do this at compile time for user proto templates).<BR>      <BR>      The solution for exported user protos with   <CODE>stepChildren</CODE> is to add a   <CODE>viewSetupChildrenScript</CODE> to either your exported proto   template or the importer that collects all of the   <CODE>stepChildren</CODE> into a runtime <CODE>stepChildren</CODE>   array.<BR>      <BR>            <PRE><CODE>// AFTER setting up stepChildren, views which "import" this proto// must call inherited:?viewSetupChildrenScript();exporter.viewSetupChildrenScript := func()  begin    // get the current value of the "extra" kids    // ...unless the importer added NO kids, in which case, these are OURS    local extraKids := stepChildren;            local items := clone(extraKids);    local kids;        local whichFrame := self;         while (whichFrame) do      begin        // get kids, but NOT using inheritance        kids := GetSlot(whichFrame, 'stepChildren);                 // copy any extra stepChildren (but if NO extra kids are defined, don't copy twice!)        if kids and kids &lt;&gt; extraKids then           ArrayMunger(items, 0, 0, kids, 0, nil);                  // go deeper into the _proto chain (or set whichFrame to nil)        whichFrame := whichFrame._proto;       end;        &nbsp;    stepChildren := items;  end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that you will have similar problems with declared children.   If you have declared children you will also need to collect the   <CODE>stepAllocateContext</CODE> slot.</P></DL><P><A NAME="How_to_Override_the_Standard_Button_Bar"></A></P><H3><HR>How to Override the Standard Button Bar (11/22/96)</H3><DL>   <DD>Q: What's the proper way to override the button bar,   especially to cover up the buttons on the Newton OS 2.1   devices?<BR>      <BR>      A: We don't recommend that typical applications obscure, cover up,   or otherwise modify the standard button bar. From a user interface   standpoint, it's a bad idea, because it can make the unit look   unfamiliar or (in extreme cases) unusable. Some applications,   typically those created for vertical markets, are designed to   "take over" the interface, in which case it may be permissible to   cover or disable the button bar.<BR>      <BR>      <CODE>GetRoot().buttons.soft</CODE> will be non-<CODE>nil</CODE>   if there is a "soft" button bar, that is, the button bar is   located on the drawable screen. <CODE>GetRoot():LocalBox()   </CODE>returns the rectangle that encloses the screen and the   tablet. <CODE>GetAppParams</CODE>() returns information about the   useful area of the screen, excluding the soft or hard button bar.   Used together, this information will allow you to implement any   combination of button bar disabling and/or button bar   obscuring.<BR>      <BR>      (There is also an Newton 2.1 OS function called   <CODE>KillStdButtonBar</CODE>. That API is designed for use when   you want to actually remove the button bar so you can replace it -   probably with a floating slip. It is a fairly expensive call and   does a lot of things you don't need if all you want to do is take   over the screen. We recommend avoiding that call if possible.)<BR>      <BR>      If the goal is simply to maximize the visible area of the base   view, then the button bar should be obscured only for devices with   a soft button bar (for instance, a MessagePad 2000). On devices   with a "hard" button bar (for instance, a MessagePad 130), the   root view encompasses a larger area than the LCD display because   the input tablet is larger to account for the "hard" button bar.   Drawing is limited to the screen so applications wouldn't increase   their visible area by covering the "hard" button bar.<BR>      <BR>      The "soft" button bar can simply be covered by your application's   base view. The only trick is properly detecting if there is a soft   button bar, and finding out where on the screen it happens to be.   This code will give you the largest drawable application box,   covering any soft button bar but not covering any hard   buttons.<BR>            <PRE><CODE>    local params := GetAppParams();    if GetRoot().Buttons.soft then        self.viewBounds := OffsetRect(UnionRect(params.appArea, params.buttonBarBounds),            -params.appAreaGlobalLeft, -params.appAreaGlobalTop)    else        self.viewBounds := params.appArea;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      If the goal is to to prevent users from accessing the buttons,   then the button bar should be obscured regardless of whether or   not it is on the LCD screen. On units with a hard button bar, you   must take into account the fact that part of the base view will be   off-screen. (For instance, don't place your close box under the   silk-screened buttons.) A simple way to accomplish this is by   having a child view whose bounds are the <CODE>appArea</CODE> and   locating the rest of the application within that child.<BR>      <BR>      Note that on some Newton devices (for instance, the eMate 300),   the buttons are not located in a view at all. On these devices,   covering the entire tablet does not prevent the user from   accessing the buttons (for instance, opening up the Extras   Drawer).<BR>      <BR>      Below is some sample code you can add to your base view's   <CODE>viewSetupFormScript</CODE> to cover the entire tablet:<BR>      <BR>      </P>      <PRE><CODE>    local params := GetAppParams();    self.viewBounds := GetRoot():LocalBox();    if params.appAreaGlobalLeft then        self.viewBounds := OffsetRect(self.viewBounds, -params.appAreaGlobalLeft, -params.appAreaGlobalTop);</CODE>&nbsp;</PRE></DL><P><A NAME="Creating_Large_Strings"></A></P><H3><HR>Creating Large Strings (1/3/97)</H3><DL>   <DD>Q: What is the best way to create a really large string?<BR>      <BR>      A: The best way is to create the string as a virtual binary object   (VBO). VBOs are described in the chapter "Data Storage and   Retrieval" in the Newton Programmer's Guide.<BR>      <BR>      To create a string as a VBO, you first need to create a VBO of   class <CODE>'string</CODE>. Next, you need to use the global   function <CODE>BinaryMunger</CODE> to munge an empty string into   the VBO. This will properly prepare the binary object to be used   as a NewtonScript string.<BR>      <BR>      Finally, use the global function <CODE>StrMunger</CODE> as often   as needed to copy new string data into the VBO. Here is a code   example:<BR>      <BR>            <PRE><CODE>// Prepare a VBO to be the stringlocal myString := GetDefaultStore():NewVBO( 'string, Length("") );BinaryMunger( myString, 0, nil, "", 0, nil );&nbsp;StrMunger( myString, StrLen( myString ), nil, "My new string", 0, nil );// Repeat with more data if necessary...</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that unlike the C language's <CODE>stdio</CODE> library   function, the NewtonScript <CODE>StrLen</CODE> function does not   need to traverse the string to determine the string length, so you   probably don't need to worry about performance hits from its   usage.<BR>      <BR>      Not all NewtonScript routines will necessarily "preserve" the VBO   nature of large strings. For instance, if you concatenate strings   using the <CODE>Stringer</CODE> global function or the &amp; or   &amp;&amp; operators, the result is currently a non-VBO string. Be   aware that if you accidentally create a very large non-VBO string,   the code may throw a "out of NewtonScript heap memory"   <CODE>evt.ex.outofmem</CODE> exception.</P></DL><P><A NAME="Strategy_for_Saving_Modified_Data"></A></P><H3><HR>Strategy for Saving Modified Data (4/8/97)</H3><DL>   <DD>Q: What's the best way to save modified data to a soup? For   example, if I try to save the contents of a   <CODE>clEditView</CODE> every time some change is made, typing is   very slow. So, when should it be saved?<BR>      <BR>      A: The best way we've found is to start a timer every time a   change is made, and save the data when the timer expires. If a   change is made before the timer expires, you can reset the timer.   This way, the longer operation of saving to a soup won't happen   until after the user pauses for a few seconds, but data will still   be protected from resets. The data should also be saved when the   views that edit it are closed, or when switching data items.<BR>      <BR>      The timer can be implemented several ways. If no view is   available, <CODE>AddDelayedCall</CODE> or   <CODE>AddDelayedSend</CODE> can be used. The OS also provides   <CODE>AddProcrastinatedSend</CODE> and   <CODE>AddProcrastinatedCall</CODE>, which more or less implement   the timer-resetting feature for you.<BR>      <BR>      The best way to implement the timer when views are available is   using the <CODE>viewIdleScript</CODE>. The   <CODE>viewIdleScript</CODE> is preferred over   <CODE>AddProcrastinatedCall/Send</CODE> because of better   management of the event queue by the OS. When you call   <CODE>SetupIdle</CODE> to start an idle timer, any existing idle   timer is reset. Procrastinated calls/sends aren't currently   implemented by resetting an existing timer, but rather by creating   a delayed event which fires for each call and then checking a flag   when the timer expires to see if it's the last one.<BR>      <BR>      Where these methods are implemented depends on what layer of your   code manages the soup entry. With the NewtApp model, the Entry   layer manages the data, and each view in the Data layer is   responsible for stuffing the modified data in the   <CODE>target</CODE> frame, which is usually a soup entry. The   entry layer implements <CODE>StartFlush</CODE> to start the timer,   and <CODE>EndFlush</CODE> is called when the timer expires and   which should ensure that the data is saved to the soup.<BR>      <BR>      Your <CODE>StartFlush</CODE> equivalent could be implemented   something like this:<BR>            <PRE><CODE>    StartFlush: func()        begin            self.entryDirty := TRUE;            :SetupIdle(5000);    // 5 second delay        end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Your <CODE>viewIdleScript</CODE> would look something like   this:<BR>      </P>      <PRE><CODE>    viewIdleScript: func()        begin            :EndFlush();             nil;            // return NIL to stop the idler until next StartFlush        end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      And your <CODE>EndFlush</CODE> equivalent would look something   like this:<BR>      </P>      <PRE><CODE>    EndFlush: func()        if self.entryDirty then            begin                // getting data from editView may not                // be necessary at this point</CODE></PRE>      <P><CODE><BR>      myEntry.editViewData :=   </CODE><I><CODE>&lt;editView/self&gt;</CODE></I><CODE>.viewChildren;</CODE>   </P>      <PRE><CODE>                EntryChangeXmit(myEntry, kAppSymbol);                self.entryDirty := nil;            end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Implementing <CODE>EndFlush</CODE> as a separate method rather   than just putting the contents in the <CODE>viewIdleScript</CODE>   makes it easy to call the method from the   <CODE>viewQuitScript</CODE> or <CODE>viewPostQuitScript</CODE>, to   guarantee that changes are saved when the view is closed. (The   <CODE>viewIdleScript</CODE> may not have been called if the user   makes a change then immediately taps the close box or overview or   whatever.)<BR>      </P></DL><P><A NAME="Detecting/Preventing_Package_Installation"></A></P><H3><HR>Detecting/Preventing Package Installation (4/18/97)</H3><DL>   <DD>Q: How can I keep my package from being installed on some   devices that may not support it? How can I find out if my package   has just been downloaded or Put Away, as opposed to being   installed as a result of card insertion or resetting?<BR>      <BR>      A: In Newton 2.0 and later releases, frame parts (including   form/application parts and auto parts) can have a   <CODE>DoNotInstall</CODE> function. This function is called when   the package containing the part is activated for the first time as   a result of downloading to the unit, putting away to the Extras   Drawer, or installation with API functions such as   <CODE>SuckPackageFromBinary</CODE> or   <CODE>SuckPackageFromEndpoint</CODE>. The function is not called   when the package is installed as a result of card insertion,   resetting the unit, or moving the package from one store to   another using the Extras Drawer filing. This function is   incorrectly mentioned in the Newton Programmer's Guide and Newton   Programmer's Reference as <CODE>DoNotInstallScript</CODE>. The   proper name of the function is simply   <CODE>DoNotInstall</CODE>.<BR>      <BR>      The function takes no arguments. If the function for any part in a   package returns non-<CODE>nil</CODE>, the entire package will not   be installed on the device. This provides a convenient way to   prevent installation on devices that do not support your package.   It's considered bad form to simply fail to install and provide no   notification to the user. We recommend at least using   <CODE>GetRoot():Notify(...)</CODE> to display a message explaining   why you are not installing.<BR>      <BR>      The function is not copied to internal memory before executing.   You must take care to <CODE>EnsureInternal</CODE> anything this   function leaves behind to avoid the "Grip of Death" problems (the   error with the alert "The package 'MyApp' still needs the card you   removed...").<BR>      <BR>      To create this function for a part, use   <CODE>SetPartFrameSlot</CODE>. For example, to create a package   that will not install on any unit after the year 2000 (because the   world will have ended anyway), do the following:<BR>      <BR>            <PRE><CODE>    SetPartFrameSlot('DoNotInstall, func()        if Time() &gt;= 50492160 then            begin                GetRoot():Notify(kNotifyAlert, "Millenial",                    "This application, and all existence, has expired.");                true;    // return non-nil to prevent install            end);</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that this does nothing to prevent packages that were   installed before the year 2000 from continuing to function.<BR>      <BR>      Because this script executes only when a package is first   installed on a given device, it may be used to set a flag that can   be used by other parts of your application to do things like   suggest user registration, go into demo mode, show some extra   help, etc. It's probably not appropriate as a way to initialize   user preferences or create initial data. Operations like that are   best done by checking each time the package is installed or   launched, and initializing then if it hasn't been done. This is   the case because a user may install your package on a card, then   remove that card from one machine and insert it into a different   machine that has not previously been used with your application.   The part's <CODE>InstallScript</CODE> will execute in this case,   but the part's <CODE>DoNotInstall</CODE> function will not.</P></DL><P><A NAME="Creating_About_Slips_for_Extensions"></A></P><H3><HR><B>NEW: </B>Creating About Slips for Extensions (4/27/97)</H3><DL>   <DD>Q: The default behavior of tapping on an icon in the   Extensions folder is to bring up a generic notification. How can I   make it so that tapping on it brings up my own informational   slip?<BR>      <BR>      A: Here are the steps to follow if you want an Extension to   display a custom slip when it is tapped:<BR>      <BR>      1) Change your part to be a form/application part instead of an   auto part. This is necessary so that a slip can be displayed when   the icon is tapped.<BR>      2) Add a layout to your project that is just a floater with the   information you want to display. Mark this layout as the main   layout. A view based on this floater will open when a user taps on   your part's icon.<BR>      3) Add the following code to a text file in your project. This   will ensure that the icon will show up in the Extensions folder   and not the Unfiled Icons folder:<BR>      <CODE>SetPartFrameSlot('labels, '_extensions); </CODE><BR>      <BR>      Note that form/application parts and auto parts have two important   differences in the behavior of their <CODE>InstallScript</CODE>   part method.<BR>      * The <CODE>InstallScript</CODE> for a form/application part only   takes one argument, whereas the <CODE>InstallScript</CODE> of an   auto part takes two arguments.<BR>      * The <CODE>InstallScript</CODE> of a form/application part is   <CODE>EnsureInternal</CODE>'ed, an auto part's   <CODE>InstallScript</CODE> is not.</DL><P><A NAME="Adding_a_DeletionScript_to_Your_Project"></A></P><H3><HR><B>NEW: </B>Adding a DeletionScript to Your Project (5/12/97)</H3><DL>   <DD>Q: When I add a <CODE>DeletionScript</CODE> to my part, it   doesn't get called when the user scrubs the package. Why is   <CODE>DeletionScript</CODE> not called?<BR>      <BR>      A: You are probably incorrectly adding the   <CODE>DeletionScript</CODE> to your part. The   <CODE>DeletionScript</CODE> must be defined in a manner different   from the part's <CODE>InstallScript</CODE> or   <CODE>RemoveScript</CODE>. You must explicitly set the   <CODE>DeletionScript</CODE> slot in your part frame using NTK's   <CODE>SetPartFrameSlot</CODE> global function. Here is an   example:<BR>      <CODE>SetPartFrameSlot('DeletionScript, func() print("Howdy!")   );</CODE><BR>      <BR>      Note that you will have to use <CODE>SetPartFrameSlot</CODE> for   any part slot other than <CODE>InstallScript</CODE> or   <CODE>RemoveScript</CODE>.<BR>   </DL><H2>Built-In Apps and System Data</H2><P><A NAME="There_Is_No_ProtoFormulasPanel"></A></P><H3><HR>There Is No ProtoFormulasPanel (2/5/96)</H3><DL>   <DD>Q: The current documentation says to use   <CODE>protoFormulasPanel </CODE>for <CODE>RegFormulas</CODE>, but   there does not appear to be such a template.<BR>      <BR>      A: You are correct, there is no such template. You use a   <CODE>protoFloatNGo </CODE>as your base and add your formula   elements to it. The only requirements are:<BR>      <BR>      1. There must be an <CODE>overview </CODE>slot that contains the   text to show in the formula's overview.<BR>      <BR>      2. <CODE>viewbounds.bottom </CODE>must be the height of your   panel.<BR>      <BR>      3. There must be a <CODE>protoTitle </CODE>whose <CODE>title   </CODE>slot is the name of the formula panel.<BR>   </DL><P><A NAME="ProtoPrefsRollItem_Undocumented_Slots"></A></P><H3><HR>ProtoPrefsRollItem Undocumented Slots (2/6/96)</H3><DL>   <DD>Q: When I try to open my own system preference, I get a -48204   error. The preference registers OK with the <CODE>RegPrefs   </CODE>function.<BR>      <BR>      A: The documentation on <CODE>protoPrefsRollItem </CODE>is   incomplete. You must define an <CODE>overview </CODE>slot which is   the text to show in the overview mode. You can optionally define   an <CODE>icon </CODE>slot which is an icon for the title in the   non-overview mode (a title icon). Note that title icons are much   smaller than normal icons.</DL><P><A NAME="SetEntryAlarm_Does_Not_Handle_Events"></A></P><H3><HR>SetEntryAlarm Does Not Handle Events (2/6/96)</H3><DL>   <DD>Q: I tried to set the alarm of an event using the   <CODE>SetEntryAlarm </CODE>calendar message, but the alarm is not   set.<BR>      <BR>      A: It turns out that <CODE>SetEntryAlarm </CODE>will not find   events. You need to use a new Calendar API called   <CODE>SetEventAlarm</CODE>. This function is provided in the   Newton 2.0 Platform File. See the Platform File Notes for more   information.<BR>      <BR>   </DL><P><A NAME="How_to_Avoid_CardFile_Extensions_"still _needs _the _card "></A></P><H3><HR>How to Avoid CardFile Extensions "Still needs the card" (5/9/96)</H3><DL>   <DD>Q: I have a package that registers a data definition and view   definition for a new card type for the Names application. If the   package is installed on a card and the card is removed, the user   gets the following error message:<BR>      <BR>      "The package &lt;The package name&gt; still needs the card you   removed. Please insert it now, or information on the card may be   damaged."<BR>      <BR>      How can I avoid this problem?<BR>      <BR>      A: Currently, the cardfile <CODE>AddLayout </CODE>method requires   that the symbol in the layout is internal. This bug will be fixed   in a future ROM. To work around this, do the following:<BR>      <BR>            <PRE><CODE>local newLayout := {_proto: GetLayout("A Test Layout")};newLayout.symbol := EnsureInternal (newLayout.symbol);GetRoot().cardfile:AddLayout(newLayout);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>For more information about issues for applications running   from a PCMCIA card, see the article "The Newton Still Needs the   Card You Removed"<BR>      </P></DL><P><A NAME="How_to_Find_Distance_Between_Two_Points_on_the_Earth"></A></P><H3><HR>How to Find Distance Between Two Points on the Earth (6/7/96)</H3><DL>   <DD>Q: Is there an API which calculates the distance between two   points on the Earth?<BR>      <BR>      A: Yes. In the Newton 2.0 ROM there is a global function called   <CODE>CircleDistance</CODE> which takes two longitude/latitude   pairs and the units to use in reporting the distance, and   <CODE>CircleDistance</CODE> returns the distance between the two   points. NTK may give a warning about "<CODE>Unknown global   function 'CircleDistance'</CODE>". This warning can be safely   ignored so long as you're writing a package for a Newton 2.0 OS   device.<BR>      <BR>      <CODE>CircleDistance</CODE> (firstLong, firstLat, secondLong,   secondLat, units)<BR>      <BR>      Returns the distance between the two points. The distance is an   integer. Currently <CODE>CircleDistance</CODE> rounds the distance   to the nearest ten miles or ten kilometers.<BR>      <BR>      <CODE>firstLong</CODE>: The longitude for the first point on the   Earth.<BR>      <CODE>firstLat</CODE>: The latitude for the first point on the   Earth.<BR>      <CODE>secondLong</CODE>: The longitude for the second point on the   Earth.<BR>      <CODE>secondLat</CODE>: The latitude for the second point on the   Earth.<BR>      <CODE>units</CODE>: A symbol specifying the units in which the   distance will be calculated. Currently the options are   <CODE>'miles</CODE> or <CODE>'kilometers</CODE>.<BR>      <BR>      Note: the longitude and latitude arguments need to be integer   values of the type used by <CODE>NewCity</CODE>. Check the section   titled "Using the Time Zone Application" in the Built-In   Applications and System Data chapter of the Newton Programmer's   Guide for information on how to convert a longitude or latitude in   degrees, minutes &amp; seconds to an integer for   <CODE>CircleDistance</CODE>.</DL><P><A NAME="Avoiding_Query_Bug_in_GetExtraIcons_Call"></A></P><H3><HR>Avoiding Query Bug in GetExtraIcons Call (8/2/96)</H3><DL>   <DD>Q: Some calls to <CODE>GetExtraIcons</CODE> result in an   undefined <CODE>Query</CODE> method exception. How can I fix   this?<BR>      <BR>      A: There is a bug in the implementation of   <CODE>GetExtraIcons</CODE>. The code is not checking if the store   has any extras information on it, so the <CODE>Query</CODE>   message is getting sent to a <CODE>NIL</CODE> soup. The result is   the exception.<BR>      <BR>      At this time it is not clear if or when this bug will be fixed. I   suggest you use the following workaround code when you call   <CODE>GetExtraIcons</CODE>:<BR>      <BR>            <PRE><CODE>    try        GetExtraIcons(...)        // do whatever you need to do here            onexception |evt.ex.fr.intrp;type.ref.frame| do    begin        // check for a problem calling the Query function        if currentException().data.errorCode = -48809 AND                currentException().data.symbol = 'Query then        begin            // no extras drawer info on the store        end ;        else            // a real error has occured, so let system handle it            ReThrow() ;    end ;</CODE></PRE></DL><P><A NAME="How_to_Get_Labels_for_Custom_Names_Fields"></A></P><H3><HR>How to Get Labels for Custom Names Fields (8/13/96)</H3><DL>   <DD>Q: The Names application allows the user to add custom fields.   If I have a specific entry, the cardfile method   <CODE>bcCustomFields</CODE> returns the labels and values of the   custom fields used in the entry. Is there a way to get a list of   all the custom fields the user has defined?<BR>      <BR>      A: Yes, you can pass <CODE>'customFields </CODE>to the names soup   method <CODE>GetInfo</CODE>. This will return a frame of all the   custom fields the user has defined. Each slot in this frame will   have a frame with a <CODE>'label</CODE> slot. Each   <CODE>'label</CODE> slot will be a string specified by the user.   Here is an example:      <PRE><CODE>    GetStores()[0]:GetSoup(ROM_CardFileSoupName):GetInfo('customFields)&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>...which returns:<BR>      </P>      <PRE><CODE>{custom1: {label: "Customer Label"},  custom2: {label: "Another label"}}</CODE>&nbsp;</PRE></DL><P><A NAME="How_to_Add_Confidential_Owner_Data"></A></P><H3><HR>How to Add Confidential Owner Data (10/1/96)</H3><DL>   <DD>Q: If I add confidential information to the Newton owner's   card, all the information is beamed when the user beams the owner   card. How can I keep confidential information from being sent?<BR>      <BR>      A: Every owner entry has an <CODE>owner</CODE> slot, the value of   which is a frame. This slot is removed from the entry before it is   sent to another Newton device. You can add slots to this frame to   store them, but keep them from being sent. Be sure to append your   developer signature to any slot names you add to the   <CODE>owner</CODE> frame.<BR>      <BR>      Note that this only applies to the built-in Beam transport; any   other transport or application can access all the slots in the   Owner entry.</DL><P><A NAME="Adding_Notes_to_Closed_Notes_Application"></A></P><H3><HR>Adding Notes to Closed Notes Application (1/14/97)</H3><DL>   <DD>Q: How do I add a note to the soup without having to have the   Notepad application open? <CODE>MakeTextNote</CODE> doesn't work   if Notes is closed.<BR>      <BR>      A: You should use <CODE>MakeTextNote</CODE> to create the data,   then add it to the soup entry using <CODE>soup:AddXmit</CODE> or   <CODE>uSoup:AddToStoreXmit</CODE> (or one of the other soup   functions.)<BR>      <BR>      <CODE>MakeTextNote</CODE> always creates a frame with all the   correct data that the Notes application requires. If the 2nd   paramater (addit) is <CODE>TRUE</CODE>, it will add that frame to   the Notes soup and show the note on the screen. If addIt is   <CODE>NIL</CODE>, then the frame is returned.<BR>      <BR>      It's the adding and showing that require the Notes app to be open,   not the frame creation. For instance, to add a note to the default   store, do something like:<BR>      <BR>            <PRE><CODE>    newNote := GetRoot().paperroll:MakeTextNote("Here is a sample note", nil);    GetUnionSoup("Notes"):AddToDefaultStoreXmit(newNote, '|appSym:SIG|)</CODE>&nbsp;</PRE></DL><P><A NAME="TapAction_Slot_Requires_Text_Slot_to_be_Present"></A></P><H3><HR>TapAction Slot Requires Text Slot to be Present (1/15/97)</H3><DL>   <DD>Q: I have an autopart that I want to display an About slip   when tapped. I added a <CODE>tapAction</CODE> slot but it does not   work. What is missing?<BR>      <BR>      A: The system will ignore the <CODE>tapAction</CODE> slot if it   does not find a <CODE>'text</CODE> slot in the   <CODE>partFrame</CODE> as well. The <CODE>'text</CODE> slot   contains the name that will be displayed in the Extras drawer.<BR>      <BR>      The following lines will correctly add a <CODE>tapAction</CODE> to   a your part frame (in other words, your autopart):<BR>      <BR>            <PRE><CODE>    DefineGlobalConstant('kTapActionFn,func()begin    // your code goes here! end);&nbsp;// part MUST have a text slot for tapAction to be used// text slot is the name seen by the user in ExtrasSetPartFrameSlot('text, kAppName) ;SetPartFrameSlot('tapAction, kTapActionFn) ;</CODE>&nbsp;</PRE></DL><P><A NAME="Getting_the_Current_Set_of_Multi-User_Names"></A></P><H3><HR>Getting the Current Set of Multi-User Names (3/17/97)</H3><DL>   <DD>Q: How can I get a list of all the students when a unit that   supports it (for instance, the Apple eMate 300) is in multi-user   mode?<BR>      <BR>      A: The multi-user mode is implemented by the Home Page built-in   application, and the list of users is stored in that application's   preferences frame. Use <CODE>GetAppPrefs</CODE> to get the prefs   for that application for read-only purposes. Only the documented   slots in that frame should be accessed. Other slots are neither   documented nor supported, and their behavior may change. You   should also check to ensure that the Home Page application exists   on a particular unit before using any features. For example, here   is a code snippet that evaluates to an array of user names, or NIL   if the unit does not support multiple users or is not in   multi-user mode.<BR>      <BR>            <PRE><CODE>    if GetRoot().HomePage then         begin            local prefs := GetAppPrefs('HomePage, '{});            if prefs.users and prefs.kMultipleUsers then                foreach item in prefs.users collect item.name;        end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The Home Page preferences frame contains the following slots that   may be accessed read only:<BR>      <CODE>kMultipleUsers</CODE>: non-nil if multi-user mode is   enabled<BR>      <CODE>kRequirePassword</CODE> non-nil if passwords required in   multi-user mode<BR>      <CODE>kDisallowNewUsers</CODE> non-nil if new users can't be   created at login<BR>      <CODE>users</CODE> array of user frames or NIL.<BR>      <BR>      A user frame contains the following slot that you may use as   read-only data:<BR>      <CODE>name</CODE> a string, the user-visible user's name<BR>      <BR>      Keep in mind that new users could be created or existing users   names may be changed at any time, and there is no notification   when this happens. If necessary, you should check the set of users   when your application launches. It is unlikely that new users will   be created, deleted, or renamed while an application is open,   unless this happens as a result of a new user being created at   login. In this case, registering for change in the user   configuration frame with <CODE>RegUserConfigChange</CODE> and   watching for the <CODE>'kCurrentUser</CODE> slot to change will   let you catch changes to the current set of multi-user names.<BR>      </P></DL><P><A NAME="Registering_an_Auxillary_Button_for_Newton_Works"></A></P><H3><HR><B>NEW: </B>Registering an Auxillary Button for Newton Works(5/12/97)</H3><DL>   <DD>Q: When I register an auxiliary button for Newton Works using   the global function <CODE>RegAuxButton</CODE>, I get a -48204   error. Why am I getting this error?<BR>      <BR>      A: This error is caused by a bug in Newton Works. You will get a   -48204 error if you register an auxiliary button for Newton Works   while Newton Works is closed. To work around this problem, catch   that particular exception and ignore it. Here is a code   example:<BR>      <BR>            <PRE><CODE>    try        RegAuxButton( kAppSymbol, {destApp: 'newtWorks, ...} );    onexception |evt.ex.fr| do        nil;</CODE></PRE></DL><P><A NAME="How_to_Create_Newton_Works_Documents"></A></P><H3><HR><B>NEW: </B>How to Create Newton Works Documents (5/15/97)</H3><DL>   <DD>Q: How do I create a Newton Works document for Newton 2.1 OS   devices or later?<BR>      <BR>      A: If you want to create a new "empty" stationery document, use   the Newton Works method <CODE>AddEntryFromStationery</CODE>. For   instance:<BR>            <PRE><CODE>    if GetRoot().NewtWorks then</CODE></PRE>      <P><CODE><BR>      GetRoot().NewtWorks:AddEntryFromStationery(stationerySym);</CODE><BR>      <BR>      If you want to create a new entry with data already in it, use the   Newton Works method <CODE>AdoptEntryFromStationery</CODE>. To   create a new entry, you must add the basic Newton Works soup entry   slots and then any stationery-specific slots:<BR>      <BR>      (1) Create a frame with the basic Newton Works soup entry slots as   shown below:<BR>      <CODE>class</CODE>: Class of the item. For instance, for Draw   documents, use the symbol <CODE>'drawPaper</CODE><BR>      <CODE>version</CODE>: Integer, the current version of the   entry<BR>      <CODE>title</CODE>: String which is the document title<BR>      <CODE>timeStamp</CODE>: Creation date of the entry<BR>      <CODE>realModTime</CODE>: Date the entry was most recently   modified<BR>      <BR>      (2) Add the stationery-specific slots:<BR>      <BR>      <B>"Draw" Stationery Additional Slots<BR>      </B><BR>      <CODE>saveData</CODE>: a frame with the following slots:<BR>      <CODE>shapes</CODE>: Required. An array of a single item, a   picture as returned by the global function   <CODE>MakePict</CODE>.<BR>      </P>      <PRE><CODE>    selection:    [], // the empty array    styles:        nil,</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Warning: the above information describes only how to create a new   Draw document. See the Q&amp;A "Reading/Modifying Newton Works   Data" for information on reading information from a Draw document.   Slots in the <CODE>saveData</CODE> slot of Draw documents already   in Newton Works should be treated as read-only. (Do not try to   modify these data structures in any way.)<BR>      <BR>      <B>"Paper" Stationery Additional Slots<BR>      </B><BR>      <CODE>SaveData</CODE>: the object returned from   <CODE>protoTXView:Externalize().</CODE> See the Newton 2.1 OS   documentation for information about <CODE>Externalize().</CODE>   Note that this data must be from a <CODE>protoTXView</CODE> that   uses VBOs (it uses the <CODE>protoTXView:SetStore(...)</CODE>   method), or Newton Works can run out of NewtonScript memory when   editing the document.<BR>      <BR>      <CODE>hiliteRange</CODE>: frame with the document's hilite range   (see the <CODE>protoTXView</CODE> documentation for details)<BR>      <BR>      <CODE>margins</CODE>: a frame with slots <CODE>'top</CODE>,   <CODE>'left</CODE>, <CODE>'bottom</CODE>, <CODE>'right</CODE>,   which are the document's margins in pixels. The frame can also   optionally have the slots<CODE> 'userTop</CODE>,   <CODE>'userLeft</CODE>, <CODE>'userBottom</CODE>, and   <CODE>'userRight</CODE> that will contain numbers (integer or   real) with the margin sizes translated to user units (inches or   centimeters.) If the <CODE>userXXX </CODE>slots are missing or   <CODE>nil</CODE>, they will be calculated from the pixel   values.<BR>      <BR>      <BR>      (3) Use code like the following to add the entry to the soup:<BR>      </P>      <PRE><CODE>    if GetRoot().NewtWorks then        GetRoot().NewtWorks:AdoptEntryFromStationery(theEntry, stationerySym, GetDefaultStore());&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>See the Newton Programmer's Reference for more info about   the <CODE>NewtApplication:AdoptEntryFromStationery(...)</CODE>   method.</P></DL><P><A NAME="Reading/Modifying_Newton_Works_Data"></A></P><H3><HR><B>NEW: </B>Reading/Modifying Newton Works Data (5/15/97)</H3><DL>   <DD>Q: How do I read/write information in Newton Works   documents?<BR>      <BR>      A: The supported ability to read/write information from Newton   Works documents depends on what type of stationery is used and   what information is documented for that stationery type. For   instance, word processor (paper) documents can be read and   modified, whereas Draw documents can be read but not modified. If   the desired Newton Works stationery is not built-in, contact the   stationery's developer to determine whether reading and/or   modifying the soup entry data is supported.<BR>      <BR>      Related APIs: To create new Newton Works documents, see the   Q&amp;A"How to Create Newton Works Documents". To modify data in   Newton Works documents that are currently viewed, see the Newton   2.1 documentation for information about APIs to the word processor   (Paper stationery) and the Draw application (Draw stationery) APIs   for tools and stamps.<BR>      <BR>      For reading/writing information from "Paper" soup entries, see the   format specified in the Q&amp;A"How to Create Newton Works   Documents" or the Newton 2.1 OS documentation.<BR>      <BR>      For "Draw" soup entries, we support creating new documents (see   the Q&amp;A "How to Create Newton Works Documents") and reading   shapes from documents that have been viewed in Newton Works   already. However, there is no support for manipulating individual   shapes of a current soup entry, nor examining shapes in items that   have been created/imported, but never viewed in the Newton Works   application.<BR>      <BR>      To read shape information from pictures, here is the information   about how to extract shapes from valid Draw documents.<BR>      <BR>      The entry has the basic Newton Works soup entry slots as shown   below:<BR>      <CODE>class</CODE>: Class of the item. For instance, for Draw   documents, use the symbol <CODE>'drawPaper</CODE><BR>      <CODE>version</CODE>: Integer, the current version of the   entry<BR>      <CODE>title</CODE>: String which is the document title<BR>      <CODE>timeStamp</CODE>: Creation date of the entry<BR>      <CODE>realModTime</CODE>: Date the entry was most recently   modified<BR>      <BR>      The Draw document soup entry also has the slot called   <CODE>saveData</CODE> that contains the following slots:<BR>      <CODE>shapes</CODE>: This is an array of shapes in the   document.<BR>      <CODE>styles</CODE>: An array of all styles contained in the   shapes array.<BR>      <CODE>selection</CODE>: An array containing integer indexes into   the shapes array, indicating the currently selected shapes.<BR>      <BR>      The <CODE>shapes</CODE> slot is represented as an array of   style/shape pairs, as returned by   <CODE>drawApp:GetContents()</CODE>. Each "shape" can be another   array of shape and style pairs, representing grouping of shapes   (these grouping can continue, so subarrays can have sub-subarrays,   etc). If the shapes array contains exactly one item (its length is   1) and the class of the item is <CODE>'picture</CODE>, it is a   picture that has been created/imported but not yet viewed in   Newton Works. If this is the case, the individual shapes cannot be   read, but the picture is the same format as the return value of   the global function <CODE>MakePict</CODE>.<BR>      <BR>      Warning: Slots in the <CODE>saveData</CODE> slot of Draw documents   already in Newton Works should be treated as read-only. Do not try   to modify these data structures in any way. Manipulating them can   result in serious user problems.</DL><P><A NAME="Opening_a_Specified_Document_in_Works"></A></P><H3><HR><B>NEW: </B>Opening a Specified Document in Works (5/27/97)</H3><DL>   <DD>Q: How do you make Newton Works open a particular   document?<BR>      <BR>      A: The easiest way is to use the <CODE>ShowFoundItem</CODE> method   of the Works base view only as shown below.   <CODE>ShowFoundItem</CODE> is generally intended for internal use   by the application itself. However, it provides handy access for   navigating to a particular soup entry, so Works supports using it   for this purpose only. Do not attempt to use   <CODE>ShowFoundItem</CODE> to do more than simply bring up an   entry in the Works application.<BR>      <BR>      The 2nd argument (the finder) to <CODE>ShowFoundItem</CODE> may be   difficult to specify because Works can use stationery provided by   3rd parties, which may have special requirements for the finder.   In Works, the stationery is responsible for adding data to the   finder when a find is performed, and so the stationery may rely on   that data being present when <CODE>ShowFoundItem</CODE> is later   used. For all the stationery types that exist at the time this   Q&amp;A was written, a minimal finder frame of <CODE>{findWords:   [""]}</CODE> is sufficient to allow the stationery to show the   item. Please note that this is NOT a fully specified finder,   however it is sufficient for the <CODE>FindSoupExcerpt</CODE>   method, which is used widely. A full finder frame which   accomplishes the same thing might look like this:<BR>            <PRE><CODE>    {owner: GetRoot().NewtWorks,     findType: 'text,     findWords: [""],     items: [{_proto: theEntry, title: "None"}]}</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      For Works stationery developers, we recommend not making any   assumptions about the contents of the finder frame when   implementing your ViewDef's <CODE>ShowFoundItem</CODE> method.   (Note that <CODE>ShowFoundItem</CODE> is a Works-specific   requirement of stationery. Generic ViewDefs do not require a   <CODE>ShowFoundItem</CODE> method.)<BR>      <BR>      Here is an inspector example of navigating Works to one of each   existing stationery. The example assumes a new untitled document   of each type exists. (You'll want to have your own code that finds   the appropriate Works soup entry to open.)<BR>      </P>      <PRE><CODE>    // make sure Works is open    GetRoot().NewtWorks:Open();&nbsp;    // find an entry    s := GetUnionSoup("NewtWorks");    theEntry := s:Query({text: "Untitled Paper"}):Entry();&nbsp;    // show it    GetRoot().NewtWorks:ShowFoundItem(e, {findWords: [""]});&nbsp;    // the rest of them    theEntry := s:Query({text: "Untitled Drawing"}):Entry();    GetRoot().NewtWorks:ShowFoundItem(e, {findWords: [""]});&nbsp;    theEntry := s:Query({text: "Untitled Calculations"}):Entry();    GetRoot().NewtWorks:ShowFoundItem(e, {findWords: [""]});&nbsp;    theEntry := s:Query({text: "Untitled Spreadsheet"}):Entry();    GetRoot().NewtWorks:ShowFoundItem(e, {findWords: [""]});&nbsp;    // cleanup    theEntry := s := nil;</CODE></PRE></DL><P><A NAME="Creating_a_Works_Word_Processor_Document_with_Data"></A></P><H3><HR><B>NEW: </B>Creating a Works Word Processor Document with Data(6/9/97)</H3><DL>   <DD>Q: How do I create a new Works paper document with some   initial data? I'd like something like the Notes application's   <CODE>MakeTextNote</CODE> function.<BR>      <BR>      A: First, review the Q&amp;A entitled "How to Create Newton Works   Documents" for details on actually creating the document.<BR>      <BR>      To create initial data for a word processor document, the simplest   thing to do is to create a dummy view based on   <CODE>protoTXView</CODE>. Use the <CODE>protoTXView</CODE> methods   to add data to that view. When done, use the   <CODE>Externalize</CODE> method to get the data in a form suitable   for saving in the Works soup.<BR>      <BR>      When creating your dummy <CODE>protoTXView</CODE>, it's imperative   that you call the <CODE>SetStore</CODE> method so that the data is   created on the user store rather than the NS heap. Different   formats are used for store-backed and heap-backed   <CODE>protoTXViews</CODE>, and the type of backing is carried into   the <CODE>Externalized</CODE> data. As a result, failure to use   <CODE>SetStore</CODE> would cause you to create a Works document   that was not backed by the user store and which could eventually   result in out-of-memory errors when the user added sufficient data   to the document.<BR>      <BR>      Here's an example of how to create a dummy text view and populate   it with some initial data. You may wish to vary the store passed   to <CODE>SetStore</CODE> in the <CODE>viewSetupFormScript</CODE>   and <CODE>AdoptEntryFromStationery</CODE>, or the intial text   specified in the 2nd paramater to <CODE>Replace</CODE>. (Notably,   you may wish to provide styles for the text, see the Newton 2.1 OS   documentation on the <CODE>protoTXView</CODE> method   <CODE>Replace</CODE>.)<BR>      <BR>            <PRE><CODE>    // create and populate a dummy protoTXView    local textView := BuildContext(        {            _proto: protoTXView,            viewBounds: SetBounds(0, 0, 0, 0),            viewFlags: 0,            ReorientToScreen: ROM_DefRotateFunc,            viewSetupFormScript: func() begin                inherited:?viewSetupFormScript();                self:SetStore(GetDefaultStore());            end,        });    textView:Open();    textView:Replace({first: 0, last: 0}, {text: "Some initial text"}, nil);&nbsp;    // get the data in an external form for the Works soup    local saveData := textView:Externalize();    textView:Close();&nbsp;    // Create a new Works document from the data    GetRoot().NewtWorks:AdoptEntryFromStationery(        {            title: "Initial Title",            saveData: saveData,            hiliteRange: {first: 0, last: 0},            margins: {top: 72, left: 72, right: 72, bottom: 72},        }, 'paper, GetDefaultStore());</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      </P></DL><P><A NAME="Unregistering_Stamps_in_Newton_Works_Draw"></A></P><H3><HR><B>NEW: </B>Unregistering Stamps in Newton Works Draw (7/2/97)</H3><DL>   <DD>Q: When I call the Newton Works Draw stationery's   <CODE>UnRegStamps</CODE> method, my registered stamps do not get   unregistered. What is going wrong?<BR>      <BR>      A: There is a bug in the Draw application's   <CODE>UnRegStamps</CODE> method that causes stamps to remain   registered. Use the following code to unregister your stamps:<BR>      <BR>            <PRE><CODE>local viewDef := GetViewDefs( 'drawPaper ).default;&nbsp;if viewDef then    begin        // Call UnregStamps conditionally.  If the Draw application is not        // installed, GetViewDefs will return the "Missing Stationery"        // stationery.        viewDef:?UnregStamps( kStampRegistrySymbol );&nbsp;        local registry := GetViewDefs( 'drawPaper ).StampListRegistry;        if registry AND HasSlot( registry, kStampRegistrySymbol ) then            RemoveSlot( registry, kStampRegistrySymbol );    end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that calling the <CODE>UnRegStamps</CODE> method is required   for future compatibility.</P></DL><H2>Controls and Other Protos</H2><P><A NAME="How_to_Set_the_Letter_in_AZTab_Protos"></A></P><H3><HR>How to Set the Letter in AZTab Protos (3/26/96)</H3><DL>   <DD>Q: How do I programmatically select the letter in   <CODE>protoAZTabs </CODE>or <CODE>protoAZVertTabs</CODE>?<BR>      <BR>      A: You can use the <CODE>SetLetter </CODE>method of the AZTab   protos:<BR>      <BR>            <PRE><CODE>protoAZTabs.SetLetter(newLetter, NIL)&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Set the tab to the character specified by newLetter and   update the hiliting. Note that this method does not send a   <CODE>pickLetterScript </CODE>message.<BR>      <CODE><BR>      </CODE>Example:<BR>      </P>      <PRE><CODE>// set myProtoAZTabs to the letter "C"myProtoAZTabs:SetLetter($c, nil) ;&nbsp;protoAZVertTabs.SetLetter...see protoAZTabs.SetLetter</CODE>&nbsp;</PRE></DL><P><A NAME="Return_Value_of_ProtoSoupOverview's_HitItem_Message"></A></P><H3><HR>Return Value of ProtoSoupOverview's HitItem Message (1/6/97)</H3><DL>   <DD>Q: What is the meaning of the return value of   <CODE>protoSoupOverview:HitItem(...)</CODE>? I want to call the   inherited method and use the return value to determine what action   the system performed.<BR>      <BR>      A: <CODE>ProtoSoupOverview:HitItem(...)</CODE> returns nil if it   handled the tap and non-<CODE>nil</CODE> if it didn't handle the   tap (the opposite meaning of the return value of   <CODE>protoOverview</CODE>'s <CODE>HitItem</CODE> method).<BR>      <BR>      Note that the final NPG documentation implies that   <CODE>protoSoupOverview</CODE>'s <CODE>HitItem</CODE> is just like   <CODE>protoOverview</CODE>'s <CODE>HitItem</CODE> method; this is   a mistake in the documentation.<BR>   </DL><P><A NAME="Don't_Use_ROM_UpArrowBitmap"></A></P><H3><HR>Don't Use ROM_UpArrowBitmap (3/28/97)</H3><DL>   <DD>Q: I used the constant <CODE>ROM_UpArrowBitmap</CODE> in my   application, and now my app appears partially invisible in the   Newton 2.1 OS. What's wrong?<BR>      <BR>      A: The constant <CODE>ROM_UpArrowBitmap</CODE> and the other   directional arrow constants were not intended to be supported, and   the value of the magic pointer has changed in Newton 2.1 OS. The   change was made to better implement the (documented and supported)   scrolling protos such as <CODE>protoUpDownScroller</CODE>.<BR>      <BR>      <CODE>ROM_UpArrowBitmap</CODE> is named in the NTK Platform File   defs file, and had mistakenly been mentioned in some public   documentation from Apple, so you may have thought this was   supported. If you have a reference to one of these magic pointers   in the <CODE>icon</CODE> slot of a <CODE>clPictureView</CODE>,   you'd have gotten an arrow graphic on the 2.0 and earlier releases   of the OS, but on the Newton 2.1 OS, the changed value is not   acceptable to the view system as a graphic. The result is that   drawing is aborted when the OS tries to render the view with the   arrow graphic, and views that would normally be drawn after the   bad view will also fail to render, producing what appear to be   invisible views that are otherwise functional.<BR>      <BR>      You should use the documented protos to implement scrolling. If a   custom scroller is needed, you can create your own graphic and   include it in your NTK project.</DL><P><A NAME="Dragging_a_View_Based_on_ProtoTXView"></A></P><H3><HR><B>NEW: </B>Dragging a View Based on ProtoTXView (7/8/97)</H3><DL>   <DD>Q: I have a <CODE>protoTXView</CODE>-based view as a   descendent of a draggable view. When I drag the view, the   <CODE>protoTXView</CODE>-based view still draws its contents at   the original coordinates. What is going wrong?<BR>      <BR>      A: The <CODE>protoTXView</CODE> prototype does not correctly   update its draw origin coordinates when moved. To work around this   bug, you must close the <CODE>protoTXView</CODE>-based view and   re-open it.<BR>      <BR>      Before closing the <CODE>protoTXView</CODE>-based view, you will   need to externalize the data so that you can restore the data when   you reopen the view. To do this, call the <CODE>Externalize</CODE>   method and store the return value somewhere (perhaps in the parent   of the <CODE>protoTXView</CODE>). When you reopen the view, call   the <CODE>Internalize</CODE> method with the stored return value   of the call to <CODE>Externalize</CODE>.<BR>      <BR>      You will probably also want to save and restore the scroll   coordinate, the caret offset, and the hilite range.</DL><H2>Data Storage (Soups)</H2><P><A NAME="FrameDirty_is_Deep,_But_Can_Be_Fooled"></A></P><H3><HR>FrameDirty is Deep, But Can Be Fooled (8/19/94)</H3><DL>   <DD>Q: Does the global function <CODE>FrameDirty</CODE> see   changes to nested frames?<BR>      <BR>      A: Yes. However, <CODE>FrameDirty</CODE> is fooled by changes to   bytes within binary objects. Since strings are implemented as   binary objects, this means that <CODE>FrameDirty</CODE> will not   see changes to individual characters in a string. Since   <CODE>clParagraphViews</CODE> try (as much as possible) to work by   manipulating the characters in the string rather than by creating   a new string, this means that <CODE>FrameDirty</CODE> can be   easily fooled by normal editing of string data.<BR>      <BR>      Here is an NTK Inspector-based example of the problem:<BR>      <BR>            <PRE><CODE>s := GetStores()[0]:CreateSoup("Test:DTS", []);e := s:Add({slot: 'value, string: "A test entry", nested: {slot: 'notherValue}})#4410B69  {slot: value,            String: "A test entry",            nested: {slot: notherValue},            _uniqueID: 0}FrameDirty(e)#2        NIL&nbsp;e.string[0] := $a; // modify the string w/out changing its referenceFrameDirty(e)#2        NIL&nbsp;EntryChange(e);e.string := "A new string";    // change the string referenceFrameDirty(e)#1A       TRUE&nbsp;EntryChange(e);e.nested.slot := 'newValue;    // nested change, FrameDirty is deep.FrameDirty(e)#1A       TRUE&nbsp;s:RemoveFromStore()    // cleanup.</CODE></PRE></DL><P><A NAME="Limits_on_Soup_Entry_Size"></A></P><H3><HR>Limits on Soup Entry Size (2/12/96)</H3><DL>   <DD>Q: How big can I make my soup entries?<BR>      <BR>      A: In practice, entries larger than about 16K will significantly   impact performance, and 8K should be considered a working limit   for average entry size. No more than 32K of text (total of all   strings, keeping in mind that one character is 2 bytes) can go in   any soup entry.<BR>      <BR>      There is no size limit built into the NewtonScript language;   however, another practical limit is that there must be space in   the NewtonScript heap to hold the entire soup entry.<BR>      <BR>      There is a hard upper limit of 64K on Store object sizes for any   store type. With SRAM-based stores there is a further block size   limit of 32K. Trying to create an entry larger than this will   result in <CODE>evt.ex.fr.store</CODE> exceptions. These limits   are for the encoded form that the data takes when written to a   soup, which varies from the object's size in the NS heap.<BR>      <BR>      Newton Backup Utility and Newton Connection Utility cannot handle   entries larger than 32K.<BR>      <BR>      Note that Virtual Binary Objects (VBOs) in Newton 2.0 are no   subject to the same restrictions. If you can store large objects   as VBOs, you can store more information in your soup entries by   referencing those VBOs.</DL><P><A NAME="Choosing_EntryFlushXMit_and_EntryChangeXMit"></A></P><H3><HR>Choosing EntryFlushXMit and EntryChangeXMit (4/17/96)</H3><DL>   <DD>Q: What is the difference between the functions   <CODE>EntryFlushXMit </CODE>and <CODE>EntryChangeXMit</CODE>?<BR>      <BR>      A: The most important criterion when choosing between   <CODE>EntryFlushXMit </CODE>and <CODE>EntryChangeXMit </CODE>is   what will be done with the entry after the flush or change.<BR>      <BR>      When an entry is added or changed, the system ensures that a   cached entry frame exists in the NewtonScript heap. The system   then writes the data in the frame to the store, skipping   <CODE>_proto </CODE>slots. The result is that the data will be   written to the store, and a cached frame will exist. Often, this   is exactly what is desired because the entry is still needed since   it will soon be accessed or modified.<BR>      <BR>      In some cases, the data will be written to the soup with no   immediate access afterwards. In other words, the data will not be   used after being written to the soup. In these cases creating or   keeping a cached entry frame in the NewtonScript heap is   unnecessary and just wastes space and time. In these situations,   <CODE>EntryFlushXMit </CODE>is a better option; it writes the data   to the soup without creating the cached entry.<BR>      <BR>      If any code accesses an entry that was just flushed, a new cached   frame will be read in from the soup, just like when an existing   entry is read for the first time.<BR>      <BR>      The rule of thumb is: if an entry will be used soon after saving   to the soup, then use <CODE>AddXMit </CODE>or   <CODE>EntryChangeXMit</CODE>. If the entry will not soon be used   again (so it doesn't need to take up heap space with the cached   frame), then use <CODE>AddFlushedXmit </CODE>or   <CODE>EntryFlushXMit</CODE>.<BR>      <BR>      Some examples of good usage:<BR>            <PRE><CODE>while entry dobegin  entry.fooCount := entry.fooCount + 1;  // nil appSymbol passed so don't broadcast  EntryFlushXMit(entry, nil);     entry := cursor:Next();end;                           // Could broadcast now &nbsp;&nbsp;foreach x in kInitialData do     // if new, may not need broadcast    soup:AddFlushedXmit(Clone(x), nil);    &nbsp;</CODE>&nbsp;</PRE></DL><P><A NAME="Limit_on_Soup_Name_Length"></A></P><H3><HR>Limit on Soup Name Length (12/10/96)</H3><DL>   <DD>Q: What is the maximum number of characters I can use for a   soup name?<BR>      <BR>      A: With the Newton OS 2.0 release, soup names, like index data,   are limited to 39 Unicode characters. If you attempt to create a   soup with a longer name, the OS will create a soup with only the   first 39 characters of the longer name. We recommend you avoid   this truncation, because typically the truncation removes some or   all of your registered signature, and the resulting name will not   be guaranteed unique.<BR>      <BR>      You can still provide longer/prettier names for users, by using   the <CODE>soupDef</CODE> mechanism and putting the long name   (typically without appended signature) in the   <CODE>'userName</CODE> slot of that data structure.</DL><P><A NAME="How_to_Use_Begin_and_End_Symbols_with_WhichEnd"></A></P><H3><HR>How to Use Begin and End Symbols with WhichEnd (1/8/97)</H3><DL>   <DD>Q: The <CODE>WhichEnd</CODE> cursor method returns the symbols   <CODE>'begin</CODE> or <CODE>'end</CODE>, depending on where the   cursor is in a soup. Why does NTK complain when I try to check for   these symbols?<BR>      <BR>      A: Unfortunately, these are reserved words so NTK won't let you   type them into normal code. The work-around is to enclose the   symbol in vertical bars.<BR>      <BR>      For instance, you can use code like:<BR>            <PRE><CODE>if myCursor:WhichEnd() = '|begin| then    :WeAreAtBeginning();</CODE>&nbsp;</PRE></DL><P><A NAME="EntryChange_on_Modified_Tags_Array_Throws_-48022"></A></P><H3><HR>EntryChange on Modified Tags Array Throws -48022 (1/15/97)</H3><DL>   <DD>Q: I added a tag to the array of tags in an entry. When I call   <CODE>EntryChange</CODE> on the modified entry I get a -48022   error. What is wrong?<BR>      <BR>      A: There is a known bug in Newton OS 2.0 (which is fixed in Newton   OS 2.1) that can cause this problem. It can occur when you   initially create an entry with an empty array as the value of the   tag index slot. The workaround is not to use the empty array. Use   NIL instead. If you need to add an array of tags later, you can do   so.</DL><P><A NAME="How_to_Avoid_Resets_When_Using_VBOs"></A></P><H3><HR>How to Avoid Resets When Using VBOs (2/27/97)</H3><DL>   <DD>Q: When writing large amounts of information to virtual binary   objects (VBOs), my Newton device sometimes resets. What is going   wrong?<BR>      <BR>      A: The problem happens because of how the Newton OS manages the   memory for VBOs. Writing to VBOs in low memory conditions can   sometimes cause the device to reset because no free pages are   available for other OS operations.<BR>      <BR>      To work around this problem, you can periodically call the global   function <CODE>ClearVBOCache</CODE> while modifying VBOs. You can   also work around the problem by putting the VBO in a soup entry   and using <CODE>EntryChangeXmit</CODE> or   <CODE>EntryFlushXmit</CODE>.<BR>      <BR>      In all versions of the Newton 2.x OS released to date, VBOs   (including packages) are managed in 1K pages. When you write to a   VBO, the "dirty" pages can remain in the system heap, taking up   space. <CODE>ClearVBOCache</CODE> takes a reference to a VBO as an   argument, and moves the dirty pages for a given VBO to the store,   freeing up the system memory. Note that this function does not   commit the changes to the VBO, while <CODE>EntryChangeXmit</CODE>   and <CODE>EntryFlushXmit</CODE> do commit the changes.<BR>      <BR>      The likelihood of the problem depends on the amount of system   memory currently available and how many pages of VBOs are   modified. We recommend that you modify no more than 32 pages of   VBOs before committing the changes or calling   <CODE>ClearVBOCache</CODE>. For example, modifying 32K of   contiguous data, or a single byte in 32 different pages of one   VBO, or even a single byte in 32 different VBOs all modify 32   total pages of VBO data. Don't do this too often, though. Calling   <CODE>ClearVBOCache</CODE> repeatedly for modifications to the   same page of a VBO or when there are only a few modified pages   will needlessly slow the machine.<BR>      <BR>      If you are experiencing this problem, you should consider   redesigning your application to minimize the amount of uncommited   VBO data. When finished with a VBO, commit it to a soup entry as   soon as possible or let it become unreferenced.</DL><P><A NAME="Why_Xmit_Functions_Seem_to_Leak_Memory"></A></P><H3><HR><B>CHANGED: </B>Why Xmit Functions Seem to Leak Memory (5/5/97)</H3><DL>   <DD>Q: I've noticed that the system seems to leak a little bit of   memory every time I call an Xmit soup function, but not if I call   the non-xmitting versions of the functions. For example, executing   this code shows a little less free memory each time   <CODE>Stats()</CODE> is called:<BR>            <PRE><CODE>    gc(); stats();    soup:AddToDefaultStoreXmit({ foo : "a test string"}, '|bar:SIG|);    gc(); stats();    soup:AddToDefaultStoreXmit({ foo : "another test string"}, '|bar:SIG|);    gc(); stats();</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      A: There is no leak. What's actually going on is that the Xmit   versions of the soup methods do their broadcasting in deferred   actions. That's good, because it means that broadcast handlers   that might throw or have other side effects won't break your code.   A little bit of heap memory is used to keep track of the deferred   action and its arguments. This memory is released after the   deferred action executes, which is typically immediately after   control returns to the top level.<BR>      <BR>      If you select all the test code in the NTK Inspector and press the   Enter key, NTK compiles the entire selection and executes it as a   single operations, so control doesn't return to the top level   (thus allowing the deferred actions to execute) until after the   last operation. The deferred action created by each call to the   Xmitting function will still be pending, so the space won't have   been released yet, and stats reflect this. If the example is   executed one line at a time, you'll see that no memory is actually   leaked.<BR>      <BR>      If you pass <CODE>nil</CODE> for the <CODE>changeSym</CODE>   argument to the Xmit functions, no notification occurs and the   deferred action is not created. Normally, this is a bad idea,   since you want other applications to know about your soup changes.   However, Xmit notification may not be necessary for specialized   applications that use only their own application soups and do not   publish information about reading/writing soup data for   extensibility.<BR>      <BR>      If you are modifying a very large number of entries (for instance,   creating a new soup of thousands of entries), you might pass   <CODE>nil</CODE> for the <CODE>changeSym</CODE> to void immediate   notification. Afterwards, use the <CODE>XmitSoupChange</CODE>   global function with the <CODE>'whatThe</CODE> symbol. (See the   documentation for <CODE>XmitSoupChange</CODE> for more   information.)</P></DL><H2>Desktop Connectivity (DILs)</H2><P><A NAME="Differences_between_MNP,_Modem,_Modem-MNP,_and_Real_Modems"></A></P><H3><HR>Differences between MNP, Modem, Modem-MNP, and Real Modems (2/5/96)</H3><DL>   <DD>Q: I want to just connect to a Newton device over a cable from   a MacOS or Windows machine - what do I need to use to get reliable   communications?<BR>      Q: I want to have the DILs answer an incoming call over a modem.   How can I do that?<BR>      Q: What's the difference between the "Serial" and "Modem" Mac   connection types?<BR>      <BR>      A: In release 1.0 of the DILs, the best way to connect to a Newton   device is by using a MNP connection over a serial cable. This is   what you're using when you set connection type "Modem" on MacOS   computers and "MNP" on Windows computers. This actually has nearly   nothing to do with modems as such; it means you're connecting over   a serial cable using MNP error correction and compression. (And on   Windows, it's the only supported option at this time.)<BR>      <BR>      Currently you cannot use a true modem with the DILs to connect to   a Newton device.<BR>      <BR>      In general, you will never use the "Serial" connection type on a   MacOS computer; that connects over a serial cable (like "Modem"   does) but offers no error detection. Therefore, you would have to   write your own code to check that data arrived safely.</DL><P><A NAME="CDPipeInit_Returning_-28102_on_MacOS_Computers"></A></P><H3><HR>CDPipeInit Returning -28102 on MacOS Computers (2/13/96)</H3><DL>   <DD>Q: When I call the DILs function <CODE>CDPipeInit</CODE>, it   returns a -28102 error (Communication tool not found). I've   checked that the tool is installed properly, and the DIL sample   application works fine. What's wrong?<BR>      <BR>      A: A common cause of this error code is that the CSTR resources   haven't been linked into your final executable. Those resources   are used to find the filenames of the communications tools. Add   the resource file named "<CODE>CSTR.rsrc</CODE>" to your project   and see if that fixes things.</DL><P><A NAME="Getting_Serial_Port_Names_on_MacOS_Computers"></A></P><H3><HR>Getting Serial Port Names on MacOS Computers (2/13/96)</H3><DL>   <DD>Q: Different MacOS computers have different numbers of ports,   different names for the ports, and the port names are translated   into other languages in non-English MacOS System Software. How can   I tell what serial ports are available?<BR>      <BR>      A: You can use the Communications Toolbox to get the list of   available serial ports. This code has been added to version 2 of   the SoupDrink sample code - see the <CODE>SetupPortMenu   </CODE>function in SoupDrink.c for an example.</DL><P><A NAME="Corruption_of_Some_Binary_Objects"></A></P><H3><HR>Corruption of Some Binary Objects (5/13/96)</H3><DL>   <DD>Q: Sometimes when I send a binary object (including a real)   from the Newton device, it is corrupted when I read it with the   FDILs on the desktop. What's going on?<BR>      <BR>      A: When FDILs 1.0 receive a binary object, they must "guess"   whether it is a string or not. This guessing algorithm has a flaw   which can result in non-string binary objects being treated as   strings, and thus the Unicode conversion process is performed on   them, which results in corruption of the desktop binary   object.<BR>      <BR>      The easiest ways to avoid this problem are to either receive the   data with the CDIL (in other words, don't include them in the   frame), or else to ensure that either the first two or the last   two bytes of the binary object are non-zero. This workaround will   not be necessary in future versions of the DIL libraries.<BR>      <BR>      Note: this has been fixed in the 1.0.2 Windows DILs.</DL><P><A NAME="Error_-28801_or_-28706_from_FDget"></A></P><H3><HR>Error -28801 or -28706 from FDget (5/13/96)</H3><DL>   <DD>Q: Why does the <CODE>FDget </CODE>function return error   -28801 (Out of heap memory) or -28706 (Invalid parameter)? I don't   think I'm out of memory, and I don't always get this error code so   my parameters must be right. What is wrong?<BR>      <BR>      A: Sometimes these error codes are accurate and indicate that not   enough memory could be allocated or that a parameter was invalid.   Sometimes they are the result of a bug caused by having multiple   copies of a rectangle slot inside a frame.<BR>      <BR>      The protocol which is used to send frames can perform an   optimization for certain rectangle frames, which transmits them in   a compact form (5 bytes instead of up to 60). However, if a given   frame holds the exact same rectangle frame in more than one slot,   the data will not be handled correctly and will either result in   one of these error codes, or alternatively it might substitute   some other object in place of the frame, or might possibly   crash.<BR>      <BR>      This is a relatively uncommon problem, since all of the values in   the frame must be between 0 and 255, and the frame must have the   same rectangle in it twice - two frames with equivalent data would   not trigger the problem. For example, frame "A" would cause the   problem, but frames "B", "C" and "D" would not.<BR>      <BR>            <PRE><CODE>A:={first: {left:3, right: 30, top:10, bottom:90}};A.second := A.first;           // triggers the problem&nbsp;B:={first: {left:3, right: 30, top:10, bottom:90}};B.second := clone(B.first);    // cloning avoids the problem&nbsp;C:={first: {left:3, right: 30, top:10, bottom:90, foo: nil}};C.second := C.first;           // no problem since C.foo exists&nbsp;D:={first: {left:3, right: 30, top:10, bottom:1000}};D.second := D.first;       // no problem since D.bottom is &gt;255</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      To work around this problem, you can clone the frame (as in frame   "B") or add another slot to the frame (as in frame "C") or ensure   that the values are not between 0 and 255 (frame "D").<BR>      <BR>      Note: this has been fixed in the 1.0.2 Windows DILs.</P></DL><P><A NAME="Using_CDPipeListen_Asynchronously_in_Windows_Applications"></A></P><H3><HR>Using CDPipeListen Asynchronously in Windows Applications (7/15/96)</H3><DL>   <DD>Q: I am passing in a callback function to   <CODE>CDPipeListen</CODE>, but it never seems to be called. What   is going wrong?<BR>      <BR>      A: Due to a bug in <CODE>CDPipeListen</CODE>, the callback   function never gets called in Windows applications. You will have   to use a synchronous listen, then wait for the state of the DIL   pipe to change before accepting the connection. The following code   shows how to properly accept a connection.<BR>            <PRE><CODE>anErr = CDPipeListen( gOurPipe, kDefaultTimeout, NULL, 0 );&nbsp;if (!anErr) {    // This code doesn't need to be executed on MacOS, but     // is currently required for Windows.  We need to loop,    // waiting for the connection state to change to    // kCDIL_ConnectPending.    endTime = (GetTickCount()/1000) + 30;  // to timeout in 30 seconds    while ((GetTickCount()/1000) &lt; endTime )     {        if (CDGetPipeState( gOurPipe ) == kCDIL_ConnectPending) {            anErr = CDPipeAccept( gOurPipe );            break;        } else            CDIdle( gOurPipe );    }}</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note: this has been fixed in the Windows DILs 1.0.2.</P></DL><P><A NAME="Unicode_Strings_and_Memory_Buffers"></A></P><H3><HR>Unicode Strings and Memory Buffers (8/26/96)</H3><DL>   <DD>Q: Sometimes when I use the DILs to get a string, some memory   gets corrupted even though I'm sure I've allocated more memory   than I have characters in the string. What's going on?<BR>      <BR>      A: One common cause is that strings arriving from a Newton device   are in Unicode - which takes two bytes per character. If you've   only allocated one byte per character, you risk memory corruption   because the data is converted to the one-byte form only after the   whole buffer has arrived. This might be too late to prevent   overrunning the buffer bounds. So, you need to allocate enough   space for the Unicode version.<BR>      <BR>      For example, if you're expecting strings to be up to 50 characters   long, you must allocate at least 100 bytes of memory in your   buffer.</DL><H2>Digital Books</H2><P><A NAME="BookMaker_Page_Limitations_"></A></P><H3><HR>BookMaker Page Limitations? (11/19/93)</H3><DL>   <DD>Q: Does the Newton BookMaker have limitations concerning the   size of books or page count?<BR>      <BR>      A: The current page limitation of BookMaker is 16 million pages, a   very unlikely size to be exceeded. However, since the entire book   is held in memory during the build process, you need to have   enough application heap space allocated to the BookMaker desktop   application. If there is not enough RAM available on your desktop   computer to process a book, you can divide it into smaller parts   and link them with the <CODE>.chain</CODE> command.</DL><H2>Drawing and Graphics</H2><P><A NAME="Drawing_Text_on_a_Slanted_Baseline"></A></P><H3><HR>Drawing Text on a Slanted Baseline (9/15/93)</H3><DL>   <DD>Q: Is it possible in the Newton OS to draw text on a slanted   baseline? I don't mean italics, but actually drawing a word at a   45 or 60 degree angle and so on. For example, can text be drawn   along a line that goes from 10,10 to 90,90 (45 degrees)?<BR>      <BR>      A: The drawing package in the Newton OS supports no calls for   rotating text. Note: this is like QuickDraw in the MacOS operating   system. In MacOS, the workaround is to draw the text into a bitmap   and then rotate the bits; you can do the same on a Newton device.   In the Newton OS, we even provide calls to rotate a bitmap in 90   degree increments.<BR>      <BR>      You might consider creating a font having characters that are   pre-rotated to common angles (such as 30 or 45 degrees) so that   applications could just draw characters rather than actually   having to rotate a bitmap.</DL><P><A NAME="LCD_Contrast_and_Grey_Texture_Drawing"></A></P><H3><HR>LCD Contrast and Grey Texture Drawing (11/10/93)</H3><DL>   <DD>Q: An artist working with me did a wonderful job rendering a   3D look using several different dithered grey textures. The   problem is that when her image is displayed on a Newton display   everything on the screen dims. Is it possible that the image   causes too much display current to maintain contrast?<BR>      <BR>      A: What you're seeing is a well-known problem with LCD displays,   and there's not a lot you can do about it. It's especially   aggravated by large areas of 50% dithered gray (checkerboard)   patterns, but the light gray and dark gray patterns also cause   some of it.<BR>      <BR>      The user interface of the Newton OS deliberately avoids 3-D   styling and 50% dithered grays as much as possible for this   reason. If you know your application is going to display large   gray areas, you can adjust the contrast yourself on some hardware   devices. There's a global function, <CODE>SetLCDContrast</CODE>,   to do just that. However, changing the contrast with no end user   control is not considered a good user-interface practice.<BR>   </DL><P><A NAME="Destination_Rectangles_and_ScaleShape"></A></P><H3><HR>Destination Rectangles and ScaleShape (3/11/94)</H3><DL>   <DD>Q: What is a valid destination rectangle for the 2nd argument   to <CODE>ScaleShape</CODE>?<BR>      <BR>      A: The destination rectangle must be at least 1 pixel wide and 1   pixel high. Each element of the bounds frame must have values that   fit in 16 bits, -32768...32767. 0-width/height and negative   width/height bounding boxes may appear to work in some cases, but   are not supported.</DL><P><A NAME="How_to_Rotate_Bitmaps_Left"></A></P><H3><HR>How to Rotate Bitmaps Left (3/5/96)</H3><DL>   <DD>Q: When I rotate a bitmap left using <CODE>MungeBitmap</CODE>,   it sometimes shifts the data. How can I rotate left correctly?<BR>      <BR>      A: There is a bug in the Newton 2.0 OS that manifests when the row   size of the unrotated bitmap is not an even byte boundary. The   result can be a shift of data up to 7 pixels.<BR>      <BR>      You can work around this bug most efficiently by replacing the   left rotation with three calls to <CODE>MungeBitmap</CODE> using   these operations: <CODE>'flipHorizontal</CODE>,   <CODE>'flipVertical</CODE>, and <CODE>'rotateRight</CODE>.   (<CODE>'rotateRight</CODE> three times will work as well, but it   is less efficient bacause flips are faster than rotates.)<BR>      <BR>      Remember: "Three Rights (or Two Flips and a Right) Make a Left".</DL><P><A NAME="Newton_Bitmap_Formats"></A></P><H3><HR>Newton Bitmap Formats (5/14/96)</H3><DL>   <DD>Q: What is the format for bitmap binary objects in the Newton   OS?<BR>      <BR>      A: There are several bitmap formats used in the Newton OS. The   Newton OS provides routines for creating and manipulating bitmaps   at runtime, and uses other formats for displaying bitmaps from   developer packages.<BR>      <BR>      If you want to create a bitmap object at compile time, below is a   description of the format of a simple bitmap object. If you want   to create a bitmap at run time, we strongly encourage you to use   <CODE>MakeBitmap</CODE> and copy data into the bitmap.<BR>      <BR>      <B>Simple Bitmaps<BR>      </B><BR>      Normally, bitmaps are created at compile time using Newton Toolkit   picture editors or functions (for example,   <CODE>GetPICTAsBits</CODE>). If you want to create bitmaps   dynamically at compile time, you can create a simple bitmap object   with the following format.<BR>      <BR>      <I>Warning</I>: Different formats may be used by images or   functions in future ROMs. This format will still be supported for   displaying images. This format does <I>not</I> describe images   created by other applications nor any images provided or found in   the Newton ROM. You can use the following format information to   create and manipulate your own bitmaps -- preferably at compile   time:<BR>      <B><BR>      </B>      <PRE><CODE>{    bounds: &lt;bounds frame&gt;,    bits:   &lt;raw bitmap data&gt;,    mask:   &lt;raw bitmap data for mask - optional&gt;}&nbsp;    Binary object &lt;raw bitmap data&gt; - class 'bits        bytes    data-type  descr    0-3      long       ignored    4-5      word       #bytes per row of the bitmap data                        (must be a multiple of 4)    6-7      word       ignored    8-15     bitmap     rectangle - portion of bits to use--see IM I    8-9      word       top    10-11    word       left    12-13    word       bottom    14-15    word       right    16-*     bits       pixel data, 1 for "on" pixel, 0 for off&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The bitmap rectangle and bounds slot must be in agreement   regarding the size of the bitmap.<BR>      <BR>      <B>MakeBitmap Shapes<BR>      </B><BR>      If you want to create bitmap data at run time or extract bitmap   data from a bitmap created with the <CODE>MakeBitmap</CODE> global   function, use the <CODE>GetShapeInfo</CODE> function to get the   bitmap and other slots required to interpret the meaning of the   bitmap created by <CODE>MakeBitmap</CODE>.<BR>      <BR>      <I>Warning</I>: the following information applies only to bitmaps   of depth 1 (black and white bitmaps) created by your application   with MakeBitmap. Do <I>not</I> rely on <CODE>GetShapeInfo</CODE>   or the following slots for images created by other applications,   images stored in the Newton ROM, images created with functions   other than <CODE>MakeBitmap</CODE>, nor images with a depth other   than 1.<BR>      <BR>      If you created a bitmap using <CODE>MakeBitmap</CODE> of   <CODE>depth</CODE> 1, the return value of   <CODE>GetShapeInfo</CODE> contains frame with information you can   use to interpret the bitmap data.<BR>      <BR>      This frame includes a <CODE>bits</CODE> slot referencing the   bitmap data for the bitmap. This bitmap data can be manipulated at   run time (or copied for non-Newton use), using other slots in the   return value of <CODE>GetShapeInfo</CODE> to interpret the bitmap   binary object: <CODE>scanOffset</CODE>, <CODE>bitsBounds</CODE>,   and <CODE>rowBytes</CODE>. For instance, the first bit of the   image created with <CODE>MakeBitmap</CODE> can be obtained with   code like:<BR>      <BR>      </P>      <PRE><CODE>   bitmapInfo := GetShapeInfo(theBitmap);   firstByte := ExtractByte(bitmapInfo.bits, bitmapInfo.scanOffset);   firstBit := firstByte &gt;&gt; 7; // 1 or 0, representing on or off</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that <CODE>rowBytes</CODE> will always be 32-bit aligned. For   instance, for a bitmap with a <CODE>bitsBounds</CODE> having width   33 pixels, <CODE>rowBytes</CODE> will be 8 to indicate 8 bytes   offsets per horizontal line and 31 bits of unused data at the end   of every horizontal line.</P></DL><P><A NAME="Difference_Between_LockScreen_and_RefreshViews"></A></P><H3><HR>Difference Between LockScreen and RefreshViews (1/15/97)</H3><DL>   <DD>Q: In the NPG, it states that sending a view the<CODE>   view:LockScreen(nil)</CODE> message forces an "immediate update".   How is this different from calling <CODE>RefreshViews</CODE>?<BR>      <BR>      A: When you post drawing commands (for example,   <CODE>DrawShape</CODE>) the system normally renders the shape on   the screen immediately. <CODE>:LockScreen(true) </CODE>provides a   way to "batch up" the screen updates for multiple drawing calls.   Sending <CODE>:LockScreen(nil)</CODE> "unplugs" the temporary   block that has been placed on the screen updater, causing all the   batched drawing changes to be rendered on the LCD.<BR>      <BR>      <CODE>RefreshViews </CODE>tells the system to execute the commands   needed to draw every view that has a dirty region. You can think   of it as working at a level "above" the screen lock routines. When   you send the message <CODE>Dirty</CODE>, it does not immediately   cause the system to redraw the dirtied view, instead it adds the   view to the dirty area for later redrawing.<BR>      <BR>      You could lock the screen, dirty a view with a   <CODE>SetValue</CODE>, call <CODE>RefreshViews</CODE> (and not see   an update) draw a few shapes, and then, when you unlock the   screen, the refreshes to the dirty regions and your shapes will   all appear at once.<BR>      <BR>      A bit more detail on the interaction between   <CODE>LockScreen</CODE> and <CODE>RefreshViews</CODE>:<BR>      1. Does <CODE>LockScreen(nil)</CODE> result in a   <CODE>RefreshViews</CODE>?<BR>      <BR>      No. <CODE>LockScreen(true)</CODE> just stops the hardware screen   from updating from the offscreen buffer.   <CODE>LockScreen(nil)</CODE> releases that lock which usually   causes the hardware screen to update soon thereafter.<BR>      <BR>      2. While the screen is locked, will <CODE>SetValues</CODE> draw   into the offscreen buffer?<BR>      <BR>      <CODE>SetValue</CODE> doesn't draw. Otherwise, see 1.<BR>      <BR>      3. While the screen is locked, what is the result of calling   <CODE>RefreshViews</CODE>?<BR>      <BR>      It will draw any dirty views into the offscreen buffer.<BR>   </DL><P><A NAME="Drawing_White_Text_on_a_Filled_Background"></A></P><H3><HR>Drawing White Text on a Filled Background (1/15/97)</H3><DL>   <DD>Q: I tried using <CODE>vfFillWhite</CODE> and   <CODE>kRGB_0</CODE> but neither seems to work. How do I draw white   text?<BR>      <BR>      A: kRGB_White has some unusual behavior. If you want a   white-on-black effect then you will need to use one of two   workarounds:<BR>      <BR>      For white text on a filled background using a style frame, set   your background to the desired shade using either the fill color   of the view or a filled object (in other words, do not do this   just by setting the color fill of the text). Then use the   <CODE>textPattern</CODE> slot in the style frame to make the text   black (<CODE>kRGB_Black</CODE>) and set the   <CODE>transferMode</CODE> to <CODE>modeBic</CODE>.<BR>      <BR>      For white text on black using the color slot of the viewFont   frame, use <CODE>kRGB_Gray1</CODE> for something that is as close   to white as you can get.<BR>   </DL><P><A NAME="Interaction_Between_Transfer_Modes_and_Gray_Patterns"></A></P><H3><HR>Interaction Between Transfer Modes and Gray Patterns (1/15/97)</H3><DL>   <DD>Q: How do the transfer modes interract with the new gray   shades in Newton OS 2.1?<BR>      <BR>      A: Here is how the transfer modes interact with images. Colors are   determined by looking up the value in the color table. For   instance, white means that the indexed pixel value is white in the   color table. All the NOT modes operate on the values from the   color table. In other words, the pixel value is looked up before   the NOT is applied.<BR>      <BR>      When the source and destination are different bit depths, the   source is effectively expanded or shrunk to match the depth of the   destination bitmap prior to drawing. When expanding, the index   into the color table's bit pattern is repeated to fill the   destination pixel. For instance, a 2-bit index of 0x1 (binary 01)   is expanded to 0x3 (binary 0011) for 4 bits, while a 2-bit index   of 0x2 (binary 10) is expanded to 0xC (binary 1100).<BR>      <BR>      <CODE>modeOr</CODE> - Replaces pixels under the non-white part of   the source image with source pixels. If the source pixel is white,   the destination pixel is unchanged.<BR>      <BR>      <CODE>modeXor</CODE> - Inverts pixels under the non-white part of   the source image. Destination pixels under the white part of the   source image are unchanged. This actually XORs the values in the   source and destination pixels. For example, for destination of 0xA   (75% grey), source 0x0 (white) produces result 0xA (unchanged).   Source 0xF (black), produces result 0x5 (25% grey, or inverted).   Source pixels of other values have less utility. For example,   source 0x5 (25% grey) produces result 0xF (black), while source   0xA (75% grey) produces result 0x0 (white), and source 0x3 (50%   grey) produces result 0x9 (slightly less than 75% grey).<BR>      <BR>      <CODE>modeBic</CODE> - Erases screen pixels under the non-white   part of the source image, making them all white. Destination   pixels under the white part of the source image are unchanged.   This actually, does a bitwise NOT, so it is really only useful   when source pixels are either 0 (white) or 0xF (black). With other   values, weird things happen, For example, destination 0xF with   source 0xA produces result 0x5. Destination 0x0 with source 0xA   produces result 0x0. Destination 0x3 with source 0xA produces   result 0x1.<BR>      <BR>      <CODE>modeNotCopy</CODE> - Replaces screen pixels under the black   part of the source image with white pixels. Screen pixels under   the white part of the source image are made black.<BR>      <BR>      <CODE>modeNotOr</CODE> - Screen pixels under the black part of the   source image are unchanged. Screen pixels under the white part of   the source image are made black.<BR>      <BR>      <CODE>modeNotXor</CODE> - Screen pixels under the black part of   the source image are unchanged. Screen pixels under the white part   of the source image are inverted.</DL><P><A NAME="Limitations_of_GrayShrink"></A></P><H3><HR>Limitations of GrayShrink (3/4/97)</H3><DL>   <DD>Q: Why isn't <CODE>GrayShrink</CODE> doing what I want it to   when I use it with relatively small bitmaps?<BR>      <BR>      A: <CODE>GrayShrink</CODE> was designed for rendering relatively   large images such as received faxes into a moderately large part   of a Newton display. It works by setting a flag in the bitmap that   tells the imager to gather multiple bits from the source bitmap   and turn them into a single gray pixel when drawing through a   reducing transform.<BR>      <BR>      If passed a bitmap that is more than one bit deep, the shrinking   algorithm is not appropriate and so <CODE>GrayShrink</CODE> will   not modify the bitmap. The end result will be a transformed   (shrunk) image with the same bit depth as the original. That is,   the shrinking will still happen, but the graying won't.<BR>      <BR>      <CODE>GrayShrink</CODE> will not work with read-only bitmaps (it   is unable to set the flag.) The result will still be a transformed   (shrunk) image, but pixels will not be combined to gray. There is   no way to clear the flag once it has been set. After   <CODE>GrayShrink</CODE> has modified a bitmap, drawing it to the   screen through any scaling transform that reduces the image will   produce a pixel combined gray result.<BR>      <BR>      The <CODE>GrayShrink</CODE> pixel gathering algorithm produces an   anomaly along the righthand side of the reduced image. When   rendering large bitmaps into a reasonably large destination, this   is generally uunnoticeable. However, when used with small source   bitmaps or when rendering into a small area, several columns along   the right side of the result may not be drawn, and the anomaly is   easily seen. We recommend using <CODE>GrayShrink</CODE> and the   <CODE>'drawGrayScaled </CODE>setting for   <CODE>protoImageView</CODE> only for large source images such as   incoming faxes or scanned data.</DL><P><A NAME="Limitations_of_MungeBitmap"></A></P><H3><HR>Limitations of MungeBitmap (4/3/97)</H3><DL>   <DD>Q: When I use <CODE>MungeBitmap</CODE> to flip or rotate a   grayscale image, it gets corrupted. What's wrong?<BR>      <BR>      A: <CODE>MungeBitmap</CODE> does not properly handle bitmaps with   a depth greater than 1. You can work around this problem by using   <CODE>kMungeBitmapFunc</CODE>, which has the same calling   conventions and return value as <CODE>MungeBitmap</CODE>.   <CODE>kMungeBitmapFunc</CODE> is provided in the Newton 2.1   Platform file, version 1.2b1 or later.<BR>      <BR>      Calling <CODE>MungeBitmap</CODE> with the   <CODE>'rotateLeft</CODE>,<CODE> 'rotateRight</CODE>, or   <CODE>'flipHorizontal</CODE> options will trigger the bug. The   <CODE>'rotate180</CODE> and <CODE>'flipVertical</CODE> arguments   to <CODE>MungeBitmap</CODE> work correctly with deeper   bitmaps.<BR>      <BR>      Note that with the Newton 2.1 OS release in the [English language]   Apple MessagePad 2000 and Apple eMate 300 products, the built-in   Drawing stationery in NewtonWorks exhibits this bug when rotating   gray bitmaps.</DL><P><A NAME="Leave_Extra_Space_for_Text_When_Printing"></A></P><H3><HR><B>NEW: </B>Leave Extra Space for Text When Printing (5/7/97)</H3><DL>   <DD>Q: I use text height/width functions to determine the exact   size to make text for printing/faxing , but sometimes text still   gets clipped. What's wrong?<BR>      <BR>      A: Text height/width functions are guaranteed to be accurate only   for on-screen use, and so the text may not actually fit in the   bounds box you created for the text. This is true whether you draw   the text using text shapes or try to create views of "minimal"   size for the text. The exact bounds will usually be close to the   bounds returned by functions like <CODE>TextBounds</CODE> and   <CODE>StrFontWidth</CODE>, but those values may be too small to   fit.<BR>      <BR>      Some of this problem is due to inherent ambiguities in PostScript   font substitution (for PostScript-based Apple LaserWriters.) Some   of this problem is due to ROM problems in font scaling for   raster/bitmap printers (including fax) at resolutions that are not   72 DPI.<BR>      <BR>      To work around this problem, be as liberal as possible when   designing the bounds for your text, using view justification as   appropriate.<BR>      <BR>      If you do not need a frame around your text or special   calculations about text size, we recommend making your view or   text shape as large as possible. For instance, a centered page   number at the bottom of the page could be a text view that is   justified with "parent full horizontal" justification with   centered text. Or, it could be a text shape that is very large (as   wide as the page -- use <CODE>:LocalBox()</CODE> to find out) and   use center justification in a style frame passed to   <CODE>:DrawShape(...)</CODE>.<BR>      <BR>      If you wanted a frame or border around your text, or have some   other reason for wanting to know the exact size, use the font   width/height functions and then add some space to the text bounds.   As a guideline, adding 6% to the width/height when printing should   be enough space to account for these problems. We recommend you   experiment with different printers and page sizes (in the Locale   preferences) to ensure that the "extra space" is enough for your   text items.<BR>      <BR>      Note: there is an unrelated text printing bug in the MessagePad   2000 and eMate 300 devices that in some circumstances will clip   parts or entire characters, occasionally preventing small text   strings from printing entirely. As of 7/16/97, this bug is fixed   for the MessagePad 2000 in System Update "MessagePad 2000 2.1   (717041)US", but is not yet fixed on the eMate 300.</DL><H2>Endpoints &amp; Comm Tools</H2><P><A NAME="What_is_Error_Code_-18003"></A></P><H3><HR>What is Error Code -18003 (3/8/94)</H3><DL>   <DD>Q: What is error code -18003?<BR>      <BR>      A: This signal is also called SCC buffer overrun; it indicates   that the internal serial chip buffer filled, and the NewtonScript   part didn't have time to read the incoming information. You need   to either introduce software (XON/XOFF) or hardware flow control,   or make sure that you empty the buffer periodically.<BR>      <BR>      You will also get -18003 errors if the underlying comms tool   encounters parity or frame errors. Note that there's no difference   between parity errors, frame errors, or buffer overruns; all these   errors are mapped to -18003.<BR>      <BR>      See the diagram for an explanation of what is going on concerning   the serial chip, the buffers and the scripting world.<BR>      <BR>      The SCC chip gets incoming data, and stores it in a 3-byte buffer.   An underlying interrupt handler purges the SCC buffer and moves it   into a special tools buffer. The comms system uses this buffer to   scan input for valid end conditions (the conditions which cause   your inputSpec to trigger). Note that you don't lose data while   you switch inputSpecs; it's always stored in the buffer during the   switch.<BR>      <BR>      Now, if there's no flow control (XON/XOFF, HW handshaking, MNP5),   the network side will slowly fill the tool buffer, and depending   on the speed the buffer is handled from the scripting world sooner   or later the comms side will signal a buffer overrun. Even if flow   control is enabled, you may still receive errors if the sending   side does not react fast enough to the Newton&Otilde;s plea to   stop sending data. In the case of XON/XOFF, if you suspect that   one side or the other is not reacting or sending flow control   characters correctly, you may want to connect a line analyzer   between the Newton and the remote entity to see what is really   happening.<BR>      <BR>      If you have inputScripts that take a long time to execute, you   might end up with overrun problems. If possible, store the   received data away somewhere, quickly terminate the inputSpec,   then come back and process the data later. For instance, you could   have an idleScript which updates a text view based on data stored   in a soup or in a slot by your inputSpec.</DL><P><CENTER><IMG SRC="pictures/buffers.gif" ALT="Q&amp;A Diagram"WIDTH=460 HEIGHT=202 X-SAS-UseImageWidth X-SAS-UseImageHeightBORDER=0 ALIGN=bottom></CENTER></P><P><A NAME="Newton_Remote_Control_IR_(Infra-red)_API"></A></P><H3><HR>Newton Remote Control IR (Infra-red) API (6/9/94)</H3><DL>   <DD>NTK 1.0.1 and future NTK development kits contain the needed   resources to build applications that control infrared receive   systems, consumer electronics systems and similar constructs.<BR>      <BR>      This development kit is fairly robust, and will produce send-only   applications.<BR>      <BR>      Note: The NTK 1.1 platforms file is required to produce code that   will execute correctly on the MessagePad 100 upgrade units.<BR>      <B><BR>      </B>      <PRE><CODE>cookie := OpenRemoteControl();</CODE></PRE>      <P><CODE><BR>      </CODE>Call this function once to initialize the remote control   functions. It returns a magic cookie that must be passed to   subsequent remote control calls, or nil if the initialization   failed.<BR>      <BR>      </P>      <PRE><CODE>CloseRemoteControl(cookie);</CODE></PRE>      <P><CODE><BR>      </CODE>Call this function once when all remote control operations   are completed, passing cookie returned from   <CODE>OpenRemoteControl</CODE>. Always returns <CODE>nil</CODE>.   cookie is invalid after this call returns.<BR>      <BR>      </P>      <PRE><CODE>SendRemoteControlCode(cookie, command, count);</CODE></PRE>      <P><CODE><BR>      </CODE>Given the cookie returned from   <CODE>OpenRemoteControl</CODE>, this function sends the remote   control command (see below for format of data). The command is   sent count times. count must be at least 1. Returns after the   command has been sent (or after the last loop for <CODE>count   </CODE>&gt; 1). (see diagram)<BR>      <BR>      Each command code has the following structure:<BR>      </P>      <PRE><CODE>struct IRCodeWord {    unsigned long name;    unsigned long timeBase;    unsigned long leadIn;    unsigned long repeat;    unsigned long leadOut;    unsigned long count;    unsigned long transitions[];};&nbsp;&nbsp;</CODE></PRE>      <P><CODE><BR>      name</CODE> identifies the command code; set to anything you   like<BR>      <CODE>timeBase</CODE> in microseconds; sets the bit time base<BR>      <CODE>leadIn</CODE> duration in timeBase units of the lead bit   cell<BR>      <CODE>repeat</CODE> duration in timeBase units of the last bit   cell for loop commands<BR>      <CODE>leadOut</CODE> duration timeBase units of the last bit cell   for non-loop commands<BR>      <CODE>count</CODE> one-based count of transitions following<BR>      <CODE>transitions</CODE>[ ] array of transition durations in   timeBase units<BR>      </P>      <P><CODE><BR>      </CODE>Note that the repeat time is used only when the code is   sent multiple times.<BR>      <BR>      See Remote., Sony.r, RC5.r, and RemoteTypes.r files for examples.   The .rsrc files have templates for ResEdit editing of the Philips   and Sony resources. See Remote IR Sample code for more   details.<BR>      <BR>      <B>Things To Know Before You Burn The Midnight Oil:<BR>      <BR>      </B>If the Newton goes to sleep, the IR circuits are powered down,   and any subsequent sends will fail. If you want to override this,   you need to have a powerOffhandler close the remote connection,   and when Newton wakes up the application could re-open the   connection.<BR>      <BR>      If two applications are concurrently trying to use the IR port   (beaming and remote control use for instance), this will cause a   conflict.<BR>      <BR>      <B>Sample Code<BR>      <BR>      </B>The Remote IR Sample is part of the DTS Sample code   distribution, you should find it on AppleLink and on the Internet   ftp server (ftp.apple.com).<BR>      <BR>      By way of a quick summary: the sample has an array of picker   elements with the resource definitions bound to the index (ircode   inside the application base view).<BR>      <BR>      You specify the constant that is an index to the array, get the   resource using the NTK function <CODE>GetNamedResource </CODE>and   when you send data, use the constant as the resource used.<BR>      <BR>      <CODE>OpenRemoteControl </CODE>is called in   <CODE>viewSetupFormscript</CODE>, and <CODE>closeRemoteControl   </CODE>is called in <CODE>viewQuitScript</CODE>. Note that these   are methods, not global functions; same is true of   <CODE>SendRemoteControlCode</CODE>.<BR>      <BR>      <B>More Information<BR>      </B><BR>      Consult the IR samples available on ftp.apple.com (Internet) and   on the Newton Developer CD-ROMs.</P></DL><P><CENTER><IMG SRC="pictures/remtcntl.gif" ALT="Q&amp;A Diagram"WIDTH=433 HEIGHT=90 X-SAS-UseImageWidth X-SAS-UseImageHeight BORDER=0ALIGN=bottom></CENTER></P><P><A NAME="Communications_With_No_Terminating_Conditions"></A></P><H3><HR>Communications With No Terminating Conditions (6/9/94)</H3><DL>   <DD>Q: How do I handle input that has no terminating characters   and/or variable sized packets?<BR>      <BR>      A: Remember that input specs are specifically tied to the receive   completion mechanism. To deal with the situations of no   terminating characters or no set packet sizes, you need only   realize that one receive completion is itself a complete packet.   Set the <CODE>byteCount</CODE> slot of your input spec to the   minimum packet size. In your input script, call   <CODE>Partial</CODE> to read in the entire packet, and then call   <CODE>FlushInput</CODE> to empty everything out for your next   receive completion.<BR>      <BR>      If this is time-delay-based input, you may be able to take   advantage of <CODE>partialScripts</CODE> with   <CODE>partialFrequencies</CODE>. Call the <CODE>Ticks</CODE>   global function if necessary to determine the exact execution time   of a <CODE>partialScript</CODE>.<BR>   </DL><P><A NAME="What_Really_Happens_During_Instantiate_&_Connect"></A></P><H3><HR>What Really Happens During Instantiate &amp; Connect (6/14/94)</H3><DL>   <DD>Q: Does <CODE>Instantiate</CODE>, <CODE>Bind</CODE> or   <CODE>Connect</CODE> touch the hardware?<BR>      <BR>      A: Exactly what happens depends on the type of endpoint being   used. In general:<BR>      <BR>      The endpoint requests one or more communications services using   endpoint options like this:<BR>      <BR>            <PRE><CODE>{  type:      'service,  label:     kCMSAsyncSerial,  opCode:    opSetRequired}&nbsp;</CODE></PRE>      <P><CODE><BR>      &lt;see diagram section A&gt;</CODE><BR>      <BR>      The CommManager task creates the appropriate CommTool task(s) and   replies to the communications service request. Each CommTool task   initializes itself . In response to the <CODE>Bind </CODE>request   the CommTool acquires access to any physical hardware it controls,   such as powering up the device. The endpoint is ready-to-go.<BR>      <BR>      <CODE>&lt;see diagram section B&gt;</CODE><BR>      <BR>      An endpoint may use multiple CommTool tasks, but there will be a   single NewtonScript endpoint reference for them.<BR>      <BR>      When the endpoint requests a connection, the CommTool interacts   wih the physical hardware (or a lower level CommTool) as necessary   to complete the connection, depending on the type of   communications service. For example, ADSP will use the endpoint   address frame to perform an NBP lookup and connection request. MNP   will negotiate protocol specifications such as compression and   error correction.<BR>      <BR>      <CODE>&lt;see diagram section C&gt;</CODE><BR>      <BR>      The CommTool completes the connection and replies to the   connection request. Note that if this is done asynchronously, the   Newt task continues execution, giving the user an option to abort   the connection request.<BR>      <BR>      <CODE>&lt;see diagram section D&gt;</CODE><BR>      <BR>      <CODE>Disconnect</CODE> functions similarly to   <CODE>Connect</CODE>, moving the endpoint into a disconnected   state. <CODE>Unbind</CODE> releases any hardware controlled by the   CommTool. <CODE>Dispose</CODE> deallocates the CommTool task.</P></DL><P><CENTER><IMG SRC="pictures/instanti.gif" ALT="Q&amp;A Diagram"WIDTH=410 HEIGHT=733 X-SAS-UseImageWidth X-SAS-UseImageHeightBORDER=0 ALIGN=bottom></CENTER></P><P><A NAME="Unicode-ASCII_Translation_Issues"></A></P><H3><HR>Unicode-ASCII Translation Issues (6/16/94)</H3><DL>   <DD>Q: How are out-of-range translations handled by the endpoints?   For example, what happens if I try to output "\u033800AE\u Apple   Computer, Inc."?<BR>      <BR>      A: The first Unicode character (0338) is mapped to ASCII character   255 because is it out of the range of valid translations, and the   second Unicode character (00AE) is mapped to ASCII character A8   because the Mac character set has a corresponding character   equivalent in the upper-bit range.<BR>      <BR>      All out-of-range translations, such as the 0338 diacritical mark   above, are converted to ASCII character 255. However, the reverse   is not true! ASCII character 255 is converted to Unicode character   02C7. This means you will need to escape or strip all 02C7   characters in your strings before sending them if you want to use   ASCII character 255 to detect out-of-range translations. Character   255 was picked over character 0 because 0 is often used as the   C-string terminator character.<BR>      <BR>      The built-in Newton Unicode-ASCII translation table is set up to   handle the full 8-bit character set used by the MacOS operating   system. Although <CODE>kMacRomanEncoding </CODE>is the default   encoding system for strings on most Newtons, you can specify it   explicitly by adding one of the following encoding slots to your   endpoint:<BR>      <BR>            <PRE><CODE>encoding:  kMacRomanEncoding;    // Unicode&lt;-&gt;Mac translation</CODE></PRE>      <P><CODE><BR>      encoding: </CODE>kWizardEncoding <CODE>; // Unicode&lt;-&gt;Sharp   Wizard translation<BR>      encoding: </CODE>kShiftJISEncoding <CODE>; //   Unicode&lt;-&gt;Japanese ShiftJIS translation<BR>      </CODE><BR>      For <CODE>kMacRomanEncoding</CODE>, the upper 128 characters of   the MacOS character encoding are sparse-mapped to/from their   corresponding unicode equivalents. The map table can be found in   Appendix B of the NewtonScript Programming Language reference. The   upper-bit translation matrix is as follows:<BR>      <BR>      </P>      <PRE><CODE>short gASCIIToUnicode[128] = {        0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1,        0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8,        0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3,        0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC,        0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF,        0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8,        0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211,        0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x2126, 0x00E6, 0x00F8,        0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB,        0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153,        0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA,        0x00FF, 0x0178, 0x2044, 0x00A4, 0x2039, 0x203A, 0xFB01, 0xFB02,        0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1,        0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4,        0xF7FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC,        0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7};</CODE>&nbsp;</PRE></DL><P><A NAME="How_To_Specify_No_Connect/Listen_Options"></A></P><H3><HR>How To Specify No Connect/Listen Options (2/1/96)</H3><DL>   <DD>Q: How do I specify that there are no options for the<CODE>   Connect </CODE>and <CODE>Listen </CODE>methods of   <CODE>protoBasicEndpoint</CODE>?<BR>      <BR>      A: Different endpoint services use the options parameter   differently. Some check for <CODE>nil </CODE>before attempting to   access the array, while others assume they will always be passed   an array of options. Some also assume that the array will always   contain at least one element.<BR>      <BR>      The correct work-around for this unspecified behaviour is to pass   an array containing a single nil element. This works for all   endpoint service types. For example:<BR>            <PRE><CODE>    ep:Connect([nil], nil);</CODE></PRE></DL><P><A NAME="Why_Synchronous_Comms_Are_Evil"></A></P><H3><HR>Why Synchronous Comms Are Evil (2/1/96)</H3><DL>   <DD>Q: Why does the following loop run slower and slower with each   successive output? If the data variable contains a sufficiently   large number of items, the endpoint times out or the Newton   reboots before all the data is transmitted. For instance:<BR>            <PRE><CODE>    data := [....];    for item := 0 to Length(data) - 1 do        ep:Output(data[ item ], nil, nil);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>A: When <CODE>protoBasicEndpoint </CODE>performs a function   synchronously, it creates a special kind of "sub-task" to perform   the interprocess call to the comm tool task. The sub-task causes   the main NewtonScript task to suspend execution until the sub-task   receives the "operation completed" response from the comm tool   task, at which time the sub-task returns control to the main   NewtonScript task, and execution continues.<BR>      <BR>      The sub-task, however, is not disposed of until control returns to   the main NewtonScript event loop. In effect, each and every   synchronous call is allocating memory and task execution time   until control is returned to the main NewtonScript event loop! For   a small number of sucessive synchronous operations, this is   fine.<BR>      <BR>      A fully asynchronous implementation, on the other hand, is faster,   uses less machine resources, allows the user to interact at any   point in the loop, and is generally very easy to implement. The   above loop can be rewritten as follows:<BR>      <BR>      </P>      <PRE><CODE>ep.fData := [....];ep.fIndex := 0;ep.fOutSpec := {    async:        true,    completionScript:        func(ep, options, error)        if ep.fIndex &gt;= Length(ep.fData) - 1 then            // indicate we're done        else            ep:Output(ep.fData[ ep.fIndex := ep.fIndex + 1 ],                      nil, ep.fOutSpec )    };ep:Output(ep.fData[ ep.fIndex ], nil, ep.fOutSpec );</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Of course, you should always catch and handle any errors that may   occur within the loop (<CODE>completionScript</CODE>) and exit   gracefully. Such code is left as an excercise for the reader.<BR>      </P></DL><P><A NAME="Maximum_Speeds_with_the_Serial_Port"></A></P><H3><HR>Maximum Speeds with the Serial Port (9/19/96)</H3><DL>   <DD>Here are some rough estimates of the speeds attainable with   the Newton serial port in combination with various kinds of flow   control. These numbers are rough estimates, and depending on the   protocol and amount of data (burst mode or not) you might get   higher or lower transmission speeds. Experiment until you have   found the optimal transmission speed.<BR>      <BR>      &#149;0 to 38.4 Kbps<BR>      No handshaking necessary for short bursts, but long transmissions   require flow control (either hardware or XON/XOFF).<BR>      <BR>      &#149;38.4 Kbps to 115 Kbps<BR>      Require flow control, preferably hardware, but XON/XOFF should   also work reasonably reliably.<BR>      <BR>      &#149;115 Kbps +<BR>      You will encounter problems with latency and buffer sizes. Speeds   in this range require an error correcting protocol.<BR>      <BR>      Both hardware and <CODE>XON/XOFF</CODE> flow control can be set   with the <CODE>kCMOInputFlowControlParms </CODE>and   <CODE>kCMOOutputFlowControlParms </CODE>options. In the case of   hardware handshaking <CODE>(RTS/CTS)</CODE> you should use the   following options:<BR>      <BR>            <PRE><CODE>{    label:    kCMOInputFlowControlParms,    type:        'option,    opCode:    opSetRequired,    data:        {    arglist: [                        kDefaultXonChar,                        kDefaultXoffChar,                        NIL,                        TRUE,                        0,                        0,    ],                    typelist: ['struct,                        'byte,                        'byte,                        'boolean,                        'boolean,                        'boolean,                        'boolean,    ],                },},&nbsp;{    label:    kCMOOutputFlowControlParms,    type:        'option,    opCode:    opSetRequired,    data:        {    arglist: [                        kDefaultXonChar,                        kDefaultXoffChar,                        NIL,                        TRUE,                        0,                        0,    ],                    typelist: ['struct,                        'byte,                        'byte,                        'boolean,                        'boolean,                        'boolean,                        'boolean,    ],                },}</CODE>&nbsp;</PRE></DL><P><A NAME="Why_Are_User_Modem_Settings_Ignored"></A></P><H3><HR>Why Are User Modem Settings Ignored (1/15/97)</H3><DL>   <DD>Q: Our customers are complaining that modem preferences such   as Ignore Dial Tone are getting ignored in our product. We are not   doing anything special to set up the modem so why are the system   settings ignored?<BR>      <BR>      A: The user modem settings do not come for free. You must   configure your endpoint based on the user settings. You can get   these using the <CODE>MakeModemOption</CODE> call.<BR>      <BR>      In general, we recommend that you always use   <CODE>MakeModemOption</CODE> when setting up options to intiailize   an endpoint. So you would call <CODE>MakeModemOption</CODE> to get   your initial option array, then add your own custom options after   that. <CODE>MakeModemOption</CODE> will return correct options   based on the user settings for ignore DialTone, use PC Card Modem,   etc.</DL><P><A NAME="Handling_a_-36006_Error_When_Disconnecting"></A></P><H3><HR>Handling a -36006 Error When Disconnecting (1/17/97)</H3><DL>   <DD>Q: Sometimes -36006 is thrown when I call my endpoint's   disconnect method. What is happening?<BR>      <BR>      A: This error will occur when Disconnect is called on a dropped   connection. In fact, any time the endpoint state does not match   the expected state of the calling method, a -36006 exception will   be thrown.<BR>      <BR>      To work around this problem, include an EventHandler method in   your endpoint. When the connection drops, the EventHandler will be   called and passed an event with an eventCode of 2. Simply add a   delayed call to unbind and dispose of your endpoint. Do not use a   deferred call to unbind and dispose of your endpoint: a bug in the   deferred call mechanism can cause unpredictable results with   communications code.</DL><P><A NAME="InputSpec_Input_Form_'Frame_or_'Binary_Buffer_Bug"></A></P><H3><HR>InputSpec Input Form 'Frame or 'Binary Buffer Bug (1/22/97)</H3><DL>   <DD>Q: I have an <CODE>inputSpec</CODE> of form   <CODE>'string</CODE>. When its <CODE>inputScript</CODE> triggers,   I switch to an input form of <CODE>'binary</CODE>. When the binary   <CODE>inputScript</CODE> triggers, the first few bytes of the data   are garbage, and sometimes the <CODE>inputScript</CODE> doesn't   trigger at all. The same behavior occurs when switching to the   <CODE>'frame</CODE> input form. Why?<BR>      <BR>      A: Binary and frame (B/F) input forms do not buffer incoming data   the same way other input forms do. For maximum performance, the   data is written directly into the destination object, rather than   into an intermediate NewtonScript buffer for   <CODE>endSequence</CODE> and <CODE>filter</CODE> processing.<BR>      <BR>      Unfortunately, all data that has been buffered using a non-B/F   input form is lost when switching to a B/F input form, resulting   in corrupted data at the start of input, incorrect   <CODE>byteCount</CODE>, or end-of-packet (<CODE>EOP</CODE>)   detection failure.<BR>      <BR>      The only workaround for this problem is to have the sender wait   until the receiver has switched input forms and has flushed the   input buffers before sending the binary data. In other words:<BR>      1. receive data using a non-B/F input form<BR>      2. flush the input buffer<BR>      3. switch to a B/F input form<BR>      4. tell the sender you're ready to receive more data<BR>      5. receive data<BR>   </DL><P><A NAME="How_to_Debug_Communication_Endpoint_Code"></A></P><H3><HR>How to Debug Communication Endpoint Code (3/21/97)</H3><DL>   <DD>Q: Is there any way I can use the NTK Inspector while running   communications code? How do I debug my endpoint code?<BR>      <BR>      A: If you are using a serial or MNP serial endpoint, you can use a   serial PC Card to do your comms, freeing the standard serial port   for the NTK Inspector. If you are using a serial or MNP serial   endpoint, you must also modify your endpoint's instantiate options   to use a PCMCIA slot instead of the built-in serial port. Here is   the option you should add directly after the endpoint service   option:      <PRE><CODE>{    type:          'option,    label:          kCMOSerialHWChipLoc,    opCode:         opSetRequired,    form:           'template,    result:         nil,    data:           {        argList:  [kHWLocPCMCIASlot1, 0],       // or kHWLocPCMCIASlot2        typeList: ['struct, ['array, 'char, 4], 'uLong]      }</CODE></PRE>      <P><CODE><BR>      }</CODE><BR>      <BR>      If you are using Newton Internet Enabler (NIE) endpoints, you can   use a PC Card Modem instead of a serial PC Card, but you do not   have to add any special endpoint options. NIE will handle this   automatically, provided you correctly set up your modem in the   Modem preferences in the Prefs application.<BR>      <BR>      This should allow your endpoint code to use the PC Card (serial   card or modem card) instead of the built-in serial port. Connect   the NTK Inspector to the built-in serial port as you normally   would. If you are using an AppleTalk endpoint, you can   simultaneously use the NTK inspector connected via AppleTalk.</P></DL><P><A NAME="XOn/XOff_Software_Flow_Control_Options"></A></P><H3><HR>XOn/XOff Software Flow Control Options (4/3/97)</H3><DL>   <DD>Q: XOn/XOff software flow control isn't working. What could I   be doing wrong?<BR>      <BR>      A: A quirk in the way Unicode characters are packed into   <CODE>'char</CODE> fields in the endpoint option is preventing the   correct flow control characters from being set in the serial   driver. The solution is to use the <CODE>'byte</CODE> symbol   rather than the <CODE>'char</CODE> symbol for these fields, thus   avoiding the Unicode-to-ASCII conversion that would normally take   place. The Newton Programmer's Guide is incorrect; the correct   option frames are as follows:<BR>      <BR>            <PRE><CODE>{ label:    kCMOInputFlowControlParms,  type:     'option,  opCode:   opSetRequired,  result:   nil,  form:     'template,  data: {    arglist:  [      unicodeDC1,           // xonChar        unicodeDC3,           // xoffChar       true,                 // useSoftFlowControl       nil,                  // useHardFlowControl       0,                    // not needed; returned       0,  ],                // not needed; returned     typelist: ['struct,      'byte,                // XON character      'byte,                // XOFF character      'boolean,             // software flow control      'boolean,             // hardware flow control      'boolean,             // hardware flow blocked      'boolean, ],  },  },  // software flow blocked&nbsp;{ label:    kCMOOutputFlowControlParms,  type:     'option,  opCode:   opSetRequired,  result:   nil,  form:     'template,  data: {    arglist:  [      unicodeDC1,           // xonChar        unicodeDC3,           // xoffChar       true,                 // useSoftFlowControl       nil,                  // useHardFlowControl       0,                    // not needed; returned       0,  ],                // not needed; returned     typelist: ['struct,      'byte,                // XON character      'byte,                // XOFF character      'boolean,             // software flow control      'boolean,             // hardware flow control      'boolean,             // hardware flow blocked      'boolean, ],  },  },  // software flow blocked</CODE>&nbsp;</PRE></DL><P><A NAME="Sharp_IR_Protocol"></A></P><H3><HR>Sharp IR Protocol (4/9/97)</H3><DL>   <DD><BR>      <B>1 Serial Chip Settings<BR>      </B>      <PRE><CODE>    Baud rate    9600    Data bits    8    Stop bits    1    Parity       Odd</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <B>2 Hardware Restrictions<BR>      </B>The IR hardware used in the Sharp Wizard series (as well as   Newtons and other devices) requires a brief stablizing period when   switching from transmitting mode to receiving mode. Specifically,   it is not possible to receive data for two milliseconds after   transmitting. Therefore, all devices should wait three   milliseconds after completion of a receive before   transmitting.<BR>      <BR>      <B>3 Packet Structure<BR>      </B>There are two kinds of Packets: "Packet I" and "Packet II".   Because the IR unit is unstable at the start of a data   transmission, <CODE>DUMMY (5 bytes of null code (0x00))</CODE> and   <CODE>START ID (0x96)</CODE> begin both packet types. At least two   null bytes must be processed by the receiver as <CODE>DUMMY</CODE>   before the <CODE>START ID</CODE> of a packet is considered. After   this <CODE>(DUMMY, START ID)</CODE> sequence the <CODE>PACKET   ID</CODE> is transmitted. Code <CODE>0x82</CODE> is the packet ID   for a PACKET I transmission, and code <CODE>0x81</CODE> is the   packet ID for a PACKET II transmission.<BR>      <BR>      <B>3.1 Packet I<BR>      </B>This packet type is used to transmit the following control   messages:<BR>      <BR>      3.1.1 Request to send <CODE>ENQ (0x05)</CODE><BR>      3.1.2 Clear to send <CODE>SYN (0x16)</CODE><BR>      3.1.3 Completion of receiving data <CODE>ACK (0x06)</CODE><BR>      3.1.4 Failed to receive data <CODE>NAK (0x15)</CODE><BR>      3.1.5 Interruption of receiving data <CODE>CAN (0x18)</CODE><BR>      <BR>      The format of this packet type is as follows:<BR>      <BR>      </P>      <PRE><CODE>             Byte length    Set value in transmission    Detection method in reception    DUMMY        5              0x00 * 5                     Only 2 bytes are detected when received.    START ID     1              0x96PACKET ID    1              0x82DATA         1              above mentioned data</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Packet I example:<BR>      <BR>      </P>      <PRE><CODE>DUMMY                     START ID    PACKET ID    DATA    0x00, 0x00, 0x00, 0x00    0x96        0x82         0x05    </CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      <B>3.2 Packet II<BR>      </B>This packet type is used to transmit data. The maximum amount   of data that may be transmitted in one packet is 512 bytes. If   more than 512 bytes are to be transmitted, they are sent as   several consecutive 512-byte packets. The last packet need not be   padded if it is less than 512 bytes and is distinguished by a   <CODE>BLOCK NO</CODE> value of <CODE>0xFFFF</CODE>.<BR>      <BR>      The format of this packet type is as follows:<BR>      <BR>      </P>      <PRE><CODE>             Byte length    Set value in transmission    Detection method in receptionDUMMY        5              0x00 * 5                     Only 2 bytes are detected.START ID     1              0x96PACKET ID    1              0x81VERSION      1              0x10                         Judge only bits 7-4BLOCK NO     2 (L/H)        0x0001 ~ 0xFFFFCTRL CODE    1              0x01                         Don't judgeDEV CODE     1              0x40                         Don't judgeID CODE      1              0xFE                         Don't judgeDLENGTH      2 (L/H)        0x0001 ~ 0x0200DATA         1 ~ 512CHKSUM       2 (L/H)</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <CODE>BLOCK NO</CODE> in last block must be set to   <CODE>0xFFFF</CODE>.<BR>      <BR>      <CODE>CHKSUM</CODE> is the two-byte sum of all of the data bytes   of <CODE>DATA</CODE> where any overflow or carry is discarded   immediately.<BR>      <BR>      Send all two-byte integers lower byte first and upper byte   second.<BR>      <BR>      Packet II example:<BR>      <BR>      </P>      <PRE><CODE>DUMMY                      START ID    PACKET ID    VERSION    BLOCK    NO      CTRL CODE0x00, 0x00, 0x00, 0x00     0x96        0x81         0x10       Low      High    0x01</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      </P>      <PRE><CODE>DEV CODE    ID CODE    DLENGTH            data    CHECKSUM0x40        0xFE       Low        High    ????    Low         High</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      <B>4 Protocol<BR>      </B>Data will be divided into several blocks of up to 512 bytes   each. These blocks are transmitted using type I and II packets as   follows:<BR>      <BR>      <B>4.1 Transmission Protocol<BR>      </B><BR>      4.1.1 The initiating device (A) begins a session by sending an   <CODE>ENQ</CODE> (type I) packet. The receiving device (B) will   acknowledge the <CODE>ENQ</CODE> by transmitting a   <CODE>SYN</CODE> packet.<BR>      <BR>      4.1.2 When (A) receives a <CODE>SYN</CODE> packet, it goes to step   4.1.4 below.<BR>      <BR>      4.1.3 When (A) receives a <CODE>CAN</CODE> packet, or when 6   minutes have elapsed without a <CODE>SYN</CODE> packet reply to an   <CODE>ENQ</CODE> packet, (A) terminates the session. If (A)   receives any other packet, no packet, or an incomplete packet, it   begins sending <CODE>ENQ</CODE> packets every 0.5 seconds.<BR>      <BR>      4.1.4 When (A) receives a <CODE>SYN</CODE> packet, it transmits a   single type II data packet, then awaits an <CODE>ACK</CODE> packet   from (B).<BR>      <BR>      4.1.5 When (A) receives an <CODE>ACK</CODE> packet, the   transmission is considered successful.<BR>      <BR>      4.1.6 If no <CODE>ACK</CODE> packet is received within 1 second   from completion of step 4.1.4, or if any other packet is received,   (A) goes to step 4.1.1 and transmits the data again.   Retransmission is attempted once. The session is terminated if the   second transmission is unsuccessful.<BR>      <B><BR>      4.2 Reception Protocol<BR>      </B><BR>      4.2.1 The receiving device (B) begins a session by waiting for an   <CODE>ENQ</CODE> (type I) packet. If no <CODE>ENQ</CODE> packet is   received after 6 minutes (B) terminates the session.<BR>      <BR>      4.2.2 When (B) receives an <CODE>ENQ</CODE> packet, (B) transmits   either a <CODE>SYN</CODE> packet to continue the session or a   <CODE>CAN</CODE> packet to terminate the session.<BR>      <BR>      4.2.3 When (B) receives a valid type II packet (for example, the   checksum and all header fields appear to be correct), (B)   transmits an <CODE>ACK</CODE> packet.<BR>      <BR>      4.2.4 If one or more header fields of the data packet are not   correct, or if the time between data bytes is more than 1 second,   (B) goes to step 4.2.1 and does not transmit the <CODE>ACK</CODE>   packet (this will cause (A) to retransmit the packet after a one   second delay).<BR>      <BR>      4.2.5 If the header fields of the data packet appear to be correct   but the checksum is incorrect, (B) transmits a <CODE>NAK</CODE>   packet (this will cause (A) to retransmit the packet   immediately).<BR>      <BR>      Because of the restriction in hardware mentioned in item 2 above,   it is not possible to receive data for two milliseconds after a   data transmission. Please wait three milliseconds before   transmitting a response to the other device.<BR>      <BR>      (see diagram)</P></DL><P><CENTER><IMG SRC="pictures/sharpir.gif" ALT="Q&amp;A Diagram"WIDTH=315 HEIGHT=418 X-SAS-UseImageWidth X-SAS-UseImageHeightBORDER=0 ALIGN=bottom></CENTER></P><P><A NAME="Using_Procrastinated_Actions_from_an_InputScript"></A></P><H3><HR><B>NEW: </B>Using Procrastinated Actions from an InputScript (7/2/97)</H3><DL>   <DD>Q: Calling <CODE>AddProcrastinatedCall</CODE> or   <CODE>AddProcrastinatedSend</CODE> repeatedly with the same symbol   from my input specification's <CODE>InputScript</CODE> method   sometimes causes an out of memory exception on pre-Newton 2.1   devices. What's going wrong?<BR>      <BR>      A: If you post a procrastinated action from an   <CODE>InputScript</CODE>, it may not be executed until a much   later time. Due to a bug in the way procrastinated actions with   the same symbol are queued, it's possible to queue so many events   that you run out of NewtonScript heap memory. This bug is fixed in   the Newton 2.1 OS.<BR>      <BR>      Here are two possible workarounds:<BR>      <BR>      1) Use <CODE>AddDelayedCall</CODE> or <CODE>AddDelayedSend</CODE>   in place of a procrastinated action.<BR>      <BR>      2) Buffer the incoming data (perhaps into a temporary soup). Once   the download has completed, perform the necessary operations on   this data. This method also provides transactional integrity in   the event the communications connection is unexpectedly torn down   while downloading.<BR>   </DL><P><A NAME="Using_the_EventHandler_Event_Time_Slot"></A></P><H3><HR><B>NEW: </B>Using the EventHandler Event Time Slot (7/2/97)</H3><DL>   <DD>Q: The Newton Programmer's Guide states that the   <CODE>'time</CODE> slot of the event frame passed to an endpoint's   <CODE>EventHandler</CODE> is in ticks. After some experimentation,   I've discovered that it is not in ticks. What is this time   value?<BR>      <BR>      A: The time value is actually the number of milliseconds since the   Newton device was last reset. The Newton Programmer's Guide   incorrectly states that it is the number of ticks since the unit   was last reset. Note that because the unit of time is   milliseconds, you can exceed NewtonScript's integer representation   fairly quickly.<BR>      <BR>      When you do run out of bits of precision for the millisecond   value, the number will wrap to the smallest representable integer   in NewtonScript. According to two's complement binary   representation, that number is <CODE>0x3FFFFFFF</CODE>, or   <CODE>-536870912</CODE> decimal. Therefore, the time value will   start counting at zero, count up to <CODE>536870911</CODE>, wrap   to <CODE>-536870912</CODE> then start to count back up to   <CODE>536870911</CODE>.</DL><H2>Errors</H2><P><A NAME="What_Is_a_Nasty_Practice"></A></P><H3><HR><B>NEW: </B>What Is a Nasty Practice (5/12/97)</H3><DL>   <DD>Q: I get the following message printed in the NTK Inspector:   "Nasty Practice #4720". What is a Nasty Practice, and where are   they defined?<BR>      <BR>      A: A Nasty Practice is a warning that you have attempted an   operation that is unwise, unnecessary, ambiguous, invalid, or just   a bad idea. Nasty Practice's have been renamed in the Newton   Programmer's Reference (NPR) to View Warning Messages. Table 2-7   of the NPR describes each of the view warning messages in detail.</DL><H2>Hardware &amp; OS</H2><P><A NAME="IR_Port_Hardware_Specs"></A></P><H3><HR>IR Port Hardware Specs (6/15/94)</H3><DL>   <DD>Q: What are the hardware specifications for the Newton IR   port?<BR>      <BR>      A: In the Apple MessagePad 100, 110, and 120, the Sharp ExpertPad,   and the Motorola Marco, the IR transmitter/receiver is a Sharp   Infrared Data Communication Unit model RY5BD11 connected to   channel B of a Zilog 85C30 SCC. Data is communicated along a 500   KHz carrier frequency at 9600 or 19200 baud, 8 data bits, 1 stop   bit, odd parity. The IR hardware requires a minimum of 5   milliseconds settling time when transitioning between sending and   receiving. Sharp's CE-IR2 wireless interface unit may be used to   connect the Newton to MacOS or DOS machines, with the appropriate   software.<BR>      <BR>      The Newton supports four IR software data modes:<BR>      Sharp encoding, NewtIR protocol (specifications are NOT   releaseable)<BR>      Sharp encoding, SharpIR protocol<BR>      Plain Serial<BR>      38 KHz encoding ("TV Remote Control")</DL><P><A NAME="Serial_Cable_Specs"></A></P><H3><HR>Serial Cable Specs (8/9/94)</H3><DL>   <DD>Q: I want to make my own serial cable. Which wires and which   connector pins do I use?<BR>      <BR>      A: To create a hardware flow control capable cable for   Mac-to-Newton or Newton-to-Newton communications (also called a   "null-modem" cable) all you need are two mini-din-8 connectors and   seven wires connected as follows:<BR>      <BR>            <PRE><CODE>Ground (4) -&gt; Ground (4)  (also connect to connectors' shrouds)Transmit+ (6) -&gt; Receive+ (8)Transmit- (3) -&gt; Receive- (5)Receive+ (8) -&gt; Transmit+ (6)Receive- (5) -&gt; Transmit- (3)Data Term Ready (1) -&gt; Clear To Send (2)Clear To Send (2) -&gt; Data Term Ready (1)</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      You should use twisted pairs for 6/3, 8/5, and 1/2, to improve   signal quality and reduce attenuation, especially in long cables.   You can use side-by-side pairs, as in telephone hookup cable, for   short cable runs.<BR>      <BR>      Remember that because RS-422 uses a differential signal for   transmit and receive, you always need two transmit and two receive   pairs, and a break of either wire will cause communications in   that direction to fail. The advantage, however, is significantly   longer and more reliable cable runs than RS-232.<BR>      <BR>      If you don't use hardware flow control, you can eliminate the 1/2   pair, but that's not recommended unless you know this cable will   be used only in software flow control situations.<BR>      <BR>      Q: What's the pin mapping on the Newton-to-PC (DIN-to-DB9)   cable?<BR>      <BR>      A: Here it is:<BR>      <BR>      Note that the pin numbers shown are as defined above.<BR>      <BR>      </P>      <PRE><CODE>PC (DB9)    Newton (DIN)    ========================1           1    2           3    3           5    4           7,2    5           4,8    6           1    7           N/C    8           N/C    9           N/C    &nbsp;N/C=not connected.</CODE>&nbsp;</PRE></DL><P><A NAME="IR_Hardware_Info"></A></P><H3><HR>IR Hardware Info (9/6/94)</H3><DL>   <DD>Q: How does the Newton send "Remote Control" codes?<BR>      <BR>      A: This information is hardware dependent, and is only valid for   the Original Message Pad, Message Pad 100, and Message Pad 110   products.<BR>      <BR>      The IR transmitter/reciever is a Sharp IR Data Communication Unit   connected to the second channel of a built-in SCC. When in "Remote   Control" mode, the SCC is not used. Instead, a carrier frequency   of 38KHz is transmitted, and the CPU toggles a register to   generate the data pattern.<BR>   </DL><P><A NAME="How_Much_Power_Can_a_PCMCIA_Card_Draw"></A></P><H3><HR>How Much Power Can a PCMCIA Card Draw (3/31/95)</H3><DL>   <DD>Q: How much power can I draw through the PCMCIA slot?<BR>      <BR>      A: The current rating depends on which Newton you are using and   the type of batteries in use. Alkaline batteries provide less   current than NiCad due to higher internal resistance. There is   also a 'semi' artifical limit in the ROM. Currently any card who's   CIS indicates more than 200 mA current draw will be rejected by   the CardHandler. Other than that, here's the run down by   hardware:<BR>      <BR>            <PRE><CODE>    Apple MessagePad 100:      50 mA    Apple MessagePad 110:    ~160 mA    Apple MessagePad 120:    ~300 mA    Apple MessagePad 130:    ~300 mA (with backlight off)    Apple MessagePad 130:    (with backlight on, the maximum has not been characterized)</CODE>&nbsp;</PRE></DL><P><A NAME="Do-it-Yourself_Package_Installation"></A></P><H3><HR>Do-it-Yourself Package Installation (8/26/96)</H3><DL>   <DD>Q: I want to have a newer version of my package downloaded   over an endpoint, and replace the older version. How do I do   this?<BR>      <BR>      A: There are a few steps, but they're fairly straightforward.<BR>      <BR>      First, you need to remove the old package if the new version has   the same unique name. (See code below which you can use if you   don't know whether the new package has the same name or not.) Then   call <CODE>SafeRemovePackage()</CODE>.<BR>      <BR>      Second, you need to get the new package to the Newton device. Use   the endpoint method <CODE>SuckPackageFromEndpoint()</CODE>, or the   store method <CODE>SuckPackageFromBinary()</CODE> depending on   where the package is coming from.<BR>      <BR>      In some cases, you don't want to remove the old package until   you're sure the new one works. If you're in this situation, the   new package will have to have a different unique name. Just defer   the call to <CODE>SafeRemovePackage</CODE> until after you verify   (most likely with a deferred call) that the   <CODE>SuckPackageFromEndpoint</CODE> or   <CODE>SuckPackageFromBinary</CODE> has succeeded.<BR>      <BR>      Also note that you can't call <CODE>SafeRemovePackage</CODE> from   a function that's in the target package. You'll need to create a   small function which does nothing but remove the old package, and   then TotalClone that small function before executing it via a   deferred call. Otherwise you'd be chopping your package's legs out   from under itself, causing no end of havoc!<BR>      <BR>      In some cases, it is appropriate to have a "loader" package which   has a small amount of code to check whether or not to install the   real package. This is accomplished by writing a small auto part   which has the "Auto Remove Package" flag turned on, and the real   package in a binary object within itself. This auto part   <CODE>installscript</CODE> performs whatever checks are necessary,   and then conditionally calls <CODE>SuckPackageFromBinary</CODE>,   providing the binary object which holds the real package.<BR>      <BR>      To create a binary object from a package, you need to move the   data from the <CODE>.pkg</CODE> file that NTK produces into an   object in the NewtonScript environment in NTK. On Windows NTK,   <CODE>LoadDataFile</CODE> does this. On Macintosh NTK, the easiest   thing to do is use a utility such as Clipboard Magician to copy   the data from the .<CODE>pkg</CODE> file into a resource, then use   <CODE>GetNamedResource</CODE> to get the data in your installer   package. <CODE>GetNamedResource</CODE> and   <CODE>LoadDataFile</CODE> are documented in the Newton Toolkit   User's Guide. The MonacoTest sample code is a working example of a   package installer that uses this technique.<BR>      <BR>      To get the unique name for a package inside a binary object, you   can use the following NewtonScript code. It takes the package   object as its argument, and will return the string holding the   unique name.<BR>      <BR>            <PRE><CODE>func(pkgRef)begin  local thelen:=extractword(pkgRef,26) div 2 -1;  local s:="             ";&nbsp;  while strlen(s)&lt;thelen do     s:=s&amp;s;  s:=substr(s,0,thelen);&nbsp;  BinaryMunger(s, 0, thelen*2, pkgRef,       52+(extractlong(pkgRef,48)*32)+extractword(pkgRef,24), thelen*2);  s;end</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      </P></DL><P><A NAME="Serial_Port_Hardware_Specs"></A></P><H3><HR>Serial Port Hardware Specs (4/9/97)</H3><DL>   <DD>Q: What are the hardware specifications for the serial   port?<BR>      <BR>      A: In the Apple MessagePad 100, 110, 120, 130, 2000, the eMate   300, the Sharp ExpertPad, and the Motorola Marco, the serial port   is an EIA standard RS-422 port with the following pinout (as   viewed looking at the female Mini-DIN-8 socket on the side of the   Newton device, or looking at the female Mini-DIN-9 on the Newton   Serial Adapter):<BR>      <BR>      &lt;see diagram&gt;<BR>      <BR>            <PRE><CODE>Pin 1    HSKo                /DTRPin 2    HSKi                /CTSPin 3    TxD-                /TDPin 4    GND                Signal ground connected to both logic and chassis ground.Pin 5    RxD-                /RD Pin 6    TxD+                (see below)Pin 7    GPi                General purpose input received at SCC's DCD pin.Pin 8    RxD+                (see below)Pin 9 Power out          5V@100ma.  This pin only exists on the eMate 300 and the Newton Serial Adapter.</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      All inputs are:<BR>      Ri 12K ohms<BR>      minimum Vih 0.2v, Vil -0.2V<BR>      maximum tolerance Vih 15V, Vil -15V<BR>      <BR>      All outputs are:<BR>      Rl 450 ohms<BR>      minimum Voh 3.6V, Vol -3.6V<BR>      maximum Voh 5.5V, Vol -5.5V<BR>      <BR>      No more than 40mA total can be drawn from all pins on the serial   port. Pins 3 &amp; 6 tri-state when SCC's /RTS is not   asserted.<BR>      <BR>      The EIA RS-422 standard modulates its data signal against an   inverted (negative) copy of the same signal on another wire   (twisted pairs 3/6 &amp; 5/8 above). This differential signal is   compatable with older RS-232 standards by converting to EIA   standard RS-423, which involves grounding the positive side of the   RS-422 receiver, and leaving the positive side of the RS-422   transmitter unconnected. Doing so, however, limits the usable   cable distance to approximately 50 feet, and is somewhat less   reliable.<BR>      <BR>      The MessagePad 120 and the MessagePad 130 use a Linear Technology   LTC902 serial line driver. This part drives +5/-5 nominally for   the RS422 signals, and you can use just one half to interconnect   with RS232 compatible signal levels.<BR>      <BR>      The MessagePad 2000 and the eMate 300 use a Linear Technology   LTC1323 serial line driver. This part drives +5/-5 nominally for   the RS422 signals, and you can use just one half to interconnect   with RS232 compatible signal levels.</P></DL><P><CENTER><IMG SRC="pictures/serlport.gif" ALT="Q&amp;A Diagram"X-SAS-UseImageWidth X-SAS-UseImageHeight BORDER=0 ALIGN=bottom></CENTER></P><P><A NAME="Programmatically_Aligning_the_Pen"></A></P><H3><HR><B>NEW: </B>Programmatically Aligning the Pen (7/2/97)</H3><DL>   <DD>Q: How do I programmatically open the view to align the   pen?<BR>      <BR>      A: You can call the global function <CODE>CalibrateTablet</CODE>   to open the "Align Pen" view. <CODE>CalibrateTablet</CODE> takes   no arguments, and does not return until the user has finished the   calibration.<BR>      <BR>      Note that <CODE>CalibrateTablet</CODE> automatically saves the new   calibration information for you.</DL><H2>Localization</H2><P><A NAME="StringToDateFrame_&_StringToTime_Don't_Use_Seconds"></A></P><H3><HR>StringToDateFrame &amp; StringToTime Don't Use Seconds (5/9/96)</H3><DL>   <DD>Q: When passed a string with seconds, for example "12:23:34",   <CODE>StringToDateFrame </CODE>and <CODE>StringToTime</CODE> don't   seem to work. <CODE>StringToDateFrame </CODE>returns a frame with   NIL for all the time &amp; day slots, and <CODE>StringToTime   </CODE>returns NIL.<BR>      <BR>      A: To correctly handle strings with seconds, seconds must be   stripped from the string. If the application might be used outside   the US, check for the Locale time delimiter. Here is a function   which prepares a string for <CODE>StringToDateFrame </CODE>and   <CODE>StringToTime</CODE>:<BR>            <PRE><CODE>    PrepareStringForDateTime := func (str)    begin   // str is just a time string, nothing else belongs         local newStr := clone (str);        local tf:= GetLocale().timeFormat;        local startMin := StrPos (str, tf.timeSepStr1, 0);        local startSec := StrPos (str, tf.timeSepStr2, startMin+1);        // If a time seperator for seconds, then strip out seconds        if startSec then        </CODE></PRE>      <P><CODE><BR>      </CODE></P>      <PRE><CODE>            begin                local skipSecSep := startSec + StrLen (tf.timeSepStr2);                local remainderStr := SubStr (                    str, skipSecSep, StrLen (str) - skipSecSep);                local appendStr := StringFilter (                    remainderStr, "1234567890", 'rejectBeginning);                newStr := SubStr (str, 0, startSec) &amp; appendStr;        end;        return newStr;    end;</CODE></PRE></DL><P><A NAME="How_GetDateStringSpec_Uses_Its_Element_Array"></A></P><H3><HR>How GetDateStringSpec Uses Its Element Array (3/31/97)</H3><DL>   <DD>Q: It appears that the compile-time function   <CODE>GetDateStringSpec</CODE> formats the supplied date elements   in reverse order. Is this is a bug?<BR>      <BR>      A: This is the defined behavior. The Newton Programmer's Guide   implies that the order does not matter, but that is not correct.   <CODE>GetDateStringSpec</CODE> uses the elements in reverse order,   although some functions that use dateStringSpecs may not observe   the order defined by the dateStringSpec. For instance, some   functions may use the elements of the dateStringSpec, but use the   element ordering defined by the locale bundle.<BR>      <BR>      For instance, you can use this call to define a dateStringSpec for   use in a locale bundle with the order Day/Month/Year:<BR>            <PRE><CODE>        GetDateStringSpec([[kElementYear, kFormatNumeric],[kElementMonth,        kFormatNumeric],[kElementDay, kFormatNumeric] ]); </CODE></PRE></DL><H2>Miscellaneous</H2><P><A NAME="Unicode_Character_Information"></A></P><H3><HR>Unicode Character Information (9/15/93)</H3><DL>   <DD>Q: Where can I find more about Unicode tables?<BR>      <BR>      A: The following book provides a full listing of the world wide   (non-Kanji) Unicode characters:<BR>      <BR>      <I>The Unicode Standard<BR>      WorldWide Character Encoding<BR>      Version 1.0 Volume 1<BR>      ISBN-0-201-56788-1</I></DL><P><A NAME="Using_the_Icon_Editor_in_NTK_1_6_4"></A></P><H3><HR>Using the Icon Editor in NTK 1.6.4 (4/18/97)</H3><DL>   <DD>Q: In the icon editor in the Project Settings slip in NTK   1.6.4 for MacOS, I don't always see all the images. Once I choose   an image in any depth, the list is much shorter for the other   depths, and I can't find the image I need! What's wrong?<BR>      <BR>      A: All of the images in a multiple-depth icon must be exactly the   same size. To help ensure that this is the case, once any image is   selected in any depth, NTK limits the available choices in the   other depths to images that are exactly the same size. Images from   any resource files that match in size will be shown, and images of   different sizes will not appear. You must edit your images "by   hand" to ensure that all the images you want for your icon family   are exactly the same size, padding smaller images with white   pixels as necessary.</DL><P><A NAME="Current_Versions_of_MessagePad_Devices"></A></P><H3><HR><B>CHANGED: </B>Current Versions of MessagePad Devices (7/22/97)</H3><DL>   <DD>Q: What are the versions of the MessagePad device?<BR>      <BR>      A: This answer will change as product versions are released. To   find the version number, open the Extras Drawer. In the Newton 1.x   OS, open the Prefs application and look at the number in the   bottom middle of the screen. In the Newton 2.x OS, choose Memory   Info from the Info button.<BR>      <BR>      As of 7/22/97 the latest MessagePad versions are:<BR>      <BR>      English Newton 2.1 OS<BR>      MessagePad 2000 2.1 (717145)<BR>      <BR>      English Newton 2.0 OS<BR>      MessagePad 120 2.0 (516205)<BR>      MessagePad 130 2.0 (526205)<BR>      <BR>      German Newton 2.0 OS<BR>      MessagePad 120 D-2.0 (536030)<BR>      <BR>      English Newton 1.x OS<BR>      MessagePad 1.05<BR>      MessagePad 1.11<BR>      MessagePad 100 1.3 (415333)<BR>      MessagePad 110 1.3 (345333)<BR>      MessagePad 120 1.3 (465333)<BR>      <BR>      German Newton 1.x<BR>      MessagePad D 1.11<BR>      MessagePad 100 D 1.3 (435334)<BR>      MessagePad 120 D 1.3 (435334)<BR>      <BR>      French Newton 1.x<BR>      MessagePad 100 F 1.3 (424112)<BR>      MessagePad 110 F 1.3 (424112)<BR>      MessagePad 120 F 1.3 (455334)</DL><H2>NewtApp</H2><P><A NAME="Creating_Preferences_in_a_NewtApp-based_Application"></A></P><H3><HR>Creating Preferences in a NewtApp-based Application (1/31/96)</H3><DL>   <DD>Q: How do I create and use my own preferences slip in a   NewtApp-based application?<BR>      <BR>      A: In your application's base view create a slot called   <CODE>prefsView</CODE> and place a reference to the template for   your preferences slip there (probably using the NTK   <CODE>GetLayout</CODE> function.) When the user selects "Prefs"   from the Info button in your application, the NewtApp framework   will create and open a view based on the template in the   <CODE>prefsView</CODE> slot.<BR>      <BR>      When your preferences view opens, a reference to your   application's base view is stored in a slot called <CODE>theApp   </CODE>in the preferences view. Use this reference to call the   application's <CODE>GetAppPreferences</CODE> method. This method   will return a frame containing your application's preferences.   <CODE>GetAppPreferences</CODE> is a method provided by NewtApp and   should not be overidden.<BR>      <BR>      When adding slots to the preferences frame, you must either append   your developer signature to the name of the preference (for   example, <CODE>'|Pref1:SIG|</CODE>) or create a slot in the   preferences frame using your developer signature and save all   preferences in that frame. This will guarantee that you don't   overwrite slots used by the NewtApp framework.<BR>      <BR>      Here is an example of how to get the preferences frame and add   your data:<BR>            <PRE><CODE>        preferencesSlip.viewSetupFormScript := func()     begin        prefs := theApp:GetAppPreferences();        if NOT HasSlot(prefs, kAppSymbol) then            prefs.(kAppSymbol) := {myPref1: nil, myPref2: nil};    end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      To save the preferences, call the application's   <CODE>SaveAppState</CODE> method:<BR>      </P>      <PRE><CODE>    preferencesSlip.viewQuitScript := func()        theApp:SaveAppState(); // save prefs</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      NewtApp currently provides one built-in preference for where to   save new items. In the preferences frame there will be a slot   called <CODE>internalStore</CODE>. Setting this slot to <CODE>true   </CODE>will force the NewtApp framework to save all new items on   the internal store.</P></DL><P><A NAME="Creating_an_About_Slip_in_a_NewtApp-based_Application"></A></P><H3><HR>Creating an About Slip in a NewtApp-based Application (1/31/96)</H3><DL>   <DD>Q: How do I create my own About slip in a NewtApp-based   application?<BR>      <BR>      A: Depending on how much control you want, there are two ways to   do this. For the least amount of control, create a slot in your   application's base view called <CODE>aboutInfo</CODE>. Place a   frame in that slot with the following slots:<BR>      <BR>            <PRE><CODE>    {tagLine:  "",        // A tagline for your application version: "",        // The version number for the application copyright: "",    // Copyright information trademarks: "",    // Trademark information}</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The information found in this frame will be displayed by the   NewtApp framework when the user selects "About" from the Info   button's popup. See the picture below for an example of what the   user will see.<BR>      <BR>      Alternatively, you can create your own About view. If you do this,   create a slot in your application's base view called   <CODE>aboutView</CODE> containing a reference to a template for   your about view (probably using the NTK <CODE>GetLayout</CODE>   function.) A view will be created from that template and opened   when the user selects "About" from the Info button's popup.<BR>      </P></DL><P><CENTER><IMG SRC="pictures/abotslip.gif" ALT="Q&amp;A Diagram"WIDTH=310 HEIGHT=206 X-SAS-UseImageWidth X-SAS-UseImageHeightBORDER=0 ALIGN=bottom></CENTER></P><P><A NAME="NewtSoup_FillNewSoup_Uses_Only_Internal_Store"></A></P><H3><HR>NewtSoup FillNewSoup Uses Only Internal Store (2/5/96)</H3><DL>   <DD>Q: My <CODE>NewtSoup</CODE> continues to get the   <CODE>FillNewSoup</CODE> message, even when the soup already   exists. Am I doing something wrong?<BR>      <BR>      A: The NewtApp framework only checks for entries on the internal   store to determine if the <CODE>FillNewSoup </CODE>message needs   to be sent. Check the "Setting the UserVisible Name With NewtSoup"   Q&amp;A for more details and a description of how to work around   the problem.</DL><P><A NAME="Setting_the_User_Visible_Name_With_NewtSoup"></A></P><H3><HR>Setting the User Visible Name With NewtSoup (2/6/96)</H3><DL>   <DD>Q: How can I make the user visible name for my NewtApp's soup   be something besides the internal soup name, as I can do with   <CODE>RegUnionSoup</CODE>?<BR>      <BR>      A: There is a method of <CODE>newtSoup</CODE> called   <CODE>MakeSoup</CODE> which you can override. The   <CODE>MakeSoup</CODE> method is responsible for calling   <CODE>RegUnionSoup</CODE> (or otherwise making a soup) and then   calling the <CODE>FillNewSoup</CODE> method if the soup is   new/empty.<BR>      <BR>      <CODE>MakeSoup</CODE> is called normally as part of initializing   the <CODE>newtSoup</CODE> object. Here is a sample   <CODE>MakeSoup</CODE> method that will use a newly defined slot   (from the <CODE>newtSoup</CODE> based template) for the user   name.<BR>      <BR>      The current documentation doesn't tell you everything you need to   do to properly override the <CODE>MakeSoup</CODE> method. In   particular, <CODE>MakeSoup</CODE> is used by the   <CODE>newtSoup</CODE> implementation to initialize the object, so   it needs to set up other internal slots. It's vital that the   <CODE>'appSymbol</CODE> slot in the message context be set to the   passed argument, and that the <CODE>'theSoup</CODE> slot be set to   the soup or unionSoup that <CODE>MakeSoup</CODE> creates or gets.   (Recall that <CODE>RegUnionSoup</CODE> returns the union soup,   whether it previously existed or not.)<BR>      <BR>      The <CODE>GetSoupList</CODE> method of union soups used in this   code snippet returns an array with the member soups. It should be   considered documented and supported. A newly created union will   have no members, so <CODE>FillNewSoup</CODE> should be called.   This is an improvement over the default <CODE>MakeSoup</CODE>   method, which always calls <CODE>FillNewSoup</CODE> if the soup on   the internal store is empty.<BR>      <BR>      The user visible name is supplied via the newtSoup   <CODE>'userName</CODE> slot, which is looked up in the current   context. As with <CODE>soupName</CODE>, <CODE>soupDescr</CODE>,   etc, you should set a new <CODE>userName</CODE> slot in the frame   in the <CODE>allSoups</CODE> frame in the <CODE>newtApplication   </CODE>template.<BR>      <BR>            <PRE><CODE>    MakeSoup: func(appSymbol)        begin            self.appSymbol := appSymbol;    // just do it...            self.theSoup := RegUnionSoup(appSymbol, {                name: soupName,                userName: userName,                ownerApp: appSymbol,                userDescr: soupDescr,                indexes: soupIndices,            });            if Length(theSoup:GetSoupList()) = 0 then                :FillNewSoup();        end;</CODE>&nbsp;</PRE></DL><P><A NAME="How_to_Control_Sort_Order_in_NewtApp"></A></P><H3><HR>How to Control Sort Order in NewtApp (5/10/96)</H3><DL>   <DD>Q: While a NewtApp application is running, can I change the   order in which soup items appear?<BR>      <BR>      A: Yes, the key to changing the sort order is to modify the query   spec in the <CODE>allSoups</CODE> frame, and then cause the   application to refresh. The cursor that controls the sort order   for the layout is built from the <CODE>masterSoupSlot </CODE>slot.   Both the default and the overview layouts have a   <CODE>masterSoupSlot </CODE>which points back to the relevant   <CODE>allSoups </CODE>slot in the app base view.<BR>      <BR>      Here are the basic steps:<BR>      <BR>      1) Ensure <CODE>newtAppBase.allSoups </CODE>&amp;   <CODE>newtAppBase.allSoups.mySoup </CODE>are writeable. (Since the   frames reside in the package, they are in protected memory.)<BR>      2) Modify the query spec to the new sort order.<BR>      3) Now send <CODE>newtAppBase.allSoups.mySoup:SetupCursor()   </CODE>to create a new cursor using the new query spec.<BR>      4) Then do a <CODE>newtAppBase:RedoChildren()</CODE> to display   the items in the new sort order.<BR>      The code would look something like:<BR>            <PRE><CODE>      if IsReadOnly (newtAppBase.allSoups) then        newtAppBase.allSoups := {_proto: newtAppBase.allSoups};   if IsReadOnly (newtAppBase.allSoups.mySoup) then        newtAppBase.allSoups.mySoup :={            _proto: newtAppBase.allSoups.mySoup};        newtAppBase.allSoups.mySoup.soupQuery :=             {indexpath: newKey};            // new sort order!        newtAppBase.allSoups.mySoup:SetupCursor();        newtAppBase:RedoChildren();</CODE></PRE></DL><P><A NAME="How_to_Avoid_NewtApp_"please _insert _the _card " _errors></A></P><H3><HR>How to Avoid NewtApp "Please Insert the Card" Errors (5/10/96)</H3><DL>   <DD>Q: If a NewtApp-based application is on a PC card and the card   is removed, the user gets the following error message:<BR>      <BR>      "The package &lt;package name&gt; still needs the card you   removed. Please insert it now, or information on the card may be   damaged."<BR>      <BR>      How can I avoid this problem?<BR>      <BR>      A: While a card is unmounting, if an object on the card is still   referenced, then the user will get the above error message asking   them to reinsert the card. For more information about issues for   applications running from a PC card see the article "The Newton   Still Needs the Card You Removed"<BR>      <BR>      The <CODE>newtApplication </CODE>method <CODE>NewtInstallScript   </CODE>is normally called in the part's <CODE>InstallScript</CODE>   function. One thing the <CODE>NewtInstallScript </CODE>does is   register the viewDefs in the NewtApp base view   <CODE>allViewDefs</CODE> slot using the global function   <CODE>RegisterViewDef</CODE>.<BR>      <BR>      Currently, <CODE>RegisterViewDef </CODE>requires that the data   definition symbol be internal. If the symbol is on the card, then   when the <CODE>NewtRemoveScript </CODE>tries to unregister the   viewDef a reference to data on the card is encountered and the   above error message will be shown. This bug will be fixed in a   future ROM.<BR>      <BR>      To work around this bug for any 2.0 based ROM, add the following   code to your part's <CODE>InstallScript </CODE>before calling   <CODE>NewtInstallScript</CODE>:<BR>      <BR>            <PRE><CODE>    local mainLayout := partFrame.theForm;    if mainLayout.allViewDefs then        foreach dataDefSym,viewDefsFrame in mainLayout.allViewDefs do            foreach viewDef in viewDefsFrame do                RegisterViewDef (                     viewDef, EnsureInternal (dataDefSym) );    partFrame.removeFrame :=         mainLayout:NewtInstallScript(mainLayout);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Note that it is OK to call <CODE>RegisterViewDef   </CODE>more than once with the same view definition.   <CODE>RegisterViewDef </CODE>will do nothing (and return NIL) if   the template is already registered.</P></DL><P><A NAME="Customizing_Filters_with_Labelled_Input_Lines"></A></P><H3><HR>Customizing Filters with Labelled Input Lines (9/4/96)</H3><DL>   <DD>Q: I need to open a slot view on a slot that isn't a standard   data type (int, string, etc). How do I translate the data from the   soup format to and from a string?<BR>      <BR>      A: Here is some interim documentation on the filter objects that   <CODE>newtLabelInputLines</CODE> (and their variants) use to   accomplish their work.<BR>      <BR>      A filter is an object, specified in the <CODE>'flavor</CODE> slot   of the <CODE>newtLabelInputLine</CODE> set of protos, which acts   as a translator between the target data frame (or more typically a   slot in that frame) and the text field which is visible to the   user. For example, it's the filter for   <CODE>newtDateInputLines</CODE> which translates the   time-in-minutes value to a string for display, and translates the   string into a time-in-minutes for the target data.<BR>      <BR>      You can create your own custom filters by protoing to   <CODE>newtFilter</CODE> or one of the other specialized filters   described in Chapter 4 of the Newton Programmer's Guide.<BR>      <BR>      When a <CODE>newtLabelInputLine</CODE> is opened, a new filter   object is instantiated from the template found in the   <CODE>'flavor</CODE> slot for that input line. The instantiated   filter can then be found in the <CODE>filter</CODE> slot of the   view itself. The <CODE>_parent</CODE> slot of the instantiated   filter will be set to the input line itself, which allows methods   in the filter to get data from the current environment.<BR>      <BR>      Here are the slots which are of interest. The first four are   simply values that you specify which give you control over the   recognition settings of the <CODE>inputLine</CODE> part of the   field, and the rest are methods which you can override or call as   appropriate.<BR>      <BR>      Settings:<BR>      <CODE>recFlags</CODE><BR>      Works like entryFlags in <CODE>protoLableInputLine</CODE>. This   provides the <CODE>'viewFlags</CODE> settings for the   <CODE>inputLine</CODE> part of the proto -- the field the user   interacts with.<BR>      <BR>      <CODE>recTextFlags</CODE><BR>      Provides the <CODE>'textFlags</CODE> settings for the   <CODE>inputLine</CODE> part of the proto.<BR>      <BR>      <CODE>recConfig</CODE><BR>      Provides the <CODE>'recConfig</CODE> settings for the   <CODE>inputLine</CODE> part of the proto.<BR>      <BR>      <CODE>dictionaries</CODE><BR>      Like the <CODE>'dictionaries</CODE> slot used in recognition,   Provides custom dictionaries if <CODE>vCustomDictionaries</CODE>   is on in the <CODE>recFlags</CODE> slot.<BR>      <BR>      Methods:<BR>      <CODE>PathToText()</CODE><BR>      Called when the <CODE>inputLine</CODE> needs to be updated. The   function should read data out of the appropriate slot in the   <CODE>'target</CODE> data frame (usually specified in the   '<CODE>path</CODE> slot) and return a user-visible string form of   that data. For example, for numbers the function might look like   <CODE>func() NumberStr(target.(path))</CODE><BR>      <BR>      <CODE>TextToPath(str)</CODE><BR>      Called when the <CODE>inputLine</CODE> value changes. The result   will be written into the appropriate slot in the   <CODE>'target</CODE> data frame. The string argument is the one   the user has modified from the <CODE>inputLine</CODE> part of the   proto. For example, for numbers the function might look like   <CODE>func(str) if StrFilled(str) then   StringToNumber(str)</CODE><BR>      <BR>      <CODE>Picker()</CODE><BR>      An optional function. If present, this method is called when the   user taps on the label part of the item. It should create and   display an appropriate picker for the data type. For the   pre-defined filters, you may also wish to call this method to open   the picker. You should store a reference to the filter in the   picker view. Then if the user picks an item, send the filter   instance a <CODE>PickActionScript</CODE> message. If the picker is   cancelled, send a <CODE>PickCancelledScript</CODE> message.<BR>      <BR>      Note: If this method is defined, a pick separator line and the   text "Other..." will be added to the <CODE>labelCommands</CODE>   array.<BR>      <BR>      <CODE>PickActionScript( newValue )</CODE><BR>      An optional function. This method should be called when the user   selects something from the picker opened through the filter's   <CODE>Picker</CODE> method. If you override this method be sure to   call the inherited <CODE>PickActionScript</CODE> method.<BR>      <BR>      <CODE>PickCancelledScript()</CODE><BR>      An optional function. This method should be called when the user   cancels the picker opened through the filter's <CODE>Picker</CODE>   method. If you override this method be sure to call the inherited   <CODE>PickCancelledScript</CODE> method.<BR>      <BR>      <CODE>InitFilter()</CODE><BR>      Optional. This method is called when an <CODE>inputLine</CODE>   that uses this filter is first opened. This method can be used to   get data from the current environment (for example, the   <CODE>'path</CODE> slot of the <CODE>inputLine</CODE>) and adjust   other settings as appropriate.</DL><P><A NAME="Using_Custom_Help_Books_in_a_NewtApp-based_Application"></A></P><H3><HR>Using Custom Help Books in a NewtApp-based Application (12/2/96)</H3><DL>   <DD>Q: I have created a help book for my NewtApp-based   application. Can I make my application open the help book when the   user chooses "Help" from the info button?<BR>      <BR>      A: Yes, there is a <CODE>newtApplication</CODE> slot called   <CODE>helpManual</CODE>. You should store a reference to your help   book in this slot.<BR>      <BR>      There is also a slot called <CODE>viewHelpTopic</CODE> which you   can use to dynamically change the location the help book is opened   to. This slot should store the name of the topic to open to.<BR>      <BR>      See the DTS Sample Code project "Beyond Help" for an example of a   help book.</DL><P><A NAME="Creating_a_Large_newtEditView/newtROEditView"></A></P><H3><HR>Creating a Large newtEditView/newtROEditView (12/2/96)</H3><DL>   <DD>Q: When I use <CODE>newtEditView</CODE> or   <CODE>newtROEditView</CODE>, I cannot scroll through all the text   of a large note. After a few pages it stops scrolling. What is   going wrong?<BR>      <BR>      A: Both <CODE>newtEditView</CODE> and <CODE>newtROEditView</CODE>   have a default scroll height of 2,000 pixels. To work around this   limitation, you will need to add a slot called   <CODE>noteSize</CODE> to your <CODE>newt(RO)editView</CODE>. This   slot should hold an array of two elements. The first element is   the scroll width. If you do not want horizontal scrolling, the   scroll width should equal the view width. The second element is   the <CODE>scrollHeight</CODE>.<BR>      <BR>      Here is an example <CODE>noteSize</CODE> slot that you would use   to create a <CODE>newt(RO)EditView</CODE> with a scroll height of   20,000 pixels.<BR>      <BR>            <PRE><CODE>    {        _proto:        newtEditView,    noteSize:    [viewWidth, 20000],    ...</CODE></PRE>      <P><CODE><BR>      }</CODE><BR>      </P></DL><P><A NAME="How_to_Use_ForceNewEntry_with_NewtApp"></A></P><H3><HR>How to Use ForceNewEntry with NewtApp (12/2/96)</H3><DL>   <DD>Q: I have a <CODE>newtApp</CODE>-based application which does   not use stationery. If I set the <CODE>forceNewEntry</CODE> slot   to <CODE>nil</CODE> in my layout and open the application with a   <CODE>nil</CODE> target, I can still see the entry view. How can I   avoid this?<BR>      <BR>      A: You will need to check for the existence of a target frame. If   one does not exist then close the entry view.<BR>      <BR>      You will not have this problem if you use stationery because the   <CODE>newtApp</CODE> framework will not open the stationery if a   target does not exist.</DL><P><A NAME="How_to_Programmatically_Open_the_Header_Slip"></A></P><H3><HR>How to Programmatically Open the Header Slip (1/3/97)</H3><DL>   <DD>Q: I like the way the Newton Works application (for Newton 2.1   OS) automatically opens the header slip each time a new entry is   created. Can I make my newtApp-based application do this?<BR>      <BR>      A: Yes! The <CODE>newtEntry(Roll/Page)Header</CODE> proto has a   <CODE>PopIt</CODE> method which opens the header. You will need to   override the <CODE>StatScript</CODE> of your   <CODE>newtNewStationeryButton</CODE> and send the header a   <CODE>PopIt</CODE> message. Because <CODE>PopIt</CODE> is not   defined prior to Newton 2.1 OS, you will need to check for its   existence before calling it. Here is a code example:<BR>      <BR>            <PRE><CODE>    newtNewStationeryButton.    StatScript: func( theStat )        begin            // Keep a copy of the inherited return value for use below            local result := inherited:?StatScript( theStat );&nbsp;            // Pass self as a parameter for the closure.  This gives us a reference            // to the application so we can get the entry view.            AddDeferredCall( func( context )                                 begin                                    local entryView := context:GetTargetView();&nbsp;                                    // This code assumes that your header is declared to the entry                                    // view with the name theHeaderView                                    if entryView.theHeaderView.popIt then                                        entryView.theHeaderView:Popit( true );                                end,                             [self] );&nbsp;            result;        end;</CODE></PRE></DL><P><A NAME="Programmatically_Changing_the_Default_ViewDef"></A></P><H3><HR>Programmatically Changing the Default ViewDef (1/3/97)</H3><DL>   <DD>Q: I want to be able to programmatically change which viewDef   is shown when I tap the "New" button in my newtApp-based   application. How can I do this?<BR>      <BR>      A: By default, the viewDef which is shown when you create a new   entry is the one with the value <CODE>'default</CODE> in its   <CODE>symbol</CODE> slot. To change this behavior at run-time, you   will need to override the <CODE>StatScript</CODE> method of your   <CODE>newtNewStationeryButton</CODE>.<BR>      <BR>      In the <CODE>StatScript</CODE> method, you will set two slots in   your application. The first slot is the   <CODE>preferredViewDef</CODE> slot in your application's base   view. The second is the <CODE>viewDef</CODE> slot of the current   layout. Both of these slots should be set to the symbol of the   viewDef that you want displayed. For instance, you might have the   following <CODE>StatScript</CODE>:<BR>      <BR>            <PRE><CODE>StatScript := func( theStat )begin    preferredViewDef := 'myNewDefaultStationery;    layout.viewDef:= 'myNewDefaultStationery;        // Make sure we call the inherited method    inherited:?StatScript( theStat );</CODE></PRE>      <P><CODE><BR>      end;</CODE><BR>      <BR>      Note: you must not modify either the application's   <CODE>preferredViewDef</CODE> slot or the layout's   <CODE>viewDef</CODE> slot at any other time. Doing so could cause   your application to not work on future versions of the Newton OS.   </P></DL><P><A NAME="How_to_Properly_Declare_NewtApp_Views"></A></P><H3><HR>How to Properly Declare NewtApp Views (1/6/97)</H3><DL>   <DD>Q: I have a <CODE>newtEntryPageHeader</CODE> which is declared   to my <CODE>newtLayout</CODE> view. Each time I change entries in   my application, the header does not get properly updated. What's   going wrong?<BR>      <BR>      A: If you declare your <CODE>newtApplication</CODE> views, they   need to be declared to their parent. Declaring   <CODE>newtApplication</CODE> views to a grandparent can cause   undefined behavior.<BR>      <BR>      Because of how the declare mechanism works, you must be careful   when you declare a view to a grandparent view. In some   circumstances, you could try to access a view which has been   closed.<BR>      <BR>      As an example, pretend you have three views called viewA, viewB,   and viewC. They have the following heirarchy.:<BR>      <BR>      ViewA (grandparent)<BR>      ViewB (parent)<BR>      ViewC (child)<BR>      <BR>      ViewC is a child of viewB and viewB is a child of viewA; ViewC is   declared to viewA. If you close viewB, viewC will also be closed   because it is a child of viewB. Since ViewC was declared to ViewA,   ViewA will still have a reference to viewC which has been closed.   Sending view messages to viewC will throw.<BR>      <BR>      For more information on the Newton OS declare mechanism, see the   "Declaring Multiple Levels" Q&amp;A, and the "The Inside Story on   Declare" appendix in the Newton Programmer's Guide.</DL><P><A NAME="How_to_Create_Custom_Overviews_with_NewtApp"></A></P><H3><HR>How to Create Custom Overviews with NewtApp (1/8/97)</H3><DL>   <DD>Q: My NewtApp-based application can print successfully, but I   want a custom format that can print multiple items on one page or   handle different transports than the default overview supports.   How do I do this?<BR>      <BR>      A: Add an <CODE>overviewTargetClass</CODE> slot to your   application (or any other layout that is a descendent of your   <CODE>newtOverLayout</CODE>). Set this slot's value to be the   symbol that represents your data class (for example,   <CODE>'|myData:SIG|</CODE>), which must match the data class you   use when registering your print format. The NewtApp overview will   use <CODE>overviewTargetClass</CODE> instead of the default   overview class (<CODE>'newtOverview</CODE>) supplied by   <CODE>newtOverLayout</CODE>.<BR>      <BR>      You must still register your print format, but you must set its   <CODE>usesCursors</CODE> slot to <CODE>true</CODE> indicating that   it will use the value target as a multiple item target and it will   iterate over it using <CODE>GetTargetCursor(target)</CODE>. For an   example of a print format that can handle multiple items, see the   MultiRoute DTS sample.<BR>      <BR>      For more information about the default overview class   (<CODE>'newtOverview</CODE>) , see the Q&amp;A "Limitations with   NewtOverview Data Class".<BR>      <BR>   </DL><P><A NAME="How_to_Store_Prefs_in_a_NewtApp-based_Application"></A></P><H3><HR>How to Store Prefs in a NewtApp-based Application (1/17/97)</H3><DL>   <DD>Q: I want to save application-specific preferences and state   information before my application is closed. What is the best way   to do this?<BR>      <BR>      A: You can save application-specific information in the frame in   the <CODE>prefsCache</CODE> slot of your NewtApp-based   application. This slot is defined in your application's base view   by the NewtApp framework. This frame will be saved to the system   soup when the application closes.<BR>      <BR>      When you add to the <CODE>prefsCache</CODE> frame, you must use   your registered signature to avoid conflicting with slots that the   framework may use. You can name each of your preferences with your   signature, or we recommend adding a subframe in a slot named with   your signature. For instance, you might have the following   code:<BR>      <BR>      <CODE>prefsCache.('|MyPrefs:MySIG|) := {pref1: 1, pref2:   2};</CODE><BR>   </DL><P><A NAME="A_CheckAll_Button_for_NewtApp_Overviews"></A></P><H3><HR>A CheckAll Button for NewtApp Overviews (3/4/97)</H3><DL>   <DD>Q: What do I have to do to get the Check All button to appear   in my overview? What's the compatible way to do this so that the   application works on Newton 2.0 OS as well?<BR>      <BR>      A: In Newton 2.1 OS, there is a proto called   <CODE>newtCheckAllButton</CODE> (<CODE>@872</CODE>) which you can   use. This proto sends the <CODE>CheckAll</CODE> method to the   layout. In Newton 2.1 OS, <CODE>newtOverLayouts</CODE> have two   new methods, <CODE>CheckAll</CODE> and <CODE>UncheckAll,</CODE>   which implement this behavior. However, none of this is present in   Newton 2.0 OS .<BR>      <BR>      To create a check all button that works on the Newton 2.0 OS, you   will need to create the button yourself and implement the   <CODE>CheckAll</CODE> and <CODE>UncheckAll</CODE> methods for your   overview layout (or any other layout you wish to implement check   all for.)<BR>      <BR>      Older versions of the DTS sample code (either "Checkbook-7" or   "WhoOwesWhom-3") do have a <CODE>protoCheckAllButton</CODE>. These   samples implement an earlier (and less useful) flavor of Check   All. The old samples check all the items which are currently   visible in the overview, while the Newton 2.1 OS checks all the   items that are present in the currently selected folder/card   filter. "Checkbook" (version 8 or later) or "WhoOwesWhom" (version   3 or later) will reflect the Newton 2.1 behavior.<BR>      <BR>      Until the updated samples are available, start with the   <CODE>protoCheckAllButton</CODE> from the older sample code, since   that gives the correct look and button bounds, and modify it as   follows:<BR>      <BR>      The check all button's <CODE>buttonClickScript</CODE> should look   something like this:<BR>            <PRE><CODE>   func()        if newtAppBase.currentLayout = 'overView then            begin                if layout.checkAllPrimed then                    layout:UnCheckAll()                else                    layout:CheckAll();                layout.checkAllPrimed := NOT layout.checkAllPrimed;            end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The overview layout's CheckAll and UncheckAll methods should look   something like this:<BR>      <BR>      </P>      <PRE><CODE>    CheckAll:        func()            begin                local curse := dataCursor:Clone();                curse:Reset();                hilitedIndex := nil;                selected := MapCursor(curse, func(e) MakeEntryAlias(e));                AddUndoSend(layout, 'UnCheckAll, []);                layout:DoRetarget();            end;&nbsp;    UncheckAll:        func()            begin                hilitedIndex := nil;                selected := nil;                layout:DoRetarget();            end</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that these methods make use of two undocumented slots:   <CODE>hilitedIndex</CODE> and <CODE>selected</CODE>.   <CODE>hilitedIndex</CODE> is used internally by   <CODE>newtOverLayout</CODE> to track the tapped item. You may set   it to <CODE>NIL</CODE> (as above) to clear the value, but do not   set it to some other value or rely on its current value.   <CODE>selected</CODE> contains an array of aliases to soup entries   representing the currently selected items, and will be used by the   routing and filing buttons for processing entries. It is important   to clear <CODE>hilitedIndex</CODE> when modifying the   <CODE>selected</CODE> array in any way.<BR>      <BR>      The resulting CheckAll button should be included in the   <CODE>menuRightButtons</CODE> array for the status bar. The older   sample code puts it on the left, however user interface   discussions as part of the Newton 2.1 OS effort resulted in the   decision to place the button on the right.<BR>      </P></DL><P><A NAME="Creating_a_Simple_NewtApp"></A></P><H3><HR>Creating a Simple NewtApp (4/7/97)</H3><DL>   <DD>Q: What are the basic steps to create a simple NewtApp-based   application?<BR>      <BR>      A: The following steps will create a basic NewtApp-based   application:<BR>      <BR>      <B>Basic Setup</B><BR>      1) Create a project.<BR>      2) In NTK's Project Settings dialog, set Platform to "Newton 2.0"   or "Newton 2.1".<BR>      <BR>      <B>Create the NewtApp base view<BR>      </B>1) Create a layout file.<BR>      2) Drag out a <CODE>newtApplication</CODE>.<BR>      3) Set the following slots to the following values:<BR>            <PRE><CODE>        allLayouts:    {</CODE></PRE>      <P><CODE><BR>      default: GetLayout("default.t"), </CODE>// see step 9 in the next   section<CODE><BR>      overview: GetLayout("Overview.t"), </CODE>// set step 4, overview   section<CODE><BR>      }</CODE><BR>      </P>      <PRE><CODE>    allSoups:       {        mySoup: {            _proto: newtSoup,            soupName: "SoupName:SIG",            soupIndices: [],            soupQuery: {}  } }    title: kAppName</CODE></PRE>      <P><CODE><BR>      </CODE>4) Draw a <CODE>newtClockFolderTab </CODE>or   <CODE>newtFolderTab </CODE>as a child of the   <CODE>newtApp</CODE>.<BR>      5) Draw a <CODE>newtStatusBar </CODE>as a child of the   <CODE>newtApp</CODE>.<BR>      6) For the <CODE>newtStatusBar </CODE>set the following slots:<BR>      </P>      <PRE><CODE>    menuLeftButtons:  [newtInfoButton]    menuRightButtons: [newtActionButton, newtFilingButton]</CODE></PRE>      <P><CODE><BR>      </CODE>7) Save the layout file as <CODE>"main.t" </CODE>and add it   to the project.<BR>      <BR>      <B>Create the default view</B>:<BR>      1) Create another layout file.<BR>      2) Draw a <CODE>newtLayout </CODE>in the new layout file.<BR>      3) Add a <CODE>viewJustify </CODE>slot to the <CODE>newtLayout   </CODE>and set it to <CODE>parentRelativeFull </CODE>horizontal   and vertical.<BR>      4) Set the <CODE>viewBounds </CODE>of the <CODE>newtLayout   </CODE>to:<BR>      </P>      <PRE><CODE>        {top: 20, // leave room for the folder tab    bottom: -25,  // leave room for the status bar    left: 0,     right: 0}</CODE></PRE>      <P><CODE><BR>      </CODE>5) Draw a <CODE>newtEntryView </CODE>as a child of the   <CODE>newtLayout</CODE>.<BR>      6) Add a <CODE>viewJustify </CODE>slot and set it to   <CODE>parentRelativeFull </CODE>horizontal and vertical (necessary   only until platform file is updated).<BR>      7) Set the <CODE>viewBounds </CODE>of the newtEntryView to:<BR>      </P>      <PRE><CODE>        {top: 0, bottom: 0, right: 0, left: 0};</CODE></PRE>      <P><CODE><BR>      </CODE>8) Draw slot views as children of the entry view to display   slots from the soup entry.<BR>      For example:<BR>      a) Draw a <CODE>newtLabelInputLine </CODE>as a child of the   <CODE>newtEntryView</CODE>.<BR>      b) Set the following slots:<BR>      </P>      <PRE><CODE>        label:  "My Label"        path:   'myTextSlot</CODE></PRE>      <P><CODE><BR>      </CODE>c) Draw a <CODE>newtLabelNumInputLine </CODE>as a child of   the <CODE>newtEntryView</CODE>.<BR>      d) Set the following slots:<BR>      </P>      <PRE><CODE>        label:  "Number"        path:   'myNumberSlot&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>9) Save the layout file as <CODE>"default.t"</CODE> and add   it to the project. Move it so that it is compiled before the main   layout (use the Process Earlier menu item).<BR>      <BR>      <B>Add Overview support<BR>      </B>1) Create another layout file.<BR>      2) Draw a <CODE>newtOverLayout </CODE>in the new layout file.<BR>      3) Add the <CODE>Abstract </CODE>slot to the   <CODE>newtOverLayout</CODE>, for example:<BR>      </P>      <PRE><CODE>            Abstract := func(item, bbox )        begin            local t := item.myTextSlot &amp; ",";            if item.myNumberSlot then                t := t &amp;&amp; NumberStr(item.myNumberSlot);            MakeText(t, bbox.left+18, bbox.top,                bbox.right, bbox.bottom - 18);        end;</CODE></PRE>      <P><CODE><BR>      </CODE>4) Save the layout file as "overview.t" and add it to the   project. Move it so that it is compiled before the main layout   (use the Process Earlier menu item).<BR>      <BR>      <B>Add InstallScript and RemoveScript<BR>      </B>1) Create a text file and add the following to it:<BR>      </P>      <PRE><CODE>    InstallScript := func(partFrame) begin    partFrame.removeFrame :=        (partFrame.theForm):NewtInstallScript(partFrame.theForm);    end;&nbsp;    RemoveScript := func(partFrame) begin         (partFrame.removeFrame):      NewtRemoveScript(partFrame.removeFrame);    end;</CODE></PRE>      <P><CODE><BR>      </CODE>2) Save the text file and add it to the project.</P></DL><P><A NAME="Registering_Soup_Change_Notifications_in_NewtApp"></A></P><H3><HR><B>NEW: </B>Registering Soup Change Notifications in NewtApp(5/15/97)</H3><DL>   <DD>Q: I have an application based on the NewtApp framework. When   I register to receive soup change notifications, things start to   behave strangely. What's going wrong?<BR>      <BR>      A: This problem is caused because of a naming conflict. When your   application is opened, the NewtApp framework registers to receive   soup change notifications using your application's symbol as the   <CODE>callbackID</CODE> parameter to the   <CODE>RegSoupChange</CODE> global function. If you also use your   application's symbol as the <CODE>callbackID</CODE> parameter, you   will overwrite the NewtApp framework's registration. There are two   ways to work around this problem.<BR>      <BR>      1) Use a different <CODE>callbackID</CODE> symbol in your call to   <CODE>RegSoupChange</CODE>.<BR>      2) Use the NewtApp framework's registration callback method. When   your soup has changed, the NewtApplication's   <CODE>NewtSoupChangedNotify</CODE> method is called. It is passed   the same four parameters as the callback function parameter of   <CODE>RegSoupChange</CODE>.<BR>      <BR>      If you do override the <CODE>NewtSoupChangedNotify</CODE> method,   be sure to call the inherited method.<BR>      <BR>      Here is an example:<BR>      <BR>            <PRE><CODE>    application:NewtSoupChangedNotify(theName, appSym, changeType, changeData)begin    // Do your stuff here        inherited:?NewtSoupChangedNotify( theName, appSym, changeType, changeData );end;</CODE></PRE></DL><H2>Newton C++ Tools</H2><P><A NAME="Packed_Structures_in_C++_Tools"></A></P><H3><HR>Packed Structures in C++ Tools (2/28/97)</H3><DL>   <DD>Q: Do the Newton C++ Tools support a concept of packed   structures? Some compilers provide a keyword (<CODE>packed</CODE>)   to prevent aligning of the fields by the compiler. I tried to use   the keyword and got an error. How can I ensure that a structure is   packed?<BR>      <BR>      A: While there is no supported way to do this in the current   tools, the ARM compiler does have an experimental directive,   <CODE>__packed</CODE>, which is probably worth a try. Using this   directive may cause the compiler to stop with an internal error in   some circumstances, so be prepared. You should ensure that the   structure produced has the correct alignment by using the C   <CODE>sizeof</CODE> and <CODE>offsetof</CODE> functions, since   this directive does introduce a compiler dependency. Accessing   elements in <CODE>__packed</CODE> structures can be considerably   less efficient than using non-packed structures: use them only   when necessary. For example:<BR>            <PRE><CODE>    __packed struct T { char c; int i; };</CODE></PRE>      <P><CODE><BR>      </CODE>produces a structure that is 5 bytes wide. Without the   <CODE>__packed</CODE> directive, it would be 8 bytes wide and the   integer field would begin 4 bytes from the structure start, so   that it was word aligned.<BR>      <BR>      We believe the internal error in the compiler can be avoided by   taking the sizeof the structure before using it. An easy way to do   this is to add a dummy function right after the structure is   declared. For example:<BR>      <CODE>inline void dummyT() { (void)sizeof(T); }</CODE><BR>      <BR>      Primitive types can also be declared <CODE>__packed</CODE>, which   means that the compiler will not make assumptions about the   alignment of pointers to them. That is, if you know an int starts   two bytes into a word-aligned data structure, the wrong thing will   happen if you simply cast the pointer to <CODE>int</CODE>.   Instead, you can used an <CODE>unaligned int</CODE> type. This   generates considerably less efficient code than is needed for   working with aligned values, but it's still more efficient that   trying to extract the proper bytes and shift/add them into an   integer youself. For example:<BR>      </P>      <PRE><CODE>    typedef __packed int UNALIGNED_INT;    int IntAt(UNALIGNED_INT* p) { return *p; }</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      This directive does not work properly with bitfield specifiers.   For example:<BR>      </P>      <PRE><CODE>        __packed struct Foo {        unsigned flag1 : 1;        unsigned flag2 : 1;        unsigned data1 : 6;        unsigned short data2;</CODE></PRE>      <P><CODE><BR>      }</CODE><BR>      will not produce what you expect. Instead, avoid the bitfield   specifiers and take advantage of C++ inline functions to access   the partial bytes:<BR>      </P>      <PRE><CODE>        __packed struct Foo {        char stuff;        unsigned short data2;&nbsp;        int Flag1() { return (stuff &amp; 0x80) != 0; }        int Flag2() { return (stuff &amp; 0x40) != 0; }        int Data1() { return stuff &amp; 0x3F; }        int Data2() { return data2; }    };    inline void dummyFoo() { (void)sizeof(Foo); }</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The result is a 3-byte wide data structure with the bitfields   easily accessible.<BR>      <CODE><BR>      </CODE>Note that the ProtocolGen tool (part of the DDKs) does not   understand the <CODE>__packed</CODE> directive. ProtocolGen does   not make use of structure sizes, so it's OK to NOP out the   <CODE>__packed</CODE> keyword for that tool. Here's an easy way to   do that:<BR>      </P>      <PRE><CODE>    #ifdef PROTOCOLGEN    #define __packed</CODE></PRE>      <P><CODE><BR>      #endif</CODE><BR>      </P></DL><H2>Newton ToolKit</H2><P><A NAME="NTK,_Picture_Slots_and_ROM_PICTs"></A></P><H3><HR>NTK, Picture Slots and ROM PICTs (12/19/93)</H3><DL>   <DD>Q: How can I use a PICT in ROM from a picture slot editor in   NTK?<BR>      <BR>      A: You must use an NTK <CODE>AfterScript </CODE>to set the   appropriate slot in the view to point to the ROM based PICT   (assuming that the constant for the PICT is defined in the NTK   definitions file AND documented in the Newton Programmers Guide).   Use something like this in the <CODE>AfterScript</CODE>:<BR>            <PRE><CODE>thisView.icon := ROM_RouteDeleteIcon;</CODE></PRE></DL><P><A NAME="Recognition_Problems_with_the_Inspector_Window_Open"></A></P><H3><HR>Recognition Problems with the Inspector Window Open (3/8/94)</H3><DL>   <DD>Q: When I have the Inspector window open in NTK and I debug my   application, recognition does not work properly and the Newton   complains about lack of memory. However, when I disconnect the   Inspector, recognition works fine. What is going on?<BR>      <BR>      A: The NTK inspector window uses system memory on the Newton side;   the Toolkit App itself makes use of MNP (a compression and error   correction protocol) in the Newton, which uses a buffer shared   with the recognition working memory.<BR>      <BR>      Different releases of the Newton OS have different amounts of   memory allocated for this shared area, so the problem may not be   apparent on some units. However, if this happens you have several   options:<BR>      &#149;Disconnect the Inspector when testing the recognition   side.<BR>      &#149;Use the keyboard for text input while testing the code.<BR>      &#149;Write shorter text items.<BR>   </DL><P><A NAME="Accessing_Views_Between_Layout_Windows"></A></P><H3><HR>Accessing Views Between Layout Windows (6/7/94)</H3><DL>   <DD>Q: I have problems setting a <CODE>protoStaticText </CODE>text   slot that is in one linked layout window from a button that is in   another linked layout window. I tried to allow access to the base   view from both linked layouts, but this didn't help. I even tried   to allow access from the base view to both layouts, but this   didn't help, either. What should I do?<BR>      <BR>      A: There is no way to declare views across the artifical boundary   imposed by the linked layouts. Until this feature of NTK is   implemented, you must either create the link yourself at run time,   or declare the button to the top level of the linked layout, and   then declare the link.<BR>      <BR>      For example, consider a view called <CODE>textThatChanges</CODE>   which a child of a view called <CODE>changingContainer</CODE> and   is declared to <CODE>changingContainer</CODE> with the name   <CODE>textThatChanges</CODE>. <CODE>ChangingContainer</CODE> is   the base view for a layout which is linked into the main layout,   and the link (in the main layout) is declared as   <CODE>changingContainerLink</CODE>. Code in the main layout can   change the text of the <CODE>textThatChange</CODE> view like   so:<BR>            <PRE><CODE>    SetValue(containerLink.whatToDo, 'text, "Turn and face the...")&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      To do the equivalent of the declare yourself:<BR>      <BR>      1) In the <CODE>viewSetupFormScript </CODE>script of the   <CODE>'buttonThatChanges </CODE>button, set the value of the base   view's slot <CODE>'theTextView </CODE>to <CODE>self</CODE>, as in   the following code fragment:<BR>      </P>      <PRE><CODE>    func()    begin           base.theTextView := self;    end&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>2) In the <CODE>buttonClickScript </CODE>script of the   <CODE>'buttonThatSetsText </CODE>button, use the global function   <CODE>SetValue </CODE>to store new text in the text slot of the   <CODE>'buttonThatChanges </CODE>button, as in the following code   fragment:<BR>      <BR>      </P>      <PRE><CODE>    func()    begin       SetValue(base.theTextView, 'text, "Now something happened!");    end&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Note that this example assumes the self-declared view   called <CODE>base</CODE>. In your application, you may access your   base view in a different way.</P></DL><P><A NAME="Dangers_of_StrCompare,_StrEqual_at_Compile_Time"></A></P><H3><HR>Dangers of StrCompare, StrEqual at Compile Time (6/9/94)</H3><DL>   <DD>Q: I've noticed that <CODE>StrCompare </CODE>can return   different results at compile time than it does at run time. What   gives?<BR>      <BR>      A: While most functions documented in the NewtonScript Reference   are available at run time and at compile time (within the NTK   environment), some functions have different behaviors.<BR>      <BR>      In this case, the sort order for strings within the NTK   NewtonScript environment is different from the ordering used on   the Newton (and different from other commonly used desktop machine   sort orders.) The differences are only apparent if you use   characters outside the ASCII range, for instance, accented   characters.<BR>      <BR>      If it is necessary to pre-sort accented strings at compile time,   you can write your own function that will return the same results   as <CODE>StrCompare </CODE>on an given Newton unit. Here is one   such function for English releases of the Newton OS (which assumes   strings using only page 0 of the unicode table):<BR>      <BR>            <PRE><CODE>constant kNSortTable := '[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24, 25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46, 47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68, 69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90, 91,92,93,94,95,96,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80, 81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106, 107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122, 123,124,125,126,127,128,129,130,131,132,133,161,157,135,136,165, 149,138,137,143,141,152,159,158,144,140,170,134,146,147,148,142, 150,138,168,171,151,153,160,153,154,155,156,174,174,174,174,65, 65,145,67,175,69,175,175,176,176,176,176,162,78,177,177,177,79, 79,164,79,178,178,178,85,166,167,139,65,65,65,65,65,65,145,67,69, 69,69,69,73,73,73,73,169,78,79,79,79,79,79,163,79,85,85,85,85,172, 173,89];&nbsp;// function to compare strings (only page 0 characters)// with the same order as the Newton ROM does.DefConst('kNewtonStrCompare, func(s1, s2)    begin        local l1 := StrLen(s1);        local l2 := StrLen(s2);        local l := Min(l1, l2);        local i := 0;        while i &lt; l and            (r := kNSortTable[ord(s1[i])] - kNSortTable[ord(s2[i])]) = 0  do                i := i + 1;        if i = l then            l1-l2        else            r;    end); &nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Note that just because you might find a particular function   to be defined at compile time, do not assume that it behaves in   exactly the same way as the like-named run-time function, unless   the documentation explicitly says it does. (And, of course, it   might not always be defined in the compile-time environment of   future NTK products if it isn't documented that way.)</P></DL><P><A NAME="Profiler_and_Frames_of_Functions"></A></P><H3><HR>Profiler and Frames of Functions (7/10/95)</H3><DL>   <DD>Q: Using the profiler with a large frame of functions gives   confusing results. The profiler labels each function by the name   of the frame and a number, but the numbers don't seem to   correspond to the order in which I defined the functions. Moving   the functions around doesn't change the profiler labels. How can I   figure out which function is which?<BR>      <BR>      A: If frames have less than than a certain number of slots (20 in   the current release), the slots are kept in the order they were   defined or added. If there are more than 20 slots in the frame,   the slots are reordered. (This improves slot lookup operations.)   The profiler in NTK 1.5 and NTK 1.6labels the functions by their   position in the final, possibly reordered, frame.<BR>      <BR>      To determine which function is in which position, you need to look   at the frame after the reordering has occurred. You can do this by   printing the frame after it's been defined. At compile time you   can use a print statement in the slot editor or afterScript. After   the package has been downloaded you can use the inspector. Then   count (starting from one) through the slots to find your   function.<BR>      <BR>      Here's a little inspector snippet that will print the slots in a   frame in order with their numbers:<BR>            <PRE><CODE>    call func(theFrame) begin        local i := 0;        foreach slot, value in theFrame do begin            print(i &amp;&amp; ': &amp;&amp; slot);            i := i + 1;        end    end with (&lt;the reordered frame&gt;)</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      </P></DL><P><A NAME="NTK_1_6_Heap/Partition_Memory_Issues"></A></P><H3><HR>NTK 1.6 Heap/Partition Memory Issues (11/24/95)</H3><DL>   <DD>Q: How do I set the build heap, main heap, and MacOS   multifinder partition sizes in NTK 1.6 so I can build my package   without running out of memory?<BR>      <BR>      A: Here is an explanation of how Mac NTK makes uses of the various   heaps. Understanding this will allow you to set your sizes for   optimal performance. The same concepts apply to the Windows NTK,   except for the sections talking about MacOS multifinder   partitions.<BR>      <BR>      <B>Main Heap<BR>      <BR>      </B>The Main heap holds your frame data while you're working in   NTK. Its size is set through the Toolkit Preference dialog. You   must quit and restart NTK for changes to take effect.<BR>      <BR>      The Main heap is allocated when NTK starts up. It is not disposed   off until you quit NTK. If NTK can't allocate the Main heap it   reports the problem and quits. As a result, if you can start NTK,   Main heap allocation has completed.<BR>      <BR>      We have no rule of thumb for setting the Main heap size. You need   to experiment keeping the following in mind:<BR>      <BR>      1) If the Main heap is insufficient, NTK will tell you so.<BR>      2) Reducing the Main heap size reduces overall RAM   requirements.<BR>      3) The Main heap is garbage collected (GC). Increasing its size   may improve performance by reducing GC activity. This will affect   build time, and to a lesser degree the time it takes to open a   project. Please note that the gains in build time are nonlinear   and quickly reach a plateau, as shown in the following   example:<BR>      <BR>            <PRE><CODE>            Main        Build time    heap size        (+/- 0.5 sec)&nbsp;        1250K            Main heap ran out of memory...        1275K            32.7 sec        1300K            26.4 sec        1400K            22.3 sec        1500K            19.2 sec        1600K            17.5 sec        2000K            16.0 sec        3000K            15.2 sec&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Experiment with Main heap size by measuring build time until you   find a reasonable compromise between build time and memory   requirements for your particular project.<BR>      <BR>      If you are curious about GC activity, do the following:<BR>      <BR>      1) Add the following line to your <CODE>GlobalData </CODE>file (in   the NTK folder) and restart NTK:<BR>      </P>      <PRE><CODE>    protoEditor:DefineKey({key: 65}, 'EvaluateSelection);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>This allows you to use the period key on the numeric keypad   to evaluate selected text in the Inspector window or any text file   in the NTK build-time environment. (Normally the text is compiled   by NTK and then evaluated by the Newton device when you hit the   Enter key.) See the NTK User's Guide for details on the   <CODE>GlobalData</CODE> file.<BR>      <BR>      2) Type <CODE>VerboseGC(TRUE)</CODE> in the Inspector window,   select, and hit the keypad-period key. Each time the GC kicks in,   a line will be displayed in the Inspector window. By watching the   frequency of GCs, you can get some idea of how your main heap is   being used.<BR>      <BR>      3) Use <CODE>VerboseGC(FALSE)</CODE> to turn this feature off.   Please note that <CODE>VerboseGC </CODE>is available only in the   NTK build-time environment. The function does not exist on the   Newton device itself. It should be used only for debugging and   optimization.<BR>      <BR>      <B>Build Heap<BR>      <BR>      </B>The Build heap holds your package frame data during the last   part of the build. Its size is set through the Toolkit Preference   dialog. Changes take effect immediately.<BR>      <BR>      The Build heap is allocated only when the Build Package command is   issued. It is released as soon as the resulting file is written to   disk. As a result Build heap allocation is a recurring issue.<BR>      <BR>      The rule of thumb is to set the Build heap to the size of your   package (on the MacOS computer hard disk, not on the Newton   device). If the Build heap is insufficient, NTK will tell you   so.<BR>      <BR>      There is nothing to be gained by setting the Build heap larger   than necessary.<BR>      <BR>      NTK first attempts to allocate the Build heap from MultiFinder   memory. If that fails, NTK tries to allocate the Build heap from   NTK's partition.<BR>      <BR>      To verify that you have enough memory for the Build heap you need   to look at the "About This Macintosh" dialog in the Finder   application just prior to issuing the build command.<BR>      <BR>      1) If the "Largest Unused Block" exceeds the Build heap requested   size, the Build heap will be allocated from MultiFinder   memory.<BR>      <BR>      2) If 1 failed and NTK's partition bar shows enough free memory to   accommodate the request, the Build heap will be allocated in NTK's   partition.<BR>      <BR>      3) If both 1 and 2 failed, the build will fail. Try to increase   MultiFinder free memory by quitting any other open application, or   increase the free memory in NTK's partition by closing some or all   of NTK's open windows. Then try building again.<BR>      <BR>      To prevent fragmentation of MultiFinder memory launch NTK first,   and DocViewer, ResEdit, etc. afterwards. Whenever possible, quit   those other applications in the reverse order .<BR>      <BR>      Note: You can use Balloon help to see how much memory an   application is actually using. Simply select the Show Balloons   menu item and position the cursor on the application partition bar   in the About Macintosh dialog. This feature is missing from   PowerPC-based MacOS computers.<BR>      <BR>      <B>NTK Partition Size<BR>      <BR>      </B>For NTK 1.6 the rule of thumb for the "smallest useful"   partition size for small projects is:<BR>      (3500K + Main heap size) for a 680x0 MacOS computer<BR>      (5500K + Main heap size) for a PowerPC MacOS computer with Virtual   Memory off.<BR>      <BR>      These rules do not include space for the Build heap.<BR>      <BR>      The "smallest useful" partition size is defined by the following   example: Using NTK default Main and Build heaps, open the   Checkbook sample. Open one browser and one layout window for each   file in the project, connect the Inspector, build and download.   Perform a global search on "Check" (case insensitive) producing   slightly more than 200 matches. Double click on several of these   matches displayed in the search results window. Build and download   again.<BR>      <BR>      For serious work, increase the partition size by at least 256K for   small projects, more for large ones. If you routinely perform   global searches that produces many matches, see the next   section.<BR>      <BR>      On a PowerPC-based MacOS computer with Virtual Memory on, NTK's   2.7 Meg of code (the exact number is shown in the Finder Info   dialog) stays on the hard disk, reducing memory requirements at   the expense of performance.</P></DL><P><A NAME="NTK_Search_and_Memory_Hoarding"></A></P><H3><HR>NTK Search and Memory Hoarding (11/24/95)</H3><DL>   <DD>Q: I sometimes run out space after working with a project for   a while. How can I avoid this?<BR>      <BR>      A: NTK 1.6 is built with the MacApp application framework, which   brings with it certain memory requirements. Understanding the way   NTK uses memory can help avoid running out of memory.<BR>      <B><BR>      </B>Most of user interface elements you see when using NTK are   pointer-based MacApp objects. Allocating a large number of   pointers in the application heap causes fragmentation. To prevent   that, MacApp has its own private heap where it manages all these   pointers.<BR>      <BR>      This heap expands when necessary, but in the current   implementation it never shrinks. This memory is not lost, but it   may be wasted, effectively reducing free memory in the application   partition.<BR>      <BR>      During a single NTK session, build requirements are relatively   constant. Partition size requirements will thus be mostly affected   by the maximum number of NTK windows open at the same time. If you   keep this number reasonable, relative to the partition size you   can afford, there should be no problem.<BR>      <BR>      The fact that MacApp's objects heap never shrinks can, however,   become an issue when performing searches. The problem is not the   search itself, but the number of matches. Each line you see in the   Search Results window is a MacApp object occupying 500 to 800   bytes. If your search results in a large number of matches, you   may run out of memory.<BR>      <BR>      To reduce such occurrences:<BR>      1) Perform more focused searches to keep the number of matches per   search reasonable.<BR>      2) Close the Search Results window as soon as you are done with   it, preferably before doing another search.<BR>   </DL><P><A NAME="NTK_Stack_Overflow_During_Compilation"></A></P><H3><HR>NTK Stack Overflow During Compilation (11/24/95)</H3><DL>   <DD>Q: When I build my project that has very deeply nested   statements, NTK runs out of memory and quits. What's going   wrong?<BR>      <BR>      A: The deep nesting in your project is causing the compiler to   overflow the stack space available in NTK. NTK 1.6 is more likely   than than NTK 1.5 to suffer this problem due to new compiler code   which nests deeper while parsing if-then-else statements, causing   the stack to overflow into the application heap.<BR>      <BR>      If you see an inadvertent crash in NTK during a save operation or   a package build:<BR>      <BR>      1) If you are familiar with MacsBug, examine the stack. This   particular case will show up in the stack as several calls to the   same function before the actual crash.<BR>      2) Otherwise, temporarily reduce the number of "else" branches and   rebuild the package. If the problem disappears, stack overflow is   the prime suspect.<BR>      <BR>      There are at least three ways to avoid this problem and possibly   improve performance at the same time:<BR>      1) Re-arrange the 'else' statements to resemble a balanced   tree<BR>      2) Instead of If-then-else statements use:<BR>      An array of functions (with integers as selectors)<BR>      A frame of functions (with symbols as selectors)<BR>      3) Finally, as a temporary work around, you can increase the stack   size using the ResEdit application.<BR>      <BR>      <B>Re-arrange the 'else' statements to resemble a balanced   tree<BR>      </B><BR>      This solution is the simplest to implement if you need to change   existing code. It accommodates non-contiguous integer selectors,   and in most cases is faster.<BR>      <BR>      For example, the following code:<BR>            <PRE><CODE>   if x = 1 then        dosomething    else        if x = 2 then            doSomethingElse        else            if x = 3 then                doYetAnotherThing            else                if x = 4 then                    doOneMoreThing                else                    if x = 5 then                        doSomethingSimple                    else                        if x = 6 then                            doThatThing                        else                            if x = 7 then                                doThisThing                            else // x = 8                                doTheOtherThing&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>...can be rewritten like this:<BR>      <BR>      </P>      <PRE><CODE>   if x &lt;= 4 then        if x &lt;= 2 then            if x = 1 then                doSomething            else // x = 2                doSomethingElse        else            if x = 3 then                doYetAnotherThing            else // x = 4                doOneMoreThing    else        if x &lt;= 6 then            if x = 5 then                doSomethingSimple            else // x = 6                doThatThing        else           if x = 7 then                doThisThing           else // x = 8                doTheOtherThing;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Note that the if/then/else statement nesting is "unusual"   to illustrate the nesting that the compiler must make each   statement is nested as the compiler would process it.<BR>      <CODE><BR>      </CODE><BR>      <B>Use an array of functions with integer selectors<BR>      <BR>      </B>Replace a long if-then-else statement with an array of   functions. The code is more compact and readable. For a large set   of alternatives, the faster direct lookup should compensate for   the extra function call. This approach is most useful for a   contiguous range of selector values (e.g., 11 to 65). It can   accommodate a few "holes" (for example, 11 to 32, 34 to 56, 58 to   65). It is not practical for non-contiguous selectors (e.g., 31,   77, 256, 1038...)<BR>      <BR>      For example, the following code:<BR>      <BR>      </P>      <PRE><CODE>    if x = 1 then        dosuchandsuch;    else        if x = 2 then            dosomethingelse;        else            if x = 3 then                andsoon;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>...can be rewritten like this:<BR>      <BR>      </P>      <PRE><CODE>        cmdArray := [func() dosuchandsuch,        func() dosomethingelse,            func() andsoon];&nbsp;        call cmdArray[x] with ();&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <B>Use a frame of functions with symbols for selectors<BR>      </B><BR>      This alternative provides the flexibility of using symbols for   selecting the outcome.<BR>      <BR>      For example, the following code:<BR>      <BR>      </P>      <PRE><CODE>    if x = 'foo then        dosuchandsuch;    else        if x = 'bar then            dosomethingelse;        else            if x = 'baz then                andsoon;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      ...can be rewritten like this:<BR>      </P>      <PRE><CODE>    cmdFrame := {foo: func() dosuchandsuch,                    bar: func() dosomethingelse,                    baz: func() andsoon};&nbsp;      call cmdFrame.(x) with ();&nbsp;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE><B>Increase NTK's stack size using the ResEdit   application<BR>      <BR>      </B>Open the Newton Toolkit application with ResEdit.<BR>      <BR>      Double-click on the "<CODE>mem!</CODE>" resource icon<BR>      <BR>      Double-click on resource ID <CODE>1000 </CODE>named "Additional   NTK Memory Requirements"<BR>      <BR>      Change the fifth (and last) value. This is an hexadecimal number.   In NTK 1.6, you should see "<CODE>0001 8000</CODE>" which is   <CODE>98304</CODE> bytes (or <CODE>96k</CODE>) to add to the total   stack size. For example, to increase this value to   <CODE>128k</CODE> = <CODE>131072</CODE> bytes change the   hexadecimal value to "<CODE>0002 0000</CODE>".<BR>      </P></DL><P><A NAME="Unit_Import/Export_and_Interpackage_References"></A></P><H3><HR>Unit Import/Export and Interpackage References (11/25/95)</H3><DL>   <DD>Q: How can I reference information in one part or package from   another (different) part or package?<BR>      <BR>      A: Newton 2.0 OS provides the ability for packages to share   informations by exporting or importing units. Units are similar to   shared libraries in other systems.<BR>      <BR>      A unit provides a collection of NS objects (unit members.) Units   are identified by a name, major version number, and minor version   number. Any frame part can export or import zero or more   units.<BR>      <BR>      A unit must be declared, using <CODE>DeclareUnit</CODE>, before   it's used (imported or exported.) See the docs on   <CODE>DeclareUnit </CODE>below for details.<BR>      <BR>      To export a unit, call <CODE>DefineUnit </CODE>and specify the NS   objects that are exported.<BR>      <BR>      To import from a unit, simply reference its members using   <CODE>UnitReference </CODE>(or UR for short.)<BR>      <BR>      <BR>      <B>Unit Usage Notes<BR>      </B><BR>      &#149;Units can also be used to share objects among parts within a   single package. This avoids the need to resort to global variables   or similar undesirable techniques.<BR>      <BR>      &#149;A part can export multiple units. To achieve some degree of   privacy, you can partition your objects into private and public   units. Privacy is achieved by not providing the declaration for a   unit.<BR>      <BR>      &#149;References to units are resolved dynamically whenever a   package is activated or deactivated. For example, a package can be   loaded before the package providing the units it imports is   loaded. There will be no problem as long as the provider is loaded   prior to actually using the imported members.<BR>      <BR>      Conversely, it's possible for the provider to be deactived while   its units are in use. The part frame methods, RemovalApproval and   ImportDisabled, provide a way to deal with this situation.<BR>      <BR>      Robust code should ensure that the units it imports are available   before attempting to use their members. It should also gracefully   handle the situation of units being removed while in use. See the   DTS sample "MooUnit" for an example.<BR>      <B><BR>      Unit Build-Time Functions<BR>      </B><BR>      These functions are available in NTK at build-time only:<BR>      <BR>            <PRE><CODE>DeclareUnit(unitName, majorVersion, minorVersion, memberIndexes)</CODE></PRE>      <P><CODE><BR>      unitName </CODE>- symbol - name of the unit<BR>      <CODE>majorVersion </CODE>- integer - major version number of the   unit<BR>      <CODE>minorVersion </CODE>- integer - minor version number of the   unit<BR>      <CODE>memberIndexes </CODE>- frame - unit member name/index pairs   (slot/value)<BR>      return value - unspecified<BR>      <CODE><BR>      </CODE>A unit must be declared by <CODE>DeclareUnit </CODE>before   it's used (imported or exported.) The declaration maps the member   names to their indexes. A typical declaration looks like:<BR>      <BR>      </P>      <PRE><CODE>    DeclareUnit('|FastFourierTransforms:MathMagiks|, 1, 0, {        ProtoGraph:     0,        ProtoDataSet:   1,    });</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Typically, the declarations for a unit are provided in a file,   such as "FastFourierTransforms.unit", that is added to an NTK   project (similar to <CODE>.h</CODE> files in C.)<BR>      <BR>      When resolving imports, the name and major version specified by   the importer and exporter must match exactly. The minor version   does not have to match exactly. If there are units differing only   in minor version, the one with the largest minor version is   used.<BR>      <BR>      Typically, the first version of a unit will have major version 1   and minor version 0. As bug fixes releases are made, the minor   version is incremented. If a major (incompatible) change is made,   then the major version number is incremented.<BR>      <BR>      Note: When a unit is modified, the indexes of the existing members   must remain the same. In other words, adding new members is safe   as long as the indexes of the existing members don't change. If   you change a member's index it will be incompatible with any   existing clients (until they're recompiled with the new   declaration.)<BR>      <BR>      </P>      <PRE><CODE>DefineUnit(unitName, members)</CODE></PRE>      <P><CODE><BR>      unitName </CODE>- symbol - name of the unit<BR>      <CODE>members </CODE>- frame - unit member name/value pairs   (slot/value)<BR>      return value - unspecified<BR>      <BR>      <CODE>DefineUnit </CODE>exports a unit and specifies the value of   each member. Immediates and symbols are not allowed as member   values. A typical definition looks like:<BR>      <BR>      </P>      <PRE><CODE>    DefineUnit('|FastFourierTransforms:MathMagiks|, {    ProtoGraph:     GetLayout("foo.layout"),    ProtoDataSet:   { ... },});</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      A unit must be declared before it's defined. The declaration used   when exporting a unit with <CODE>n</CODE> members must contain   <CODE>n</CODE> slots with indexes <CODE>0..n-1</CODE>. The   definition must specify a value for every declared member (this is   important.)<BR>      <BR>      </P>      <PRE><CODE>UnitReference(unitName, memberName)</CODE></PRE>      <P><CODE><BR>      </CODE>or<BR>      </P>      <PRE><CODE>UR(unitName, memberName)</CODE></PRE>      <P><CODE><BR>      unitName </CODE>- symbol - name of a unit<BR>      <CODE>memberName </CODE>- symbol - name of a member of unit<BR>      return value - a reference to the specified member<BR>      <BR>      To use a unit member call <CODE>UnitReference </CODE>(<CODE>UR   </CODE>for short) with the unit and member name.<BR>      <BR>      The unit name <CODE>'ROM</CODE> can be used to refer to obects in   the base ROM. For example:<BR>      <CODE>UR('ROM, 'ProtoLabelInputLine)</CODE>.<BR>      <BR>      Note: references to objects in the base ROM are sometimes called   "magic pointers" and have traditionally been provided in NTK by   constants like <CODE>ProtoLabelInputLine </CODE>or   <CODE>ROM_SystemSoupName</CODE>.<BR>      <BR>      In Newton 2.0 OS, there may also be packages in the ROM. These ROM   packages may provide units. Their members are referenced just like   any other unit, using <CODE>UR</CODE>, the unitName, and the   memberName. This is the mechanism by which licensees can provide   product-specific functionality.<BR>      </P>      <PRE><CODE>AliasUnit(alias, unitName)</CODE></PRE>      <P><CODE><BR>      alias </CODE>- symbol - alternate name for unit<BR>      <CODE>unitName </CODE>- symbol - name of a unit<BR>      return value - unspecified<BR>      <BR>      <CODE>AliasUnit </CODE>provides a way to specify an alternate name   for a unit. Since unit names must be unique, they tend to be long   and cumbersome. For example:<BR>      </P>      <PRE><CODE>    AliasUnit('FFT, '|FastFourierTransforms:MathMagiks|);</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      ...so that you could write:<BR>      </P>      <PRE><CODE>    local data := UR('FFT, 'ProtoDataSet):New(points);</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      ...instead of:<BR>      </P>      <PRE><CODE>    local data := UR('|FastFourierTransforms:MathMagiks|,     'ProtoDataSet):New(points);&nbsp;&nbsp;AliasUnitSubset(alias, unitName, memberNames)</CODE></PRE>      <P><CODE><BR>      alias </CODE>- symbol - alternate name for unit<BR>      <CODE>unitName </CODE>- symbol - name of a unit<BR>      <CODE>memberNames </CODE>- array of symbols - list of unit member   names<BR>      return value - unspecified<BR>      <BR>      <CODE>AliasUnitSubset </CODE>is similar to <CODE>AliasUnit</CODE>,   except that it additionally specifies a subset of the units   members which can be used. This helps restrict code to using only   certain members of a unit.<BR>      <BR>      <BR>      <B>Unit Part Frame Methods<BR>      </B><BR>      These methods can optionally be defined in a part frame to handle   units becoming unavailable.<BR>      </P>      <PRE><CODE>RemovalApproval(unitName, majorVersion, minorVersion)</CODE></PRE>      <P><CODE><BR>      unitName </CODE>- symbol - name of the unit<BR>      <CODE>majorVersion </CODE>- integer - major version number of the   unit<BR>      <CODE>minorVersion </CODE>- integer - minor version number of the   unit<BR>      return value - <CODE>nil </CODE>or string<BR>      <BR>      This message is sent to a part frame when an imported unit is   about to be deactivated. It may a return a string to be shown to   the user as a warning about the consequences of deactivating the   package in use. For example:<BR>      <BR>      </P>      <PRE><CODE>"This operation will cause your connection to fooWorld to be dropped."</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note: do not assume that the user is removing the package. Other   operations such as moving a package between stores also cause   package deactivation.<BR>      <BR>      This message is only a warning. The user may decide to proceed and   suffer the consequences. If the user proceeds, the   <CODE>ImportDisabled </CODE>message (see below) will be sent.<BR>      <BR>      If the removing the unit is not a problem (for example, your   application is closed), then<CODE> RemovalApproval </CODE>can   return <CODE>nil </CODE>and the user will not be bothered.<BR>      <BR>      </P>      <PRE><CODE>ImportDisabled(unitName, majorVersion, minorVersion)</CODE></PRE>      <P><CODE><BR>      unitName </CODE>- symbol - name of the unit<BR>      <CODE>majorVersion </CODE>- integer - major version number of the   unit<BR>      <CODE>minorVersion </CODE>- integer - minor version number of the   unit<BR>      return value - unspecified<BR>      <BR>      This message is sent to a part frame after an imported unit has   been deactivated. The part should deal with the situation as   gracefully as possible. For example, use alternative data or put   up a Notify and/or close your application.<BR>      <BR>      <B>Unit-Related Glue Functions<BR>      </B><BR>      These functions are available in the Newton 2.0 Platform file.<BR>      <BR>      </P>      <PRE><CODE>MissingImports(pkgRef)</CODE></PRE>      <P><CODE><BR>      </CODE>return value - <CODE>nil </CODE>or an array of frames (see   below)<BR>      glue name - <CODE>kMissingImportsFunc<BR>      </CODE><BR>      <CODE>MissingImports </CODE>lists the units used by the specified   package that are not currently available. <CODE> MissingImports   </CODE>returns either nil, indicating there are no missing units,   or an an array of frames of the form:<BR>      </P>      <PRE><CODE>    {        name: symbol  - name of unit desired        major: integer - major version number        minor: integer - minor version number&nbsp;        &lt;other slots undocumented&gt;    }</CODE>&nbsp;</PRE></DL><P><A NAME="Store_parts_and_PowerPC-native_NTK"></A></P><H3><HR>Store parts and PowerPC-native NTK (5/15/96)</H3><DL>   <DD>Q: When I build a store part with NTK 1.6 or 1.6.2 on my   PowerPC MacOS computer, text searches (for example<CODE>   mySoup:Query({words: "pizza"}</CODE>) don't sucessfully find the   entries. Why?<BR>      <BR>      A: On PowerPC MacOS computers only, there is a bug in 1.6 and   1.6.2 wherein building store parts will cause this behavior. The   workaround is building the store part on a 680x0-based MacOS   computer.<BR>      <BR>      If you don't have a 680x0 machine available, you might try any of   various third-party applications which remove the PowerPC-native   code from an application which contains 680x0 code and PowerPC   code, thus forcing it to run the 680x0 code instead. Before doing   this, be sure to backup your copy of NTK!</DL><P><A NAME="Using_Strings_as_Hex_Data_and_Windows_NTK"></A></P><H3><HR><B>CHANGED: </B>Using Strings as Hex Data and Windows NTK (7/18/97)</H3><DL>   <DD>Q: When I use <CODE>SetClass(SetLength("\u&lt;hex data&gt;"),   theLength), theClass)</CODE> in Windows NTK , the binary object is   not what I expect. It seems to be byte-swapped. How can I create   binary objects with data in them in Windows NTK?<BR>      <BR>      A: In Windows NTK (and other Windows NS environments), strings are   stored in byte swapped order, that is, low byte first. This is   because strings are basically arrays of 16-bit Unicode characters,   and on the Intel platform 16-bit values are most usefully stored   low byte first. Technically, changing the class and length of a   string relies on the internal representation of strings, which   isn't documented or supported, though it works fine on Newton OS   and Mac OS platforms.<BR>      <BR>      The correct way to create binary objects is to use the new   <CODE>MakeBinaryFromHex()</CODE> function; it handles the   byte-swapping issues properly. This function is defined by the   platform file, and only runs at build-time -- it doesn't exist on   the Newton device. You may need to get a newer platform file   because this function was added after Windows NTK 1.6 shipped.</DL><H2>NewtonScript</H2><P><A NAME="Nested_Frames_and_Inheritance"></A></P><H3><HR>Nested Frames and Inheritance (10/9/93)</H3><DL>   <DD>Unlike C++ and other object oriented languages, NewtonScript   does not have the notion of nested frames obtaining the same   inheritance scope as the enclosing frame.<BR>      <BR>      This is an important design issue, because sometimes you want to   enclose a frame inside a frame for name scoping or other reasons.   If you do so you have to explicitly state the messages sent as   well as explicitly state the path to the variable:<BR>      <BR>      Here's an example that shows the problems:<BR>      <BR>            <PRE><CODE>myEncloser := {    importantSlot: 42,    GetImportantSlot := func()        return importantSlot,&nbsp;    nestedSlot := {        myInternalValue: 99,&nbsp;        getTheValue := func()            begin            local foo;            foo := :GetImportantSlot();            // WON'T WORK; can't find function            foo := myEncloser:GetImportantSlot();    // MAY WORK&nbsp;            importantSlot := 12;       // WON'T WORK; will create new slot in nestedSlot            myEncloser.importantSlot := 12;        // MAY WORK            end    }};&nbsp;myEncloser.nestedSlot:GetTheValue();&nbsp;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>The proper way to accomplish this is to give the nested   frame a <CODE>_parent</CODE> or <CODE>_proto</CODE> slot that   references the enclosing frame. Nesting the frame is not strictly   necessary in this case, only the <CODE>_proto</CODE> or   <CODE>_parent</CODE> references are used.<BR>      </P></DL><P><A NAME="Symbol_Hacking"></A></P><H3><HR>Symbol Hacking (11/11/93)</H3><DL>   <DD>Q: I would like to be able to build frames dynamically and   have my application create the name of the slot in the frame   dynamically as well. For instance, something like this:<BR>            <PRE><CODE>MyFrame:= {}; theSlotName := "Slot_1";</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      At this point is there a way to then create the following?...   <CODE>MyFrame.Slot_1<BR>      </CODE><BR>      A: The function <CODE>Intern</CODE> takes a string and returns a   symbol. There is also a mechanism called path expressions (see the   NewtonScript Reference), that allows you to specify an expression   or variable to evaluate, in order to get the slot name. You can   use these things to access the slots you want:<BR>      <BR>      </P>      <PRE><CODE>    MyFrame := {x: 4};    theXSlotString := "x" ;&nbsp;    MyFrame.(Intern(theXSlotString)) := 6 &nbsp;    theSlotName := "Slot_1";    MyFrame.(Intern(theSlotName)) := 7;&nbsp;    // myFrame is now {x: 6, Slot_1: 7}</CODE></PRE></DL><P><A NAME="Check_for_Application_Base_View_Slots"></A></P><H3><HR>Check for Application Base View Slots (3/6/94)</H3><DL>   <DD>Here's a simple function that will print out all the slots and   the slot values in an application base view. This function is   handy if you want to check for unnecessary slots stored in the   application base view; these eat up the NewtonScript heap and   eventually cause problems with external PCMCIA RAM cards.<BR>      <BR>            <PRE><CODE>    call func()     begin        local s,v;        local root := GetRoot();        local base := root.|YourApp:YourSIG|; // name of app        local prot := base._proto;&nbsp;        foreach s,v in base do        begin            if v and v &lt;&gt; root AND v &lt;&gt; base AND v &lt;&gt; prot then              begin               Write ("Slot:" &amp;&amp; s &amp; ", Value: ");               Print(v);              end;        end;    end with ()&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>The debugging function <CODE>TrueSize</CODE> can also be a   valuable tool to determine the heap used by your applications. See   the NTK User Guide for more information about   <CODE>TrueSize</CODE>.<BR>      </P></DL><P><A NAME="Performance_of_Exceptions_vs_Return_Codes"></A></P><H3><HR>Performance of Exceptions vs Return Codes (6/9/94)</H3><DL>   <DD>Q: What are the performance tradeoffs in writing code that   uses try/onexception vs returning and checking error results?<BR>      <BR>      A: We did a few trials to weight the relative performance.   Consider the following two functions:<BR>      <BR>            <PRE><CODE>    thrower: func(x) begin        if x then            throw('|evt.ex.msg;my.exception|, "Some error occurred");        end;     returner: func(x) begin        if x then            return -1;    // some random error code,        0; // nil, true, whatever.        end; </CODE></PRE>      <P><CODE><BR>      </CODE>Code to throw and and handle an exception:<BR>      </P>      <PRE><CODE>    local s;    for i := 1 to kIterations do        try            call thrower with (nil);        onexception |evt.ex.msg;my.exception| do            s := CurrentException().data.message;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Code to check the return value and handle an error:<BR>      </P>      <PRE><CODE>    local result;    local s;    for i := 1 to kIterations do        if (result := call returner with (nil)) &lt; 0 then            s := ErrorMessageTable[-result];</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      Running the above loops 1000 times took about 45 ticks for the   exception loop, and about 15 ticks for the check the return value   loop. From this you might conclude that exception handling is a   waste of time. However, you can often write better code if you use   exceptions. A large part of the time spent in the loop is setting   up the exception handler. Since we commonly want to stop   processing when exceptions occur, we can rewrite the function to   set up the exception handler once, like this:<BR>      <BR>      </P>      <PRE><CODE>local s;try    for i := 1 to kIterations do        call thrower with (nil);    onexception |evt.ex.msg;my.exception| do        s := CurrentException().data.message;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      This code takes only 11 ticks for 1000 iterations, an improvement   over the return value case, where we'd have to check the result   after each call to the function and stop the loop if an error   occurred.<BR>      <BR>      Running the same loops, but passing <CODE>TRUE </CODE>instead of   <CODE>NIL </CODE>so the "error" occurs every time was interesting.   The return value loop takes about 60 ticks, mostly due to the time   needed to look up the error message. The exception loop takes a   whopping 850 ticks, mostly because of the overhead in the   <CODE>CurrentException</CODE>() call.<BR>      <BR>      With exceptions, you can handle the error at any level up the call   chain, without having to worry about each function checking for   and returning error results for every sub-function it uses. This   will produce code that performs much better, and will be easier to   maintain as well.<BR>      <BR>      With exceptions, you do not have to worry about the return value   for successful function completion. It is occasionally very   difficult to write functions that both have a return value and   generate an error code. The C/C++ solution is to pass a pointer to   a variable that is modified with what should otherwise be the   return value of the function, which is a technique best   avoided.<BR>      <BR>      As in the above example, you can attach data to exceptions, so   there's no need to maintain an error code to string (or whatever)   mapping table, which is another boon to maintainability. (You can   still use string constants and so on to aid localization efforts.   Just put the constant in the throw call.)<BR>      <BR>      Finally, every time an exception occurs you have an opportunity to   intercept it with the NTK inspector. This is also a boon to   debugging, because you know something about what's going wrong,   and you can set the <CODE>breakOnThrows</CODE> global to stop your   code and look at why there's a problem. With result codes you have   a tougher time setting break points. With a good debugger it could   be argued that you can set conditional break points on the "check   the return value" code, but even when you do this you'll have lost   the stack frame of the function that actually had the problem.   With exceptions and <CODE>breakOnThrows</CODE>, all the local   context at the time the exception occurred is still available for   you to look at, which is an immense aid.<BR>      <BR>      Conclusion: Use exceptions. The only good reason not to would be   if your error handler is very local and if you expect it to be   used a lot, and if that's true you should consider rewriting the   function.</P></DL><P><A NAME="NewtonScript_Object_Sizes"></A></P><H3><HR>NewtonScript Object Sizes (6/30/94)</H3><DL>   <DD>These desciptions document current OS formats only, we reserve   the right to extend or change the implementation in future   releases.<BR>      <BR>      <B>Generic<BR>      </B>NewtonScript objects are objects that reside either in the   read-write NewtonScript memory, in pseudo-ROM memory, inside the   package, or in ROM. In earlier MessagePad platforms, these objects   are aligned to 8-byte boundaries. In Newton 2.0 OS, objects in the   NewtonScript memory are aligned to 4-byte boundaries. Inside   Newton 2.0 packages, you can optionally align objects to 4-byte   boundaries (with NTK's "tighter object packing" checkbox).   Alignment causes a very small amount of memory to be wasted,   usually less than 2%.<BR>      <BR>      <BR>      The Newton Object System has four built-in primitive classes that   describe an object's basic type: immediates, binary objects,   arrays, and frames. The NewtonScript function   <CODE>PrimClassOf</CODE> will return an object's primitive   type.<BR>      <BR>      <B>Immediates and Magic Pointers<BR>      </B>Immediates (integers, characters, TRUE and NIL) and magic   pointers are stored in a 4-byte structure containing up to 30 bits   of data and 2 bits of primitive class identification.<BR>      <BR>      <B>Referenced Objects<BR>      </B>Binaries, arrays and frames are stored as larger separate   objects and managed through references. A reference is a four-   byte object. The binary objects, frames, or arrays themselves are   stored separately as objects containing a so-called Object   Header.<BR>      <BR>      <B>Object Header<BR>      </B>Every referenced object has a 12-byte header that contains   information concerning size, flags, class, lock count and so on.   This information is implementation-specific.<BR>      <BR>      <B>Symbols<BR>      </B>A symbol is a binary object that contains a four-byte hash   value and a name, which is a null-terminated ASCII string. Each   symbol uses 12 (header) + 4 (hash value) + length of name + 1   (null terminator) bytes.<BR>      <BR>      <B>Binary Objects<BR>      </B>A binary object contains a 12- byte header plus space for the   actual data (allocated in 8 -byte chunks.)<BR>      <BR>      <B>Strings<BR>      </B>Strings are binary objects of class (or a subclass of)   <CODE>String</CODE>. A string object contains a 12-byte header   plus the Unicode strings plus a null termination character. Note   that Unicode characters are two-byte values. Here's an   example:<BR>            <PRE><CODE>    "Hello World!"&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>This string contains 12 characters, in other words it has   24 bytes. In addition we have a null termination character (24 + 2   bytes) and an object header (24 + 2 + 12 bytes), all in all the   object is 38 bytes big. Note that we have not taken into account   any possible savings if the string was compressed (using the NTK   compression flags).<BR>      <BR>      <B>Rich Strings<BR>      </B>Rich strings extend the string object class by embedding ink   information within the object. Within the unicode, a special   character <CODE>kInkChar</CODE> is used to mark the position of an   ink word. The ink data is stored after the null termination   character. Ink size varies depending on stroke complexity.<BR>      <BR>      <B>Array Objects<BR>      </B>Array objects have an object header (12 bytes) and additional   four bytes per element which hold either the immediate value or a   reference to a referenced object. To calculate the total space   used by an array, you need to take into account the memory used by   any referenced objects in the array.<BR>      <BR>      Here's an example:<BR>      </P>      <PRE><CODE>    [12, $a, "Hello World!", "foo"]&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>We have a header (12 bytes) plus four bytes per element (12   + (4 * 4) bytes). The integer and character are immediates, so no   additional space is used, but we have 2 string objects that we   refer to, so the total is (12 + (4*4) + 38 + 20 bytes) 86 bytes.   We have not taken into account savings concerning compression.   Note that the string objects could be referred by other arrays and   frames as well, so the 38 and 20 byte structures are stored only   once per package.<BR>      <BR>      <B>Frame Objects<BR>      </B>We have two kinds of frames: frames that don't have a shared   map object; and frames that do have a shared map object. We take   the simple case first (no shared map object).<BR>      <BR>      The frame is maintained as two array-like objects. One, called the   frame map, contains the slot names, and the other contains the   actual slot values. A frame map has one entry per symbol, plus one   additional 4 -byte value.<BR>      <BR>      The frame map uses a minimum of 16 bytes. If we add the frame's   object header to this, the minimal size of a frame is 28 bytes.   Each slot adds 8 bytes to the storage used by the frame (two array   entries.) Here's an example:<BR>      </P>      <PRE><CODE>    {Slot1: 42, Slot2: "hello"}&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>We have a header of 28 bytes, and in addition we have two   slots, for a total of (28 + (2 * 8)) 48 bytes. This does not take   into account the space used for each of the slot name symbols or   for the string object. (The integer is an immediate, and so is   stored in the array.)<BR>      <BR>      Multiple similar frames (having the same slots) could share a   frame map. This will save space, reducing the space used per frame   (for many frames all sharing the same map) to the same as used for   an array with the same number of slots. (If just a few frames   share the frame map, we need to take into account the amortized   map size that the frames share. So the total space for N frames   sharing a map is N*28 bytes of header per frame, plus the size of   the frame map, plus the size of the values for the N frames.<BR>      <BR>      Here's an example of a frame that could share a map with the   previous example:<BR>      </P>      <PRE><CODE>    {Slot1: 56, Slot2: "world"}&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>We have a header of 12 bytes. In addition, we have two   slots (2 * 4), and additional 16 bytes for the size of a map with   no slots &Ntilde; all in all, 36 bytes. We should also take into   account the shared map, which is 16 bytes, plus the space for the   two symbols.<BR>      <BR>      When do frames share maps?<BR>      <BR>      1. When a frame is cloned, both the copy and the original frame   will share the map of the original frame. A trick to make use of   this is to create a common template frame, and clone this template   when duplicate frames are needed.<BR>      <BR>      2. Two frames created from the same frame constructor (that is,   the same line of NewtonScript code) will share a frame map. This   is a reason to use <CODE>RelBounds</CODE> to create the   <CODE>viewBounds</CODE> frame, and it means there will be a single   <CODE>viewBounds</CODE> frame map in the part produced.<BR>      <BR>      Note<B>:</B> These figures are for objects in their run-time   state, ready for fast access. Objects in transit or in storage   (packages) are compressed into smaller stream formats. Different   formats are used (and different sizes apply) to objects stored in   soups and to objects being streamed over a communications   protocol.</P></DL><P><A NAME="Symbols_vs_Path_Expressions_and_Equality"></A></P><H3><HR>Symbols vs Path Expressions and Equality (7/11/94)</H3><DL>   <DD>Q: While trying to write code that tests for the existance of   an index, I tried the following, which did not work. How can I   compare path expressions?<BR>            <PRE><CODE>if value.path = '|name.first| then ...    // WRONG&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>A: There are several concerns. <CODE>'|name.first|</CODE>   is not a path expression, it is a symbol with an escaped period. A   proper path expression is either <CODE>'name.first</CODE> or   <CODE>[pathExpr: 'name, 'first]</CODE>. The vertical bars escape   everything between them to be a single NewtonScript symbol.<BR>      <BR>      The test <CODE>value.path = 'name.first</CODE> will always fail,   because path expressions are deep objects (essentially arrays) the   equal comparison will compare references rather than contents. You   will have to write your own code to deeply compare path   expressions.<BR>      <BR>      This code is further complicated by the fact that symbols are   allowed in place of path expressions that contain only one   element, but the two syntaxes produce different NewtonScript   objects with different meanings. That is, <CODE>'name = [pathExpr:   'name]</CODE> will always fail, as the objects are different.<BR>      <BR>      A general test is probably unnecessary in most circumstances,   since you will be able to make assumptions about what you are   looking for. For example, here is some code that will check if a   given path value from a soup index is equivalent to   <CODE>'name.first</CODE>:<BR>      <BR>      </P>      <PRE><CODE>if ClassOf(value.path) = 'pathExpr and Length(value.path) = 2      and value.path[0] = 'name and value.path[1] = 'first then ...&nbsp;</CODE>&nbsp;</PRE></DL><P><A NAME="Function_Size_and_" closed _over " _environment></A></P><H3><HR>Function Size and "Closed Over" Environment (7/18/94)</H3><DL>   <DD>Q: I want to create several frames (for soup entries) that all   share a single function, but when I try to store one of these   frames to a soup, I run out of memory. Can several frames share a   function and still be written to a soup? My code looks like   this:<BR>            <PRE><CODE>    ...    local myFunc := func(...) ...;    local futureSoupEntries := Array(10, nil);    for i := 0 to 9 do        futureSoupEntries[i] := {            someSlots: ...,            aFunction: myFunc,        };    ...&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>A: When a function is defined within another function, the   lexically enclosing scope (locals and paramaters) and message   context (self) are "closed over" into the function body. When   NewtonScript searches for a variable to match a symbol in a   function, it first searches the local scope, then any lexically   enclosing scopes, then the message context (self), then the _proto   and _parent chains from the message context, then finally the   global variables.<BR>      <BR>      Functions constructed within another function, as in your example,   will have this enclosing lexical scope, which is the locals and   parameters of the function currently being executed, plus the   message context (self) when the function is created. Depending on   the size of this function and how it's constructed, this could be   very large. (Self might be the application's base view, for   example.)<BR>      <BR>      A <CODE>TotalClone</CODE> is made during the process of adding an   entry to a soup, and this includes the function body, lexical   scopes, and message context bound up within any functions in the   frame. All this can take up a lot of space.<BR>      <BR>      If you create the function at compile time (perhaps with   <CODE>DefConst('kMyFunc, func(...) ...)</CODE>) it will not have   the lexically enclosing scope, and the message context at compile   time is defined to be an empty frame, and so cloning such a   function will take less space. You can use the constant   <CODE>kMyFunc</CODE> within the initializer for the frame, and   each frame will still reference the same function body.   (Additionally, the symbol <CODE>kMyFunc</CODE> will not be   included in the package, since it is only needed at compile   time.)<BR>      <BR>      If the soup entries are only useful when your package is   installed, you might consider instead replacing the function body   with a symbol when you write the entry to the soup. When the entry   is read from the soup, replace the symbol with the function   itself, or use a <CODE>_proto</CODE> based scheme instead. Each   soup entry will necessarily contain a complete copy of the   function, but if you can guarantee that the function body will   always be available within your application's package, it might be   unnecessarily redundant to store a copy with each soup entry.<BR>      </P></DL><P><A NAME="TrueSize_Incorrect_for_Soup_Entries"></A></P><H3><HR>TrueSize Incorrect for Soup Entries (2/6/96)</H3><DL>   <DD>Q: When I use <CODE>TrueSize </CODE>to get the size of a soup   entry I get results like 24K or even 40K for the size. That can't   be right. What's going on?<BR>      <BR>      A: <CODE>TrueSize </CODE>"knows" about the underlying   implementation of soup entries. A soup entry is really a special   object (a fault block) that contains information about how to get   an entry and can contain a cached entry frame. In the information   about how to get an entry, there is a reference to the soup, and   various caches in a soup contain references to the cursors, the   store, and other (large) NewtonScript objects. <CODE>TrueSize   </CODE>is reporting the space taken up by all of these objects.   (Note: calling <CODE>TrueSize</CODE> on a soup entry will force   the entry to be faulted in, even if it was not previously taking   up space in the NewtonScript heap.)<BR>      <BR>      The result is that <CODE>TrueSize </CODE>is not very useful when   trying to find out how much space the cached frame for an entry is   using. A good way to find the space used for a cached entry frame   is to call g<CODE>c(); stats();</CODE> record the result, then   call <CODE>EntryUndoChanges(entry); gc(); stats()</CODE>. The   difference between the two free space reports will be the space   used by the cached frame for a given entry.<BR>      <BR>      <CODE>EntryUndoChanges(entry)</CODE> will cause any cached frame   to be removed and the entry to return to the unfaulted state. Gc()   then collects the space previouly used by the cached entry   frame.<BR>      <BR>      If you want the <CODE>TrueSize </CODE>breakdown of the types of   objects used, you can <CODE>Clone </CODE>the entry and call   <CODE>TrueSize </CODE>on the copy. This works because the copy is   not a fault block, and so it does not reference the   soups/cursors/stores.</DL><P><A NAME="Floating_Point_Numbers_Are_Approximations"></A></P><H3><HR>Floating Point Numbers Are Approximations (3/28/97)</H3><DL>   <DD>Q: The functions <CODE>Floor</CODE> and <CODE>Ceiling</CODE>   seem broken. For instance, <CODE>Floor(12.2900 * 10000)</CODE>   returns 122899, not 122900. What's going on?<BR>      <BR>      A: This is not a bug in <CODE>Floor</CODE> or   <CODE>Ceiling</CODE>. This happens because of the way floating   point numbers are stored, and the limitation is common to many   real number representations. In the same way that 1/3 cannot   accurately be represented in a finite number of digits in base 10   (it is .3333333333...), likewise 1/10 cannot be exactly   represented as a fractional part in base 2. Because number   printers typically round to a small number of significant digits,   you don't normally notice this. The NTK inspector, for example,   displays only 5 significant figures in floating point numbers.   However, if you display the number with enough precision, you'll   see the representation error, where the real is actually slightly   larger or smaller than the intended value.<BR>      <CODE>FormattedNumberStr(0.1, "%.18f") -&gt;   "0.100000000000000010"</CODE><BR>            <PRE><CODE>    FormattedNumberStr(0.3, "%.18f")  -&gt;  "0.299999999999999990"</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The functions <CODE>Floor</CODE> and <CODE>Ceiling</CODE> are   strict, and do not attempt to take this error into account. In the   example, <CODE>12.29</CODE> is actually   <CODE>12.2899999999999990</CODE>, which multiplied by   <CODE>10000</CODE> is <CODE>122,899.999999999990</CODE>. The   largest integer less than this number (<CODE>Floor</CODE>) is   correctly <CODE>122899</CODE>.<BR>      <BR>      There are usually ways to work around this problem, depending on   what you are trying to accomplish. To convert a floating point   number to an integer, use <CODE>RIntToL</CODE>, which rounds to   the nearest integer avoiding the problems caused with round-off   error and <CODE>Floor</CODE> or <CODE>Ceiling</CODE>.   <CODE>RIntToL(x)</CODE> produces the same result that   <CODE>Floor(Round(x))</CODE> would produce.<BR>      </P>      <PRE><CODE>    RIntToL(12.29*10000)  -&gt;  122900</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      If you need to format a number for display, use a formatting   function such as <CODE>FormattedNumberStr</CODE>. These functions   typically round to the nearest displayable value. To display 2   decimal digits, use "%.2f":<BR>      </P>      <PRE><CODE>    FormattedNumberStr(12.29, "%.2f")  -&gt;  "12.29"</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      If you're working with fixed point numbers such as dollar amounts,   consider using integers instead of reals. By representing the   value in pennies (or mils, or whatever) you can avoid the   imprecision of reals. For example, represent <CODE>$29.95</CODE>   as the integer <CODE>2995</CODE> or <CODE>29950</CODE>, then   divide by <CODE>100</CODE> or <CODE>1000</CODE> to display the   number. If you do this, keep in mind that there is a maximum   representable integer value, <CODE>0x1FFFFFFF</CODE> or   <CODE>536870911</CODE>, which is sufficient to track over 5   million dollars as pennies, but can't go much over that.<BR>      <BR>      If you really need to find the greatest integer less than a   certain number and can't tolerate how <CODE>Floor</CODE> deals   with round off errors, you'll need to do some extra work keeping   track of the precision of the number and the magnitude of the   round off error. It's worthwhile to read a good numeric methods   reference. Floating point numbers in NewtonScript are represented   by IEEE 64-bit reals, which are accurate to around 15 decimal   digits. The function <CODE>NextAfterD</CODE> provides a handy way   to see how 'close together' floating point numbers are.<BR>      </P>      <PRE><CODE>        FormattedNumberStr(NextAfterD(0.3, kInfinity), "%.18f");                                                    -&gt;  "0.300000000000000040"</CODE>&nbsp;</PRE></DL><P><A NAME="Real_Numbers_in_NewtonScript"></A></P><H3><HR>Real Numbers in NewtonScript (3/28/97)</H3><DL>   <DD>Q: How are real numbers represented as floating point in   NewtonScript? How accurate are they? What about infinities, NANs,   and other exceptions?<BR>      <BR>      A: Real numbers in NewtonScript are represented as IEEE 64-bit   floating point numbers, which are accurate to about 15 decimal   digits. You can read more about the IEEE floating point numbers in   "Inside Macintosh: PowerPC Numerics" available online at the   URL:<BR>            <PRE><CODE>        http://gemma.apple.com/dev/techsupport/insidemac/PPCNumerics/PPCNumerics-2.html</CODE></PRE>      <P><CODE><BR>      </CODE>The Newton floating point environment is not as rich in   features as the PowerPC environment, and the PowerPC numerics   document is only mentioned as a useful resource for understanding   floating point issues. It in no way documents API or features of   the Newton floating point environment.<BR>      <BR>      Briefly, numbers are represented by 1 bit of sign ("on" is   negative), 11 bits of exponent, and 52 bits of fractional part.   The exponent bits are stored in excess 0x3FF, that is, 0x3FF is   the representation for 0, values greater than 0x3FF are positive   exponents, and values less than 0x3FF are negative exponents. The   52 bits of fractional part actually provide 53 bits of accuracy,   because the initial 1 bit is dropped.<BR>      <BR>      For example, suppose that we want to convert 9 97/128 into IEEE 64   bit format:<BR>      1) convert to base 2<BR>      <CODE>1001.1100001</CODE><BR>      2) shift number to the form of 1.yyyyyy * 2^Z<BR>      <CODE>1.0011100001 * 2^3 </CODE><BR>      3) add 0x3FF (excess 0x3FF) to exponent field, convert to   binary.<BR>      <CODE>3+0x3FF = 0x402 = 100 0000 0010 </CODE><BR>      4) now put the numbers together, using only the fractional part of   the number represented above, in the form of yyyyyy<BR>      <CODE>0 10000000010   0011100001000000000000000000000000000000000000000000 </CODE><BR>      in hex representation, this is <CODE>0x4023840000000000</CODE><BR>      5) Just to verify, try it: <CODE>StrHexDump(9+97/128, 16) -&gt;   "4023840000000000"</CODE><BR>      <BR>      The IEEE standard also allows for non-normal numbers. Here are the   exceptions:<BR>      infinity e = 7FF, f = 0 (+ or - depending on sign bit)<BR>      NaN e = 7FF, f &lt;&gt; 0 (also overflow, error, etc.)<BR>      zero e = 0, f = 0 (+ or -, depending on sign bit)<BR>      subnormal e = 0, f &lt;&gt; 0 (these are less precise numbers,   smaller than the smallest normal number)<BR>      <BR>      Note that there is more than one not a number value. In fact,   there are quite a large number. The IEEE spec assigns meaning to   various NaN values, as well as defining signalling and quiet NaNs.   NewtonScript does not distinguish between NaN values. One NaN is   as good as another.<BR>      <BR>      In NewtonScript, real numbers are 8-byte binary objects of class   '<CODE>real</CODE>. In addition to the NewtonScript floating point   literal syntax, you can use the compile time function   <CODE>MakeBinaryFromHex</CODE> to construct real numbers, and you   must use this style for custom NaN values. The most recent   platform files for Newton 2.0 and Newton 2.1 provide constants for   negative zero (<CODE>kNegativeZero</CODE>), positive and negative   infinity (<CODE>kInfinity</CODE>, <CODE>kNegativeInfinity</CODE>),   and a canonical NaN (<CODE>kNaN</CODE>).<BR>      <CODE>MakeBinaryFromHex("4023840000000000", 'real) -&gt; 9.7578125   // = 9+97/128</CODE><BR>      </P></DL><H2>Pickers, Popups and Overviews</H2><P><A NAME="Determining_Which_ProtoSoupOverview_Item_Is_Hit"></A></P><H3><HR>Determining Which ProtoSoupOverview Item Is Hit (2/5/96)</H3><DL>   <DD>Q: How do I determine which item is hit in a   <CODE>protoSoupOverview</CODE>?<BR>      <BR>      A: There is a method called <CODE>HitItem </CODE>that gets called   whenever an item is tapped. The method is defined by the overview   and you should call the inherited one. Also note that   <CODE>HitItem </CODE>gets called regardless of where in the line a   tap occurs. If the tap occurs in the checkbox, you should do   nothing, otherwise you should do something.<BR>      <BR>      The method is passed the index of the hit item. The index is   relative to the item displayed at the top of the displayed list.   This item is always the current entry of the cursor used by   <CODE>protoSoupOverview</CODE>. So, you can find the actual soup   entry by cloning the cursor and moving it.<BR>      <BR>      Here is an example of a <CODE>HitItem </CODE>method. If the item   is selected (the checkbox is not tapped) then the code will set an   inherited cursor (called <CODE>myCursor</CODE>) to the entry that   was tapped on:<BR>      <BR>            <PRE><CODE>func(itemIndex, x, y)begin    // MUST call the inherited method for bookeeping    inherited:HitItem(itemIndex, x, y);        if x &gt; selectIndent then    begin  // get a temporary cursor based on the cursor used  // by soup overview        local tCursor := cursor:Clone();&nbsp;  // move it to the selected item        tCursor:Move(itemIndex) ;&nbsp;  // move the inherited cursor to the selected entry        myCursor:Goto(tCursor:Entry());&nbsp;  // usually you will close the overview and switch to  // some other view        self:Close();    end;    // otherwise, just let them check/uncheck // which is the default behaviorend</CODE></PRE></DL><P><A NAME="Displaying_the_ProtoSoupOverview_Vertical_Divider"></A></P><H3><HR>Displaying the ProtoSoupOverview Vertical Divider (2/5/96)</H3><DL>   <DD>Q: How can I display the vertical divider in a   <CODE>protoSoupOverview</CODE>?<BR>      <BR>      A: The mechanism for bringing up the vertical divider line was not   correctly implemented in <CODE>protoSoupOverview</CODE>. You can   draw one in a <CODE>viewDrawScript </CODE>as follows:<BR>      <BR>            <PRE><CODE>    // setup a cached shape for efficiency    mySoupOverview.cachedLine := nil;&nbsp;    mySoupOverview.viewSetupDoneScript := func()    begin       inherited:?viewSetupDoneScript();           local bounds := :LocalBox();       cachedLine := MakeRect(selectIndent - 2, 0,            selectIndent - 1, bounds.bottom);    end;        mySoupOverview.viewDrawScript := func()    begin       // MUST call inherited script       inherited:?viewDrawScript();           :DrawShape(cachedLine,             {penPattern: vfNone, fillPattern: vfGray});    end;</CODE></PRE></DL><P><A NAME="Validation_and_Editing_in_ProtoListPicker"></A></P><H3><HR>Validation and Editing in ProtoListPicker (4/1/96)</H3><DL>   <DD>Q: I am trying to use the <CODE>ValidationFrame </CODE>to   validate and edit entries in a <CODE>protoListPicker</CODE>. When   I edit certains slots I get an error that a path failed. All the   failures occur on items that are nested frames in my soup entry.   What is going on?<BR>      <BR>      A: The built-in validation mechanism is not designed to deal with   nested soup information. In general, you gain better flexibility   by not using a <CODE>validationFrame </CODE>in your pickerDef,   even if you have no nested entries. Instead, you can provide your   own validation mechanism and editors:<BR>      <BR>      Define a <CODE>Validate </CODE>method in your picker   definition<BR>      Define an <CODE>OpenEditor </CODE>method in your picker   definition<BR>      Draw a layout for each editor you require<BR>      <BR>            <PRE><CODE>pickerDef.Validate(nameRef, pathArray)</CODE></PRE>      <P><CODE><BR>      nameRef </CODE>- nameRef to validate<BR>      <CODE>pathArray </CODE>- array of paths to validate in the   nameRef<BR>      returns an array of paths that failed, or an empty array<BR>      <BR>      Validate each path in <CODE>pathArray </CODE>in the given nameRef.   Accumulate a list of paths that are not valid and return them.<BR>      <BR>      The following example assumes that <CODE>pickerDef.ValidateName   </CODE>and <CODE>pickerDef.ValidatePager </CODE>have been   implemented:<BR>      <BR>      </P>      <PRE><CODE>pickerDef.Validate := func(nameRef, pathArray)begin    // keep track of any paths that fail    local failedPaths := [];                                                            foreach index, path in pathArray do    begin        if path = 'name then        begin            // check if name validation fails            if NOT :ValidateName(nameRef) then                // if so, add it to array of failures                AddArraySlot(failedPaths, path);        end;        else begin            if NOT :ValidatePager(nameRef) then                AddArraySlot(failedPaths, path);        end;    end;    // return failed paths or empty array    failedPaths;end;&nbsp;&nbsp;pickerDef.OpenEditor(tapInfo, context, why)</CODE></PRE>      <P><CODE><BR>      </CODE>The arguments and return value are as per   <CODE>OpenDefaultEditor</CODE>. However, you need to use this   instead of <CODE>DefaultOpenEditor</CODE>.<BR>      <BR>      </P>      <PRE><CODE>pickerDef.OpenEditor := func(tapInfo, context, why)begin   local valid = :Validate(tapInfo.nameRef, tapInfo.editPaths) ;    if (Length(valid) &gt; 0) then        // if not valid, open the editor        // NOTE: returns the edit slip that is opened        GetLayout("editor.t"):new(tapInfo.nameRef,            tapInfo.editPaths, why, self, 'EditDone, context);    else    begin        // the item is valid, so just toggle the selection        context:Tapped('toggle);        nil;                                        // Return &lt;nil&gt;.    end;..end;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>The example above assumes that the layout "editor.t" has a   <CODE>New </CODE>method that will open the editor and return the   associated View.<BR>      <BR>      The editor can be designed to fit your data. However, we suggest   that you use a <CODE>protoFloatNGo </CODE>that is a child of the   root view created with the <CODE>BuildContext </CODE>function. You   are also likely to need a callback to the pickderDef so it can   appropriately update the edited or new item. Finally, your editor   will need to update your data soup uing an "Xmit" soup method so   that the listPicker will update.<BR>      <BR>      In the <CODE>OpenEditor </CODE>example above, the last three   arguments are used by the editor to send a callback to the   pickerDef from the <CODE>viewQuitScript</CODE>. The design of the   callback function is up to you, here is an example:<BR>      </P>      <PRE><CODE>pickerDef.EditDone := func(nameRef, context)begin   local valid = :Validate(tapInfo.nameRef, tapInfo.editPaths) ;    if (Length(valid) &gt; 0) then    begin    // Something failed. Try and revert back to original        if NOT :ValidatePager(nameRef) AND            self.('[pathExpr: savedPagerValue, nameRef]) = nameRef             then            nameRef.pager := savedPagerValue.pager;                context:Tapped(nil);        // Remove the checkmark    end;    else        // The nameRef is valid, so select it.        context:Tapped('select);        // Clear the saved value for next time.    savedPagerValue := nil;        end;</CODE></PRE></DL><P><A NAME="Picker_List_is_Too_Short"></A></P><H3><HR>Picker List is Too Short (4/29/96)</H3><DL>   <DD>Q: I have items in my picker list with different heights that   I set using the <CODE>fixedHeight </CODE>slot. When I bring up the   picker, it is not tall enough to display all the items. Worse, I   cannot scroll to the extra items. What is going on?<BR>      <BR>      A: The <CODE>fixedHeight </CODE>slot is used for two separate   things. Any given pick item can use the <CODE>fixedHeight   </CODE>slot to specify a different height. This works fine.<BR>      <BR>      However, the code in Newton 2.0 OS that determines how big the   list should be also uses the <CODE>fixedHeight </CODE>slot of the   first pick item (in other words, <CODE>pickItems[0]</CODE>) if it   exists. It is as if the following code executes:<BR>      <BR>            <PRE><CODE>local itemHeight := kDefaultItemHeight;if pickItems[0].fixedHeight then   itemHeight := pickItems[0].fixedHeight;local totalHeight := itemHeight * Length(pickItems);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>This total height is used to figure out if scrolling is   required. As you can see, this can cause problems if your first   item is not the tallest one. The solution is to make sure the   first item in your <CODE>pickItems</CODE> array has a   <CODE>fixedHeight </CODE>slot that is sufficiently large to make   scrolling work correctly. This may be fixed in future revisions of   the NewtonOS.<BR>      <BR>      Note that there will be similar problems if your pick items   contain icons. The system will use the default height unless you   specify a <CODE>fixedHeight </CODE>slot in your first item. The   default height is not tall enough for most icons. In other words,   if you have icons in your pick items, you must have a   <CODE>fixedHeight </CODE>slot in the first item that is set to the   height of your icon.</P></DL><P><A NAME="Tabs_Do_Not_Work_With_ProtoTextList"></A></P><H3><HR>Tabs Do Not Work With ProtoTextList (5/8/96)</H3><DL>   <DD>Q: I tried to use tabs to get columns in a <CODE>protoTextList   </CODE>but they do not appear. How do I get columns?<BR>      <BR>      A: The text view in <CODE>protoTextList </CODE>is based on a   simple text view which does not support tabs. If you want   scrolling selectable columns you can use shapes to represent the   rows. If you need finer control, use the <CODE>LayoutTable   </CODE>view method.</DL><P><A NAME="How_to_Avoid_Problems_with_ProtoNumberPicker"></A></P><H3><HR>How to Avoid Problems with ProtoNumberPicker (8/23/96)</H3><DL>   <DD>Q: I am thinking of using <CODE>protoNumberPicker</CODE> for   input. (or) I have used <CODE>protoNumberPicker</CODE> and have   encountered a bug/misfeature/problem. What should I use?<BR>      <BR>      A: <CODE>protoNumberPicker</CODE> has several instabilities and   bugs. We recommend that you use the DTS sample code   "protoNumberPicker_TDS". It provides all of the features of   <CODE>protoNumberPicker</CODE> with none of the bugs. It also   provides additional functionality that is not in   <CODE>protoNumberPicker</CODE>. See the sample code for more   detail.<BR>   </DL><P><A NAME="Single_Selection_in_ProtoListPicker-based_Views"></A></P><H3><HR>Single Selection in ProtoListPicker-based Views (9/20/96)</H3><DL>   <DD>Q: How do I allow only one item to be selected in a   <CODE>protoListPicker</CODE>, <CODE>protoPeoplePicker</CODE>,   <CODE>protoPeoplePopup</CODE>, or<CODE>   protoAddressPicker</CODE>?<BR>      <BR>      A: The key to getting single selection is that single selection is   part of the picker definition and not an option of   <CODE>protoListPicker</CODE>. That means that the particular class   of nameRef you use must include single selection. In general, this   requires creating your own subclass of the particular name   reference class.<BR>      <BR>      The basic solution is to create a data definition that is a   subclass of the particular class that your <CODE>protoListPicker   </CODE>variant will view. That data definition will include the   <CODE>singleSelect </CODE>slot. As an example, suppose you want to   use a <CODE>protoPeoplePopup </CODE>that just picks individual   people. You could use the following code to bring up a   <CODE>protoPeoplePopup </CODE>that only allowed selecting one   individual at one time:<BR>      <BR>            <PRE><CODE>    // register the modified data definition    RegDataDef('|nameref.people.single:SIG|,    {_proto: GetDataDefs('|nameRef.people|), singleSelect: true});&nbsp;    // then pop the thing    protoPeoplePopup:New('|nameref.people.single:SIG|,[],self,[]);&nbsp;    // sometime later    UnRegDataDef('|nameref.people.single:SIG|);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>For other types of <CODE>protoListPickers</CODE> and   classes, create the appropriate subclass. For example, a transport   that uses <CODE>protoAddressPicker </CODE>for emails might create   a subclass of <CODE>'|nameRef.email|</CODE> and put that subclass   symbol in the <CODE>class </CODE>slot of the   <CODE>protoAddressPicker</CODE>.<BR>      <BR>      Since many people are likely to do this, you may cut down on code   in your <CODE>installScript </CODE>and <CODE>removeScript   </CODE>by registering your dataDef only for the duration of the   picker. That would mean registering the class just before you pop   the picker and unregistering after the picker has closed. You can   use the <CODE>pickActionScript </CODE>and <CODE>pickCanceledScript   </CODE>methods to be notified when to unregister the dataDef.</P></DL><P><A NAME="How_to_Change_Font_or_LineHeight_in_ProtoListPicker"></A></P><H3><HR>How to Change Font or LineHeight in ProtoListPicker (9/20/96)</H3><DL>   <DD>Q: How do I set a different font for the items in the   <CODE>protoListPicker</CODE>?<BR>      <BR>      A: There is a way to change the font in the Newton 2.0 OS,   however, we intend to change the mechanism in the future.   Eventually, you will be able to set a <CODE>viewFont </CODE>slot   in the <CODE>protoListPicker </CODE>itself and have that work   (just like you can set <CODE>viewLineSpacing </CODE>slot now). In   the meantime, you need a piece of workaround code. Warning: you   must set the viewFont of the listPicker AND include this   workaround code in the <CODE>viewSetupDoneScript</CODE>:<BR>      <BR>            <PRE><CODE>func()    begin       if listBase exists and listBase then          SetValue(listBase, 'viewFont, viewFont) ;&nbsp;           inherited:?viewSetupDoneScript();    end;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>This will set the <CODE>viewFont </CODE>slot of the   <CODE>listBase</CODE> view to the <CODE>viewFont </CODE>of the   <CODE>protoListPicker</CODE>. You cannot rely on the listbase view   always being there, hence the test for its existence.<BR>      <BR>      Note that you can use the same code to modify the   <CODE>lineHeight</CODE> slot of the listPicker. Just substitute   <CODE>lineHeight</CODE> for <CODE>viewFont</CODE> in the code   snippet. The one caveat is that the <CODE>lineHeight</CODE> must   be at least 13 pixels.</P></DL><P><A NAME="How_to_Preselect_Items_in_ProtoListPicker"></A></P><H3><HR>How to Preselect Items in ProtoListPicker (9/20/96)</H3><DL>   <DD>Q: If I put name references in the <CODE>selected</CODE> array   of a <CODE>protoListPicker</CODE>, it throws a <CODE>-48402</CODE>   error. How do I preselect items?<BR>      <BR>      A: In the MessagePad 120/130 units it is not possible to preselect   items in the listPicker and have it work correctly. We recommend   that you use the "protoSlimPicker" DTS Sample Code instead.</DL><P><A NAME="How_to_Get_ProtoSoupOverview_Selections"></A></P><H3><HR>How to Get ProtoSoupOverview Selections (10/3/96)</H3><DL>   <DD>Q: How do I get the selected items in   <CODE>protoSoupOverview</CODE>?<BR>      <BR>      A: The final documentation inadvertantly left out the following   documentation on the <CODE>selected</CODE> slot:<BR>      <BR>      <CODE>selected</CODE> - Required. Initially set to   <CODE>nil</CODE>; it is modified by <CODE>protoSoupOverview</CODE>   as the user selects and deselects overview items.<BR>      This slot contains an array of soup entry aliases to the selected   items when the overview is closed, or <CODE>nil</CODE> or the   empty array if there is no selection. For example:<BR>            <PRE><CODE>                    [[alias: NIL, 66282812, 84, "Names"],                  [alias: NIL, 66282812, 85, "Names"]]</CODE></PRE></DL><P><A NAME="Dynamically_Adding_to_ProtoTextList_Confuses_Scrolling"></A></P><H3><HR>Dynamically Adding to ProtoTextList Confuses Scrolling (1/15/97)</H3><DL>   <DD>Q: I am adding items to a <CODE>protoTextList</CODE> after it   is displayed. I add an item and scroll to highlight that item.   However, the state of the scroll arrows does not correctly get   updated. Sometimes it will indicate that there are more items to   scroll when it is really at the end of the list.<BR>      <BR>      A: There is a problem with Newton 2.0 OS devices (although not   Newton 2.1 OS devices) that causes the <CODE>protoTextList</CODE>   to reset the scroll distance when you update the listItems array.   The workaround is to always scroll the list to the top before   calling <CODE>SetupList</CODE> when you add items. Then you can   scroll the list to where you want it. Note that this workaround is   safe to use in Newton 2.1 OS as well. In other words, if you are   adding items to a <CODE>protoTextList</CODE>, use this workaround   unless your application is Newton 2.1 OS-specific. This method   will add a single item to the <CODE>protoTextList</CODE>, set the   highlighted item to the new item and scroll if required. It will   also make sure the item is unique.<BR>      <BR>            <PRE><CODE>    AddListItem := func(newItem)    begin         // Insert the item if not already in Array        local index := BInsert(listItems, item, '|str&lt;|, nil, true);&nbsp;        // item must be in the array and index will point to the item.&nbsp;        if NOT index then        begin            :Notify(kNotifyAlert, kAppName, "Duplicate entry.");            return nil;        end;&nbsp;        // workaround a bug in 2.0 that causes the        // scroll arrows to get out of sync        // do this by scrolling to the top        :DoScrollScript(-viewOriginY) ;&nbsp;        self:SetUpList();&nbsp;        // Setting the selection slot will highlight the item        selection := index;&nbsp;        // scroll to show the new item        if index &gt;= viewLines then            :DoScrollScript((index - viewLines + 1) * lineHeight) ;&nbsp;        self:RedoChildren();&nbsp;        return true;    end ;</CODE>&nbsp;</PRE></DL><P><A NAME="ProtoPicker_Lists_are_Sometimes_Blank"></A></P><H3><HR><B>NEW: </B>ProtoPicker Lists are Sometimes Blank (5/16/97)</H3><DL>   <DD>Q: I have a <CODE>protoPicker</CODE> that I reuse in my   application. Sometimes the picker will be blank when I open it.   What's happening?<BR>      <BR>      A: <CODE>ProtoPicker</CODE> does not correctly reset the   <CODE>viewOriginY</CODE> slot if you display a list that requires   scrolling, and then display one that does not require scrolling.   The solution is to manually reset the <CODE>viewOriginY</CODE>   slot to 0 if you dynamically change the contents of the picker.</DL><P><A NAME="ProtoPeoplePicker_Name_Display_Changed_in_Newton_2_1"></A></P><H3><HR><B>NEW: </B>ProtoPeoplePicker Name Display Changed in Newton 2.1(7/2/97)</H3><DL>   <DD>Q: In Newton OS 2.0, the <CODE>protoPeoplePicker</CODE>   displayed names as "last, first", but in Newton 2.1 OS it displays   "first last". How can I make <CODE>protoPeoplePicker</CODE>   display the original way?<BR>      <BR>      A: You will need to create a subclass of the   <CODE>nameRefDataDef</CODE> for people that will display the name   in "last, first" format. The good news is that this workaround   will work on both Newton 2.0 and Newton 2.1. The basic steps   are:<BR>      <BR>      1. Register your own subclass of <CODE>nameRefDataDef</CODE> that   does the right thing<BR>      <BR>      2. Use this new data def class in the <CODE>dataClass</CODE> slot   of your <CODE>peoplePicker</CODE><BR>      <BR>      3. Unregister your subclass when you are done (for instance, when   quitting the application)<BR>      <BR>      <BR>      Here is some code that can be used to register a subclass. Put the   following in a text file in your project:<BR>      <BR>            <PRE><CODE>    // create a unique symbol for the the data def    DefineGlobalConstant('kMyDataDefSym,        Intern("nameRef.people.lastFirst:" &amp; kAppSymbol)) ;&nbsp;    DefineGlobalConstant('kMyGetFunc,        func(item, fieldPath, format)        begin            // if this is a person, not a company, modify stuff            local entry := EntryFromObj(item) ;                if fieldPath = 'name AND format = 'text AND entry AND                 IsFrame(entry) AND ClassOf(entry) = 'person then            begin                local nameFrame := entry.name ;                if nameFrame AND nameFrame.first AND nameFrame.last then                    return nameFrame.last &amp; ", " &amp; nameFrame.first ;                else                    return inherited:Get(item, fieldPath, format) ;            end             else                return inherited:Get(item, fieldPath, format) ;        end    ) ;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Put this code into the <CODE>viewSetupFormScript</CODE> of the   base view of your application:<BR>      <BR>      </P>      <PRE><CODE>            // register my modified people data def        RegDataDef(kMyDataDefSym, {_proto: GetDataDefs('|nameRef.people|),                        Get: kMyGetFunc}) ;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Put this code into the <CODE>viewQuitScript</CODE> of the base   view of your application:<BR>      <BR>      </P>      <PRE><CODE>        // unregister my modified people data def        UnRegDataDef(kMyDataDefSym) ;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      Use the <CODE>kMyDataDefSym</CODE> constant as the value for the   <CODE>dataClass</CODE> slot of your <CODE>protoPeoplePicker</CODE>   or <CODE>protoPeoplePopup</CODE><BR>      </P></DL><P><A NAME="Setting_Default_Choices_for_Country_or_State_Pickers"></A></P><H3><HR><B>NEW: </B>Setting Default Choices for Country or State Pickers(7/15/97)</H3><DL>   <DD>Q: How do I set a default country for   <CODE>protoCountryTextPicker</CODE> or default state for   <CODE>protoUSstatesTextPicker</CODE>?<BR>      <BR>      A: You can specify a default country/state by adding a slot called   <CODE>'default</CODE> to the <CODE>params</CODE> frame. The slot   must contain the name of the country   (<CODE>protoCountryTextPicker</CODE>) or state   (<CODE>protoUSstatesTextPicker</CODE>) as a string. For example,   if you wanted the <CODE>protoCountryTextPicker</CODE> to default   to Canada, you could do the following in the   <CODE>viewSetupFormScript</CODE>:<BR>      <BR>            <PRE><CODE>    // get a writeable copy of the params frame    self.params := Clone(params);    params.default := "Canada";</CODE></PRE></DL><H2>Recognition</H2><P><A NAME="Custom_Recognizers"></A></P><H3><HR>Custom Recognizers (2/8/96)</H3><DL>   <DD>Q: Can I build recognizers for gestures and objects other than   those built into the Newton system?<BR>      <BR>      A: In Newton 2.0 OS, theres no support to add custom recognizers   using the Newton Toolkit. Stay tuned for more information   concerning this.<BR>      <BR>      Some recognition engines can work in a window separate from the   edited text. For instance, writing a "w" in a special view might   causes "w" to appear in the currently edited text view (the key   view.) This type of recognition system can be implemented as a   keyboard. If you want to use this approach, you might want to use   a function in the Newton 2.0 Platform file that allows your   keyboard to replace the built-in alphanumeric "typewriter"   keyboard. See the Platform File Notes documentation for more   information on the <CODE>RegGlobalKeyboard </CODE>function.</DL><P><A NAME="How_to_Save_and_Restore_Recognition_Settings"></A></P><H3><HR>How to Save and Restore Recognition Settings (4/9/96)</H3><DL>   <DD>Q: Can I capture a user's recognition settings, which then may   later be restored?<BR>      <BR>      A: Yes, the global functions <CODE>GetUserSettings</CODE>,   <CODE>SetDefaultUserSettings </CODE>and <CODE>SetUserSettings   </CODE>allow you to manipulate recognition-related user preference   data. These functions can allow an application to keep and manage   recognition settings for multiple users. These functions only   manage information about the recognition settings, and no other   user preference settings.<BR>      <BR>            <PRE><CODE>    GetUserSettings()</CODE></PRE>      <P><CODE><BR>      </CODE>This function returns a frame of the current user   recognition settings; this frame is the argument for   <CODE>SetUserSettings</CODE>. Do not modify the frame this   function returns. Do not rely on any values, as the frame may   change in future releases.<BR>      <BR>      </P>      <PRE><CODE>    SetDefaultUserSettings()</CODE></PRE>      <P><CODE><BR>      </CODE>This function sets recognition-related user preference   settings to default values.<BR>      <BR>      </P>      <PRE><CODE>    SetUserSettings(savedSettings)</CODE></PRE>      <P><CODE><BR>      </CODE>savedSettings - Recognition preferences frame returned by   <CODE>GetUserSettings</CODE>.<BR>      Sets user preferences for recognition as specified.<BR>      </P></DL><P><A NAME="Opening_the_Corrector_Window"></A></P><H3><HR>Opening the Corrector Window (3/17/97)</H3><DL>   <DD>Q: I want the corrector window available for the user at   specific times, can I open it from within my application?<BR>      <BR>      A: Yes, below is the code you should use to open the corrector   window. For compatibility, you should always make sure the   corrector exists. The corrector itself requires that a correctable   key view exists.<BR>      <BR>            <PRE><CODE>local correctView := GetRoot().correct;if correctView and (GetCaretBox() or GetHiliteOffsets()) then   correctView:Open();&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Note: An older version of this Q&amp;A (from 12/8/95)   showed using <CODE>GetKeyView</CODE> as a test to make sure a   correctable view was the key view. With the changes to the OS with   the Newton 2.1 release that allow any view to be a key view, this   is no longer a reliable test. The corrector will fail to open   (generating a -48204 "bad path" error) if the key view does not   support the caret or a selection. Calling <CODE>GetCaretBox</CODE>   and <CODE>GetHiliteOffsets</CODE> is a more reliable test to see   if a correctable view is available.</P></DL><H2>Routing</H2><P><A NAME="Printing_Resolution_72DPI/300DPI"></A></P><H3><HR>Printing Resolution 72DPI/300DPI (2/8/94)</H3><DL>   <DD>Q: I've tried to print PICT resources; the picture was   designed in Illustrator and copied to the clipboard as a PICT. The   picture printed correctly but at a very low resolution. Is there   any way of printing PICTs with a higher resolution?<BR>      <BR>      A: Currently the only supported screen resolution for PICT   printing is 72dpi. This may change in future platforms, so stay   tuned for more information.<BR>   </DL><P><A NAME="PICT_Printing_Limitations"></A></P><H3><HR>PICT Printing Limitations (6/9/94)</H3><DL>   <DD>Q: My large pictures cannot print on my LaserWriter. Is there   a maximum size Newton picture?<BR>      <BR>      A: The current PostScript printing system in the Newton ROMs is   unable to print extremely large individual bitmap frames, the kind   of pictures created using the NTK Picture editor or the   GetPictAsBits routine. This is because in order to print these,   the Newton must copy the bitmaps into an internal buffer. Thus the   GetPictAsBits case fails (current limitation is a 168K buffer, but   do not rely on a specific number for other Newton devices).<BR>      <BR>      Using the <CODE>GetNamedResource(..., 'picture)</CODE> routine,   you can use PICT resources to be drawn in clPictureViews. MacOS   PICT resources often contain multiple opcodes (instructions). For   single-opcode PICTs, compression is done for the whole picture.   You can check <I>Inside Macintosh </I>documentation for   specifications of the PICT format. If you are using very large   bitmaps which you will print, you should use PICT resources   composed of many smaller 'bitmap copy' opcodes because they will   print much faster and more reliably on PostScript printers. This   is because very large PICT opcodes printed to LaserWriters must be   decompressed on the printer. The printer's decompression buffer is   sometimes too small if the opcodes represent large bitmaps. Check   your MacOS graphics application documentation for more information   on segmenting your large PICTs into smaller pieces. For some   applications, you might have two versions of the PICTs, one for   displaying (using <CODE>GetPictAsBits </CODE>for faster screen   drawing), and a large tiled PICT for printing.<BR>      <BR>      Starting with Newton 2.1 OS, color PICTs (PICT 2) are supported.   Colors will be interpolated into gray values.</DL><P><A NAME="Printing_Fonts_with_a_PostScript_Printer"></A></P><H3><HR>Printing Fonts with a PostScript Printer (7/26/94)</H3><DL>   <DD>Q: When printing from my application on the Newton to a   PostScript Laser printer, I noticethat the fonts are substituted.   Printing always looks fine on a fax or bitmap printer like the   StyleWriter.<BR>      <BR>      A: Yes, this is true.The additional System font (Espy Sans) or any   custom Newton font created with the Newton Font Tool is not   printed directly to a LaserWriter because the fonts are missing in   the PostScript font versions. Just printing Espy Sans (Newton   system fonts) is currently not possible on the LaserWriter, but is   possible on faxes and bitmap printer drivers, since the rendering   for those is done inside the Newton.<BR>      <BR>      For the built-in Espy font, the troublesome characters are the   Apple-specific ones, starting with Hex FC. The filled diamond is   one of these characters, the specific tick box arrow is   another.<BR>      <BR>      For printing, you might need to include bitmaps for special   characters or words in your application in order to print them   (that is, if the normal LaserWriter fonts are unacceptable)<BR>      <BR>      Note that if you want a monospaced font, check out the DTS sample   "<CODE>MonacoTest</CODE>". That includes a font which will print   as the monospaced Courier font.<BR>   </DL><P><A NAME="Printing_Does_Not_Have_Access_to_My_Application_Slots"></A></P><H3><HR>Printing Does Not Have Access to My Application Slots (11/27/95)</H3><DL>   <DD>Q: Why can't I find my application slots from my print   format?<BR>      <BR>      A: Print format does not have direct access to your application   context because it is not a child of your application, so it   cannot rely on the parent inheritance chain. All viewDefs should   be designed so that they do not rely on your application being   open or rely on state-specific information in your application.   The application may be closed, or the user may continue to work in   your application while the print/fax transport is imaging.<BR>      <BR>      Print format does have access to the <CODE>target</CODE> variable   (it will contain the "body" of the data sent; don't use   <CODE>fields</CODE>.body). Note that if mulitiple items are sent,   the value of <CODE>target</CODE> will change as the print format   iterates over the list. Try to put the real "data" for the routing   in the target using the view method   <CODE>GetTargetInfo</CODE>.<BR>      <BR>      If, for some reason, you need to access slots from your   application, you can access them using   <CODE>GetRoot().(yourAppSymbol).theSlot</CODE>.<BR>   </DL><P><A NAME="How_to_Open_the_Call_Slip_or_Other_Route_Slips"></A></P><H3><HR>How to Open the Call Slip or Other Route Slips (12/19/95)</H3><DL>   <DD>Q: How do I open the call slip (or other route slips)   programmatically?<BR>      <BR>      A: Use the global function <CODE>OpenRoutingSlip</CODE>. Create a   new item with the transport's <CODE>NewItem </CODE>method and add   routing information such as the recipient information in the   <CODE>toRef </CODE>slot. For the call slip, the transport symbol   will be '<CODE>|phoneHome:Newton|</CODE>, but this approach will   work for other transports. (For transports other than the call   transports, you will also provide the data to route in the   <CODE>item.body</CODE> slot.)<BR>      <BR>      <B>Determining the value of the toRef slot<BR>      </B><BR>      The <CODE>toRef </CODE>slot in the item frame should contain an   array of recipients in the form of nameRefs, which are the objects   returned from <CODE>protoPeoplePicker </CODE>and other   <CODE>protoListPicker</CODE>-based choosers. Each nameRef can be   created from one of two forms: a cardfile soup entry, or just a   frame of data with minimal slots. (The required slots vary   depending on the transport. For instance, the current call   transport requires only phone, name, and country.)<BR>      <BR>      1. Cardfile entry:<BR>            <PRE><CODE>        entry := myCursor:Entry();</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      2. Create your own pseudo-entry:<BR>      </P>      <PRE><CODE>        entry := {        phone:"408 555 1234",        name: {first: "Glagly", last: "Wigout"},        country: "UK",    };</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      Make the entry into a "nameRef" using the nameRef's registered   datadef -- an object which describes how to manipulate nameRefs of   a specific class. Note that every transport stores its preferred   nameRef class symbol in its <CODE>transport.addressingClass   </CODE>slot. (Examples are <CODE>'|nameRef.phone|</CODE> and   <CODE>'|nameRef.email|</CODE>).<BR>      <BR>      </P>      <PRE><CODE>local class := '|nameRef.phone|;local nameRef := GetDataDefs(class):MakeNameRef(myData, class);</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      <B>Setting up the targetInfo Frame<BR>      </B><BR>      Your <CODE>GetTargetInfo </CODE>view method should return a   <CODE>targetInfo </CODE>frame, consisting of <CODE>target   </CODE>and <CODE>targetView </CODE>slots. Alternatively, you can   create a frame consisting of these slots and pass it to   <CODE>OpenRoutingSlip</CODE>. As a workaround to a ROM bug, you   must also supply an <CODE>appSymbol </CODE>slot in the   <CODE>targetInfo </CODE>frame containing your appSymbol. Note that   <CODE>targetInfo.target </CODE>could be a multiple item target   (see the <CODE>CreateTargetCursor </CODE>documentation for more   info.)<BR>      <BR>      <BR>      <B>Opening The Slip<BR>      </B><BR>      You can use <CODE>OpenRoutingSlip </CODE>to open the slip after   setting up slots such as <CODE>toRef </CODE>and <CODE>cc   </CODE>within the item. You can use code such as the   following:<BR>      <BR>      </P>      <PRE><CODE>/* example using Call Transport */local item, entry, class, nameRef;&nbsp;// just for testing, get an Name...entry := GetUnionSoup("Names"):Query(nil):Entry();&nbsp;item := TransportNotify('|phoneHome:Newton|, 'NewItem, [nil]);if item = 'noTransport or not item then    return 'noTransport; &nbsp;class := '|nameRef.phone|;nameRef := GetDataDefs(class):MakeNameRef(entry, class);item.toRef :=  [nameRef];targetInfo := {    targetView: getroot(),     target: {}/* for non-CALL transports, add your data here! */,     appsymbol: kAppSymbol    };&nbsp;// returns view (succeeded), or fails: nil or 'skipErrorMessageOpenRoutingSlip(item, targetInfo);</CODE>&nbsp;</PRE></DL><P><A NAME="Routing_Multiple_Items"></A></P><H3><HR>Routing Multiple Items (5/15/96)</H3><DL>   <DD>Q: How can my application route multiple items at one   time?<BR>      <BR>      A: The target must be a "multiple item target" created with the   <CODE>CreateTargetCursor </CODE>function.<BR>      For instance, your application could use a <CODE>GetTargetInfo   </CODE>method like:<BR>      <BR>            <PRE><CODE>        func(reason)    begin        local t := CreateTargetCursor(kDataClassSymbol, myItemArray);        local tv := base; // the targetView&nbsp;            return {target: t, targetView: tv};    end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The first argument to <CODE>CreateTargetCursor</CODE> is used as   the class of the target, which is used to determine what formats   and transports are available. You must register formats on that   data class symbol in your part's <CODE>InstallScript   </CODE>function.<BR>      <BR>      The item array passed to <CODE>CreateTargetCursor</CODE> can   contain any items, including soup entries or soup entry aliases.   If you include soup entry aliases, they will automatically be   resolved when accessing items using the <CODE>GetTargetCursor   </CODE>function.<BR>      <BR>      Print formats that have their <CODE>usesCursors </CODE>slot set to   <CODE>nil </CODE>will automatically print items on separate pages   -- print formats must use the target variable to image the current   item. To print multiple items, set the format <CODE>usesCursors   </CODE>slot to <CODE>true </CODE>and use   <CODE>GetTargetCursor(target, nil)</CODE> to navigate through the   items.<BR>      <BR>      If either the format (the <CODE>usesCursors </CODE>slot) or the   transport (the <CODE>allowsBodyCursors </CODE>slot) does not   support cursors, the system will automatically split the items   into separate Out Box items.</P></DL><P><A NAME="When_to_Call_Inherited_ProtoPrintFormat_ViewSetupFormScript"></A></P><H3><HR>When to Call Inherited ProtoPrintFormat ViewSetupFormScript (1/6/97)</H3><DL>   <DD>Q: Does it matter when I call the inherited method in my   <CODE>protoPrintFormat:viewSetupFormScript()</CODE>?<BR>      <BR>      A: Yes, you must call the inherited method before doing anything   else in the <CODE>viewSetupFormScript</CODE>.<BR>      <BR>      Among other things, the inherited method sets up the page size.   After calling the inherited method, you can call   <CODE>self:LocalBox() </CODE>and get the correct page size. Note   that you cannot rely on the   <CODE>protoPrintFormat.viewBounds</CODE> slot value. To position   subviews within the print format centered or "full" width or   height, use view justifications like centered, right, and full, or   use <CODE>theEnclosingView:LocalBox()</CODE> to determine the   exact size of the enclosing view.</DL><P><A NAME="Limitations_with_NewtOverview_Data_Class"></A></P><H3><HR>Limitations with NewtOverview Data Class (1/8/97)</H3><DL>   <DD>Q: I want to use code like   <CODE>CreateTargetCursor('newtOverview, myItemArray) </CODE>in my   application to simplify my code which handles overviews. Why would   my print format throw an exception when I use this method?<BR>      <BR>      A: There are limitations to using the <CODE>'newtOverview</CODE>   symbol as your data class with <CODE>CreateTargetCursor</CODE>.   The biggest limitation is that it requires you to support exactly   the set of of datatypes: <CODE>['frame, 'text, 'view].</CODE> In   other words, you must register a <CODE>protoFrameFormat</CODE> (by   default, it handles <CODE>'frame</CODE> and <CODE>'text</CODE>   dataTypes) and a <CODE>protoPrintFormat</CODE>. However, there are   two other limitations not mentioned in the final documentation:   the system does not guarantee that it will call your print   format's <CODE>formatInitScript</CODE> method or a format's   <CODE>SetupItem</CODE> method.<BR>      <BR>      This means that if your print format's   <CODE>viewSetupFormScript</CODE> (or other code in the print   format) assumed that the <CODE>formatInitScript</CODE> has been   called, it could cause errors and/or exceptions. The workaround to   this would be to set a flag in the <CODE>formatInitScript</CODE>;   if it was not set at the beginning of   <CODE>viewSetupFormScript</CODE>, send your format the   <CODE>formatInitScript</CODE> message. Other problems could occur   with <CODE>SetupItem</CODE>, but you'd probably not see any errors   or exceptions until you tried to beam/mail a frame to another   device and then tried to Put Away the item.<BR>      <BR>      About the default overview class: when you use   <CODE>CreateTargetCursor</CODE> to prepare a "multiple item   target", you may be able to use this special   <CODE>'newtOverview</CODE> symbol as your data class. If your   application prints every item on separate pages (in other words,   not multiple items on one page) and you want to split beam and   mail items into separate items in the Out Box, this might be   useful to you. For more information, see the Newton Programmers   Guide (not reference) in the Routing chapter "Using the Built-in   Overview Data Class" section and the "Move It!" article in the   Newton Technology Journal 2.02. Also, check out the MultiRoute DTS   sample.</DL><P><A NAME="Beam_is_Partially_Available_for_Text_Routing"></A></P><H3><HR><B>NEW: </B>Beam is Partially Available for Text Routing (5/22/97)</H3><DL>   <DD>Q: My application doesn't support <CODE>'frame</CODE>   dataTypes. Why is Beam available in my Action picker in Newton 2.1   OS?<BR>      <BR>      A: The Beam transport in Newton 2.1 OS supports the   <CODE>'text</CODE> dataType. If any routing formats for your data   supports text export (a <CODE>format.dataTypes</CODE> array   includes <CODE>'text</CODE>), Beam will be available.   Unfortunately, there is a bug in current Newton 2.1 OS devices   such that Beam does not convert the target to text before sending   it. Transports that support sending text should use the   <CODE>kItemToTextFunc</CODE> function (in the Newton 2.x platform   files), and that function calls the format's   <CODE>TextScript</CODE> to convert the item to text. Since Beam   does not do this, this gives the appearance that the item is being   sent as <CODE>'frame</CODE>, a dataType that may not be supported   by your application's routing formats.<BR>      <BR>      There are several workarounds (with the first choice   recommended):<BR>      #1) Add support for the <CODE>'frame </CODE>datatype. In your   routing format, add <CODE>'frame</CODE> to the   <CODE>dataTypes</CODE> slot. This will allow all   <CODE>'frame</CODE> transports, including mail transports that can   send attachments, to send mail with your application. This will   allow your application to avoid text-specific bugs in Beam. For   the best user interface, we recommend that you write stationery   for your data so that users can view the item in the In Box or Out   Box. See the Newton Programmers Guide and Reference for more   information about writing and registering stationery. Note that   you can test your application with Put Away, using the built-in   Beam transport as well as the DTS sample "Archive Transport".<BR>      <BR>      #2) Provide a text-only format that converts the item to text in   the <CODE>format:SetupItem(...)</CODE> method. If you don't   support overviews or other mechanisms that use multiple item   targets, change <CODE>item.body</CODE> to be a new frame of the   form <CODE>{text: "the converted item to text", class:   'text}</CODE>. Note that this format should not also support the   <CODE>'frame</CODE> dataType because you are destructively   modifying the item.<BR>      <BR>      If you do support multiple item targets, you have to do more work   because the items are not split up into seperate items before your   <CODE>SetupItem</CODE> method is called. You can use the code like   the following in your <CODE>SetupItem</CODE> format after calling   the inherited method:<BR>      <BR>            <PRE><CODE>// get a 'cursor' to iterate over the items.// Note: this still returns a 'cursor' even if item.body wasn't reallocal cursor := GetTargetCursor(item.body, nil);local newArray := [];local entry := cursor:entry();while (entry) do    begin        // convert item to text in whatever way you normally do it...        // For instance, you might call your format's textscript...        entry := {            text: "blah blah" &amp;&amp; entry.a &amp;&amp; entry.b,            class: 'text            };         AddArraySlot(newArray, entry);        entry := cursor:Next();    end;        item.body := CreateTargetCursor(classof(item.body), newArray);&nbsp;// remember to return 'item' from SetupItemitem </CODE></PRE>      <P><CODE><BR>      </CODE>You might be wondering if you could route the   <CODE>'frame</CODE> data by hiding the data in extra slots in   <CODE>item.body</CODE>. If you did that, the item would be much   larger than necessary to route <CODE>'frame</CODE> data, and will   not be Put Away properly because the <CODE>'class</CODE> slot is   set to <CODE>'text</CODE>, not your original data class). If you   actually want to support <CODE>'text </CODE>and   <CODE>'frame</CODE> dataTypes, use a single   <CODE>protoFrameFormat</CODE> with dataTypes <CODE>['frame, 'text]   </CODE>and do not convert the <CODE>item.body</CODE> as   illustrated above. (This is actually recommendation #1 above).<BR>      <BR>      Note that <CODE>'text</CODE> stationery must be registered in   order to view the item in the In Box and Out Box. Such stationery   is not necessarily installed on the receiving device. Some mail   transport packages may have installed <CODE>'text</CODE>   stationery, but you may choose not to rely on this. If you are   interested in writing text stationery, see the DTS sample   "MinMail" and the Newton Programmers Guide and Reference for more   information about writing and registering stationery.<BR>      </P></DL><P><A NAME="Page_Sizes_Cannot_Be_Determined_Before_Printing_Begins"></A></P><H3><HR><B>NEW: </B>Page Sizes Cannot Be Determined Before Printing Begins(7/10/97)</H3><DL>   <DD>Q: How can my application or print format determine the exact   page size before the print job actually starts?<BR>      <BR>      A: There is currently no supported API to do this. You cannot rely   on a particular size for the actual printable area of the paper,   nor the actual printable area as viewed by your print format. This   is a limitation of the current Newton OS printing   architecture.<BR>      <BR>      The correct way for a print format to determine its size is for   the print format to call <CODE>:LocalBox()</CODE> in its   <CODE>viewSetupFormScript</CODE>,   <CODE>viewSetupChildrenScript</CODE>, or   <CODE>viewSetupDoneScript</CODE>. This is only accurate during the   current print job to the printer or fax driver. You cannot   determine this size during Print/Fax preview, nor during the print   format's <CODE>formatInitScript</CODE>, nor in your application's   on-screen views.<BR>      <BR>      The size of the print format is affected by many factors that can   change before the print job begins. Factors include, but are not   limited to, the printer driver, the printer/fax settings, and   whether a fax cover page is selected in the Fax routing slip. (The   least intuitive of these variables is the fax cover page, which   also controls the fax header strip at the top of the page --   affecting the height of the printable area.)<BR>      <BR>      A common question is whether the print format   <CODE>formatInitScript</CODE> can accurately determine the page   height. This special format method was designed to allow   time-intensive code to execute before the print job begins. For   instance, fax timeouts might be less likely if some data were   processed before fax connection. However, there is no supported   API to find the actual final printable area that you will have   when the system opens the print format view and sends the   <CODE>viewSetupFormScript</CODE> message. Although you may be   tempted to access undocumented slots which contain information   about printer and page settings, this is both unsupported and   results in unreliable bounds. (For instance, the undocumented fax   cover page information affects the printable area but it's not   stored in the printer nor page size structures.)<BR>      <BR>      On a related note, there are user configurations slots called   <CODE>paperSize</CODE> and <CODE>paperSizes</CODE>. You cannot use   these to reliably determine the printable area, nor can you create   new <CODE>paperSizes</CODE>. See the Newton Programmer's Reference   for more details.<BR>      <BR>      You could hard-code a specific size of "main view" within your   print format, but you do so at the risk of view clipping or other   cosmetic problems if the actual printable area is too small in   either dimension. For instance, you could determine a "lowest   common denominator" page size for many printer/fax combinations,   and then center a view of that size within the print format. You   may waste some vertical/horizontal space if the page is larger and   you still risk clipping the view if the printed page is smaller   than expected. If you took this approach, you might consider   registering multiple print formats that contained different page   size/layout assumptions. We do not recommend hard-coding a   specific page size, but it is appropriate for printing official   forms whose size and design must be copied excactly.<BR>      <BR>      We strongly recommend that most applications assume nothing about   page size before printing occurs. During printing, get the page   size by calling <CODE>:LocalBox()</CODE> in the print format   <CODE>viewSetupFormScript</CODE>,   <CODE>viewSetupChildrenScript</CODE>, or   <CODE>viewSetupDoneScript</CODE>. (Or, use the print format   <CODE>pageHeight</CODE> and <CODE>pageWidth</CODE> slots in   <CODE>viewSetupChildrenScript</CODE> or later.) Also, add new   child views with appropriate center/full/right/relative   justification to take advantage of varying page sizes. This will   allow your application to work with any paper size, in any   printer, and in any locale.</DL><P><A NAME="Not_All_Drawing_Modes_Work_with_a_PostScript_Printer"></A></P><H3><HR><B>CHANGED: </B>Not All Drawing Modes Work with a PostScript Printer(7/16/97)</H3><DL>   <DD>Q: It seems that not all drawing modes work with printing. Is   that true?<BR>      <BR>      A: Yes, at least this is true for PostScript printers. PostScript   behaves like layers of paint: you can not go back and change   something. Anything that uses an invert mode will not work.   Specifically, <CODE>modeXOR</CODE> and <CODE>modeNot</CODE> will   not work.<BR>      <BR>      If you want to get the effect of white text on a black/filled   background, use bit clear mode (<CODE>modeBic</CODE>) for drawing   the text.<BR>      <BR>      This does not affect non-PostScript print drivers, for instance,   Apple StyleWriter printers and Fax.</DL><H2>Sound</H2><P><A NAME="Finding_and_Adding_Alert_Sounds_"></A></P><H3><HR>Finding and Adding Alert Sounds (1/23/97)</H3><DL>   <DD>Q: Is there a way to add a new sound to the list of available   alert sounds?<BR>      <BR>      A: Yes. There is a registry API for alert sounds that is not   mentioned in the Newton 2.0 OS final documention. Alert sounds are   sound frames with an additional <CODE>userName</CODE> slot. This   slot contains a string that will show up in the alert sound   picker.<BR>      <BR>            <PRE><CODE>RegSound(soundSymbol, alertSoundFrame)</CODE></PRE>      <P><CODE><BR>      soundSymbol</CODE> - a unique symbol identifying the sound that   incorporates your signature<BR>      <CODE>alertSoundFrame</CODE> - see above<BR>      Registers the sound in <CODE>alertSoundFrame</CODE> with the alert   sound picker.<BR>      <CODE><BR>      </CODE><BR>      </P>      <PRE><CODE>UnRegSound(soundSymbol)</CODE></PRE>      <P><CODE><BR>      soundSymbol</CODE> - symbol of the sound to unregister<BR>      Unregisters the sound frame that was registered with the symbol   specified by <CODE>soundSymbol</CODE>.<BR>      <BR>      <BR>      </P>      <PRE><CODE>SoundList()</CODE></PRE>      <P><CODE><BR>      </CODE>Returns an array of currently registered alert sounds that   can be used to construct a popup menu. It returns an array of   frames, such that each frame is of the format: <CODE>{item:   soundName, soundSymbol: theSoundSymbol}</CODE><BR>      <BR>      <BR>      </P>      <PRE><CODE>GetRegisteredSound(soundSymbol)</CODE></PRE>      <P><CODE><BR>      soundSymbol</CODE> - symbol of the sound to return<BR>      Returns a sound frame that can be passed to the sound playing   functions (for example, the global function   <CODE>PlaySound</CODE>). <CODE>soundSymbol</CODE> is the symbol   used to register the sound.<BR>      </P></DL><H2>Stationery</H2><P><A NAME="Limits_on_Stationery_Popups"></A></P><H3><HR>Limits on Stationery Popups (4/30/96)</H3><DL>   <DD>Q: If I add stationery to Notes, Names, or my application and   it is off the bottom of the popup in the new button, I am unable   to scroll to it in the stationery popup. Why?<BR>      <BR>      A: There is a problem in the MessagePad 120 and 130 with Newton   2.0 OS constructing popups that contain icons. See the "Picker   List is Too Short " Q&amp;A in the Pickers, Popups and Overviews   section.</DL><P><A NAME="Dynamically_Changing_the_Height_of_Stationery"></A></P><H3><HR>Dynamically Changing the Height of Stationery (11/19/96)</H3><DL>   <DD>Q: How can I dynamically change the height of my roll-style   stationery?<BR>      <BR>      A: To dynamically change the height of roll-style stationery you   will need to change the target's <CODE>height</CODE> slot, flush   the data, and then do a re-target. For instance, you might have   the following method in your stationery:<BR>      <BR>            <PRE><CODE>    DoResize: func( newHeight )    begin        target.height := newHeight;        :FlushData();        :DoRetarget();</CODE></PRE>      <P><CODE><BR>      end;</CODE><BR>      </P></DL><P><A NAME="Properly_Registering_a_ViewDef"></A></P><H3><HR>Properly Registering a ViewDef (1/3/97)</H3><DL>   <DD>Q: When I add a viewDef using <CODE>RegisterViewDef</CODE> on   Newton 2.0 OS, I get the "grip of death" alert ("The package   'MyApp' still needs the card you removed...") when the card the   viewDef is on is removed. I don't get the grip of death alert when   using Newton 2.1 OS. How can I keep the grip of death alert from   appearing?<BR>      <BR>      A: In Newton 2.0 OS, you must <CODE>EnsureInternal</CODE> the   second argument to the <CODE>RegisterViewDef</CODE> global   function. The <CODE>RegisterViewDef</CODE> global function was   changed in Newton 2.1 OS to automatically   <CODE>EnsureInternal</CODE> the second argument.<BR>      <BR>      Note: <CODE>EnsureInternal</CODE>-ing something that has been   <CODE>EnsureInternal</CODE>-ed is a very fast operation so you   don't need to worry about checking which platform you are running   on.</DL><H2>System Services, Find, and Filing</H2><P><A NAME="Preventing_Selections_in_the_Find_Overview"></A></P><H3><HR>Preventing Selections in the Find Overview (2/5/96)</H3><DL>   <DD>Q: When I use <CODE>ROM_compatibleFinder </CODE>in Newton 2.0,   the overview of found items contains checkboxes for each item,   allowing the user to attempt to route the found items. Since my   found items are not soup items, various exceptions are thrown. How   can I prevent the checkboxes?<BR>      <BR>      A: What you do depends on how you want to handle your data. There   are basically two cases. The first case is when you want no   Routing to take place (Routing refers to Delete, Duplicate, and   the ability to move the data using transports like Beam or Print).   The second case is when you want some or all of the Routing to   occur.<BR>      <BR>      The first case is easy. Just add a <CODE>SelectItem </CODE>slot to   the result frame, set to <CODE>nil</CODE>.<BR>      For example:<BR>            <PRE><CODE>    AddArraySlot(results,           {_proto: ROM_compatibleFinder,            owner: self,            title: mytitle,            SelectItem: nil,   // prevents checkboxes            items: myresults});&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>The second case is more complex. The problem is that there   are many variants. The best strategy is to override the   appropriate methods in your finder to gain control at appropriate   points. This may be as simple of overriding <CODE>Delete </CODE>to   behave correctly, or as complex as replacing <CODE>GetTarget   </CODE>and adding appropriate layouts. See the Newton DTS Q&amp;A   "Creating Custom Finders" for more information.</P></DL><P><A NAME="Creating_Custom_Finders"></A></P><H3><HR>Creating Custom Finders (2/5/96)</H3><DL>   <DD>Q: My application uses more than one soup, so   <CODE>ROM_soupFinder </CODE>is not appropriate, but   <CODE>ROM_compatibleFinder </CODE>seems to throw many exceptions.   Which should I use?<BR>      <BR>      A: The answer depends on how much modification you will make. What   you need is documentation on how they work and what you can   override:<BR>      <BR>      Each of the finder base protos (soupFinder and compatibleFinder)   are magic pointers, so can create your own customizations at   compile time.<BR>      <BR>      So to do a <CODE>soupFinder</CODE> based item you could do   something like:<BR>      <BR>            <PRE><CODE>DefConst('kMySoupFinder, {    _proto: ROM_soupFinder,&nbsp;    Delete: func()    begin        print("About to delete " &amp; Length(selected) &amp;&amp; "items") ;        inherited:Delete() ;    end,}) ;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Most of these routines are only callable by your code. They should   not be overwritten. Those routines that can be safely overriden   are specified.<BR>      <BR>      Some of methods and slots are common to both types of finders:<BR>      <BR>      </P>      <PRE><CODE>finder.selected</CODE></PRE>      <P><CODE><BR>      </CODE>An array of selected items stored in an internal format.   All you can do with this array is figure out the number of   selected items by taking the Length of this array.<BR>      <BR>      </P>      <PRE><CODE>finder:Count()</CODE></PRE>      <P><CODE><BR>      </CODE>Returns an integer with the total number of found   items.<BR>      <BR>      </P>      <PRE><CODE>finder:ReSync()</CODE></PRE>      <P><CODE><BR>      </CODE>Resets the finder to the first item.<BR>      <BR>      </P>      <PRE><CODE>finder:ShowFoundItem(item)</CODE></PRE>      <P><CODE><BR>      </CODE>Displays the item passed. item is an overview item that   resides in the<BR>      overview's items array.<BR>      <BR>      </P>      <PRE><CODE>finder:ShowOrdinalItem(ordinal)</CODE></PRE>      <P><CODE><BR>      </CODE>Display an item based on the symbol or integer passed in   ordinal:<BR>      <CODE>'first </CODE>- the first found item<BR>      <CODE>'prev </CODE>- the previous item<BR>      <CODE>'next </CODE>- the next item<BR>      <CODE>&lt;an-integer&gt;</CODE> - display the nth item based on   the integer.<BR>      <BR>      Under no circumstances should you call or override:<BR>      </P>      <PRE><CODE>        finder:MakeFoundItem</CODE></PRE>      <P><CODE><BR>      </CODE></P>      <PRE><CODE>        finder:AddFoundItems</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      <B>ROM_SoupFinder<BR>      </B><BR>      SoupFinder has the following methods and slots:<BR>      <BR>      All the documented items from the simple use of soupFinder as   documented in the Newton Programmer's Guide 2.0.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:Reset()</CODE></PRE>      <P><CODE><BR>      </CODE>Resets the soupFinder cursor to the first found entry. In   general, you<BR>      should use the ReSync method to reset a finder.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:ZeroOneOrMore()</CODE></PRE>      <P><CODE><BR>      </CODE>Returns 0 if no found entries, 1 if one found entry or   another number<BR>      for more than one entry.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:ShowEntry(entry)</CODE></PRE>      <P><CODE><BR>      </CODE>causes the finding application to display entry. This may   involve<BR>      opening the application and moving it to that item.<BR>      This does not close the findOverview.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:SelectItem(item)</CODE></PRE>      <P><CODE><BR>      </CODE>mark the item as selected.<BR>      If this method is set to <CODE>nil </CODE>in the soupFinder proto,   items will not have a checkbox in front of them (not   selectable).<BR>      <BR>      </P>      <PRE><CODE>soupFinder:IsSelected(item)</CODE></PRE>      <P><CODE><BR>      </CODE>Returns true if the item is selected.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:ForEachSelected(callback)</CODE></PRE>      <P><CODE><BR>      </CODE>Calls callback function with each selected item. The   callback function has one argument, the entry from the soup   cursor.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:FileAndMove(labelsChanged, newLabel,storeChanged, newStore)</CODE></PRE>      <P><CODE><BR>      </CODE>File and/or move the selected items.<BR>      <CODE>newLabel </CODE>is the new label if and only if   <CODE>labelsChanged </CODE>is <CODE>true.<BR>      newStore </CODE>is the new store if and only if <CODE>storeChanged   </CODE>is <CODE>true.<BR>      </CODE><BR>      Developers can override this, though they may want to call the   inherited routine to do that actual work. Note that   <CODE>FileAndMove </CODE>can be called even if no items are   selected. If you override this method you MUST check if there are   selected items by doing:<BR>      <BR>      </P>      <PRE><CODE>    if selected then        // do the work</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      </P>      <PRE><CODE>soupFinder:FileAs(labels)</CODE></PRE>      <P><CODE><BR>      </CODE>Deprecated. Do not use.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:MoveTo(newStore)</CODE></PRE>      <P><CODE><BR>      </CODE>Deprecated. Do not use.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:Delete()</CODE></PRE>      <P><CODE><BR>      </CODE>Deletes all selected items from read/write stores.<BR>      <BR>      Developer can override. Note: if you override this, the crumple   effect will<BR>      still happen. There is no way to prevent the ability to delete the   items or<BR>      prevent the crumple effect at this time.<BR>      <BR>      </P>      <PRE><CODE>soupFinder:GetTarget()</CODE></PRE>      <P><CODE><BR>      </CODE>Returns a cursor used by routing.<BR>      <BR>      The following methods should not be called or modified:<BR>      </P>      <PRE><CODE>    soupFinder.MakeFoundItemsoupFinder.AddFoundItems</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      <B>ROM_CompatibleFinder<BR>      </B><BR>      </P>      <PRE><CODE>compatibleFinder:ShowFakeEntry(index)</CODE></PRE>      <P><CODE><BR>      </CODE>Show the <CODE>index</CODE>'th item from the found items.   Note that items will likely be an array of the found items.<BR>      <BR>      <CODE>ShowFakeEntry </CODE>should behave just like   <CODE>ShowFoundItem</CODE>. In other words, it should open the   application then send a <CODE>ShowFoundItem </CODE>to the   application.<BR>      <BR>      </P>      <PRE><CODE>compatibleFinder:ConvertToSoupEntry(item)</CODE></PRE>      <P><CODE><BR>      </CODE>Return a soup entry that corresponds to the item. item is   an item from the found items array.<BR>      <BR>      The following methods are defined to be the same as the   soupFinder:<BR>      </P>      <PRE><CODE>        FileAs, MoveTo, Delete, IsSelected, SelectItem,    ForEachSelected, GetTarget, FileAndMove</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Note that this causes problems in some cases: most notably, the   <CODE>ForEachSelected </CODE>call is expected to return an array   of soup entries. The chances are you will need to override most of   those methods. See <CODE>soupFinder </CODE>for a description of   what the methods are supposed to do.</P></DL><P><A NAME="How_to_Interpret_Return_Value_of_BatteryStatus"></A></P><H3><HR>How to Interpret Return Value of BatteryStatus (5/6/96)</H3><DL>   <DD>Q: I am trying to determine whether the Newton device is   plugged in and to obtain other battery status information. Many   slots have a <CODE>nil </CODE>value in the frame returned by the   <CODE>BatteryStatus </CODE>global function. How do I interpret   these values?<BR>      <BR>      A: A value of <CODE>nil </CODE>is returned if the underlying   hardware cannot determine the correct information. Some hardware   is limited in the amount of information that it can return. Future   hardware may fill in more slots with authoritative non-nil   values.<BR>   </DL><P><A NAME="How_to_Create_Application-specific_Folders"></A></P><H3><HR>How to Create Application-specific Folders (5/14/96)</H3><DL>   <DD>Q: I would like to programmatically create folders so that   they are available as soon as the application is open. What is the   best approach to add application-specific folders?<BR>      <BR>      A: You can use the global functions <CODE>AddFolder</CODE> and   <CODE>RemoveFolder</CODE> to modify the folder set for a given   application.<BR>      <BR>            <PRE><CODE>AddFolder(newFolderStr, appSymbol)</CODE></PRE>      <P><CODE><BR>      newFolderStr </CODE>- string, the name of the new folder<BR>      <CODE>appSymbol </CODE>- symbol, application for local folder<BR>      <CODE>result </CODE>- symbol, the folder symbol of the newly added   folder.<BR>      <BR>      <CODE>AddFolder</CODE> takes a folder name and creates a new   folder for the application.<BR>      <BR>      <CODE>AddFolder</CODE> returns the symbol representing the tag   value for the new folder. Please note that the symbol may be   different from the value returned by using <CODE>Intern()</CODE>   on the string. In particular, folder names with non-ASCII folders   are supported. If a folder with the name already exists, the   symbol for the pre-existing folder is returned and a new folder is   not created.<BR>      <BR>      There is a limit on the number of unique folders an application   can support. If the limit is exceeded, <CODE>AddFolder</CODE>   returns <CODE>NIL</CODE> and a new folder is not added. With the   Newton 2.0 OS, the current limit is twelve global folders and   twelve local folders.<BR>      <BR>      </P>      <PRE><CODE>RemoveFolder(folderSym, appSymbol)</CODE></PRE>      <P><CODE><BR>      folderSym </CODE>- symbol, the folder symbol of the folder to   remove<BR>      <CODE>appSymbol </CODE>- symbol, the application for which to   remove the folder<BR>      <CODE>result </CODE>- undefined; do not rely on the return value   of this function.<BR>      <BR>      <CODE>RemoveFolder</CODE> can be used to remove a folder from the   available list for an application. If items exist in a folder that   is removed, the only way users can see the items is by selecting   "All Items" from the folder list.<BR>      </P></DL><P><A NAME="Changing_ProtoStatusButton_Text_in_ProtoStatusTemplate"></A></P><H3><HR>Changing ProtoStatusButton Text in ProtoStatusTemplate (1/15/97)</H3><DL>   <DD>Q: I am using a <CODE>protoStatusTemplate</CODE>-based view   and am trying to rename the primary button through the   <CODE>protoStatusTemplate</CODE>'s setup frame. After doing this,   I get an exception when I tap on the renamed button. What am I   doing wrong?<BR>      <BR>      A: You are not doing anything wrong. There is a bug in   <CODE>protoStatusTemplate</CODE> which will cause the primary   button to function incorrectly if you do not include a   <CODE>buttonClickScript</CODE> in the setup frame.<BR>      <BR>      When you specify a frame in the <CODE>primary</CODE> slot of the   values frame of the setup, the primary button uses the   <CODE>text</CODE> slot and the <CODE>buttonClickScript</CODE> slot   of that frame to initalize itself. Unfortunately, it does not   check to see if either of those slots exist before trying to use   them. The result is that an exception is thrown when you tap the   button.<BR>      <BR>      To work around this bug you must add a   <CODE>buttonClickScript</CODE> to the primary frame. From that   method you will typically call your base view's   <CODE>CancelRequest</CODE> method.<BR>      <BR>      Here is a code example:<BR>      <BR>            <PRE><CODE>// Add a buttonClickScript method which just calls the application's CancelRequest method.local viewSetValues :=  {    primary:         {        text: "Stop",         buttonClickScript: func() GetRoot().(kAppSymbol):CancelRequest('userCancel)        }    };                    local viewSet := {        appSymbol: kAppSymbol,         name: "The Name",         values: viewSetValues        };            // Setup the status templatestatusView:ViewSet( viewSet );</CODE></PRE></DL><H2>Text and Ink Input and Display</H2><P><A NAME="ProtoPhoneExpando_Bug_in_Setup1_Method"></A></P><H3><HR>ProtoPhoneExpando Bug in Setup1 Method (2/6/96)</H3><DL>   <DD>Q: I am having a problem using <CODE>protoPhoneExpando   </CODE>under Newton 2.0 OS. Something is going wrong in the   <CODE>setup1 </CODE>method. Is this a known bug?<BR>      <BR>      A: Yes, this is a known bug. <CODE>protoPhoneExpando</CODE> (and   the entire expando user interface) have been deprecated in the   Newton 2.0 OS, and are only supported for backward compatibility.   If possible, you should redesign your application to avoid the   expandos.<BR>      <BR>      The problem seems to be that the expando shell is sending the   <CODE>setup1 </CODE>and <CODE>setup2 </CODE>messages to the   template in the <CODE>lines </CODE>array. These methods in   <CODE>protoPhoneExpando </CODE>rely on information that isn't   created until the view is actually opened.<BR>      <BR>      We're investigating solutions to this problem. You can usually   hack around the problem by placing a <CODE>labelCommands   </CODE>slot in the template which has an array of one element,   that element being the label you want to appear in the phone line.   For example: <CODE>labelCommands: ["phone"]</CODE>.<BR>      <BR>      This hack works only if your <CODE>protoPhoneExpando   </CODE>doesn't use the <CODE>phoneIndex </CODE>feature. If it   does, you'll have problems that are harder to work around.</DL><P><A NAME="Pictures_in_clEditViews"></A></P><H3><HR>Pictures in clEditViews (2/6/96)</H3><DL>   <DD>Q: Is there a API or procedure that allows an application to   write objects such as shapes, PICTs, or bitmaps to a note in the   Notes application?<BR>      <BR>      A: There is no API for Notes specifically. The Notes "Note" view   is basically a plain old <CODE>clEditView</CODE>, and   <CODE>clEditViews </CODE>can contain pictures (in addition to ink,   polygons, and text) in the Newton 2.0 OS.<BR>      <BR>      The Newton Programmer's Guide 2.0 (in the "Built-In Applications   and System Data" chapter) contains a description of the types of   children you can create in the Notes application.<BR>      <BR>      This is really a description of the frames you need to put in the   <CODE>'viewChildren</CODE> slot of a <CODE>clEditView</CODE> to   create editable items. <CODE>'para</CODE> templates are text and   ink text, <CODE>'poly</CODE> templates are drawings and sketch   ink, and <CODE>'pict</CODE> templates are images.<BR>      <BR>      To add a picture to a <CODE>clEditView</CODE>, you need to create   an appropriate template and then add it to the   <CODE>viewChildren</CODE> array (and open the view or call   <CODE>RedoChildren</CODE>) or use the <CODE>AddView</CODE> method   to add it to an existing view (then <CODE>Dirty</CODE> the view.)   See the item "Adding Editable Text to a clEditView" elsewhere in   the Q&amp;As for details.<BR>      <BR>      The template for <CODE>'pict</CODE> items needs to contain these   slots:<BR>      <CODE>viewStationery</CODE>: Must have the symbol<CODE> 'pict<BR>      viewBounds</CODE>: A bounds frame, like   <CODE>RelBounds(0,0,40,40)<BR>      icon</CODE>: A bitmap frame, see <CODE>clPictureView</CODE>   docs<BR>      <BR>      For other slots, see the documentation for the <CODE>clPictureView   </CODE>view class.</DL><P><A NAME="Horizontal_Scrolling,_Clipping,_and_Text_Views"></A></P><H3><HR>Horizontal Scrolling, Clipping, and Text Views (2/7/96)</H3><DL>   <DD>Q: I want to draw 80 columns in a <CODE>clParagraphView</CODE>   that's inside a smaller view and be able to scroll back and forth.   When I try this, it always wraps at the bounds of the parent. How   can I create a horizontal scrolling text view?<BR>      <BR>      A: Normal paragraph views are written so that their right edge   will never go beyond their parent. This is done to avoid the   circumstance where a user could select and delete some text from   the left part of a paragraph in a <CODE>clEditView</CODE>, leaving   the rest of it off screen and unselectable.<BR>      <BR>      What happens is the <CODE>viewBounds </CODE>of the   <CODE>clParagraphView</CODE> are modified during creation of the   view so that the view's right edge is aligned with the parent's   right edge. After that, wrapping is automatic.<BR>      <BR>      The so-called "lightweight" text views do not work this way. You   can force a paragraph to be lightweight by: 1) Making sure the   <CODE>viewFlag</CODE> <CODE>vReadOnly</CODE> is set, 2) making   sure <CODE>vCalculateBounds</CODE> and   <CODE>vGesturesAllowed</CODE>, are off, and 3) not using   <CODE>tabs</CODE> or <CODE>styles</CODE>. Lightweight text views   are not editable, but you can use <CODE>SetValue</CODE> to change   their <CODE>text</CODE> slots dynamically.<BR>      <BR>      If you must use an editable <CODE>clParagraphView</CODE> or if   tabs or styles are required, there is another workaround. The code   to check for clipping only looks one or two levels up the parent   chain, so you could nest the paragraph in a couple of otherwise   useless views which were large enough to prevent clipping, and let   the clipping happen several layers up the parent chain.<BR>   </DL><P><A NAME="How_to_Intercept_Keyboard_Events"></A></P><H3><HR>How to Intercept Keyboard Events (5/6/96)</H3><DL>   <DD>Q: How do I intercept hardware keyboard events or "soft"   keyboard events?<BR>      <BR>      A: You can implement view methods that are called whenever the   user presses a key on software or external (hardware) keyboards..   There are two keyboard-related methods associated with views based   on the <CODE>clParagraphView </CODE>view class:<BR>      the <CODE>viewKeyDownScript </CODE>message is sent when a key is   pressed.<BR>      the <CODE>viewKeyUpScript </CODE>message is sent when a key is   released.<BR>      <BR>      Both methods receive two arguments: the character that was pressed   on the keyboard and a keyboard flags integer. The keyboard flags   integer encodes which modifier keys were in effect for the key   event, the unmodified key value, and the keycode. The layout of   the keyboard flags integer is shown in the section below,   "Keyboard Flags Integer". The modifier key constants are shown in   the section "Keyboard Modifier Keys".<BR>      <BR>      <CODE>ViewKeyUpScript </CODE>and <CODE>ViewKeyDownScript   </CODE>are currently called using parent inheritance. Do not rely   on this behavior: it may change in future ROMs.<BR>      <BR>      If you want the default action to occur, these method must return   <CODE>nil</CODE>. The default action for <CODE>ViewKeyDownScript   </CODE>is usually to insert the character into the paragraph.   (There may be other default actions in the future.) If you return   a non-nil value, the default action will not occur.<BR>      <BR>      You must include the <CODE>vSingleKeyStrokes </CODE>flag in the   <CODE>textFlags </CODE>slot of your view for the system to send   the <CODE>ViewKeyDownScript </CODE>or <CODE>ViewKeyUpScript   </CODE>message for every key stroke. If you do not specify   <CODE>vSingleKeyStrokes</CODE>, keyboard input may be dropped if a   lot of key strokes are coming in.<BR>      <BR>      The hard keyboard auto repeats with the following event   sequence:<BR>      <BR>      keydown -- keydown -- keydown -- keydown...<BR>      <BR>      The soft keyboard auto repeats with this sequence:<BR>      <BR>      keydown -- keyup -- keydown -- keyup -- keydown -- keyup...<BR>      <BR>      Do not rely on this order, it may change in future ROMs.<BR>      <BR>      <B>ViewKeyDownScript<BR>      </B><BR>            <PRE><CODE>    ViewKeyDownScript(char, flags)</CODE></PRE>      <P><CODE><BR>      </CODE>This message is sent to the key view when the user presses   down on a keyboard key. This applies to a hardware keyboard or an   on-screen keyboard.<BR>      <BR>      <CODE>char</CODE> The character that was entered on the keyboard.   Note that if a modifier key is the only key pressed (for example,   the Shift key), this value will be 0.<BR>      <BR>      <CODE>flags</CODE> An integer that specifies which modifier keys   were pressed, the unmodified key value, and the keycode. The   modifier key constants are shown in the section "Keyboard Modifier   Keys".<BR>      <BR>      <BR>      <B>ViewKeyUpScript<BR>      </B><BR>      </P>      <PRE><CODE>    ViewKeyUpScript(char, flags)</CODE></PRE>      <P><CODE><BR>      </CODE>This message is sent to the key view whenever the user   releases a keyboard key that was depressed. This applies to a   hardware keyboard or an on-screen keyboard.<BR>      <BR>      <CODE>char</CODE> The character that was entered on the keyboard.   Note that if a modifier key is the only key pressed (for example,   the Shift key), this value will be 0.<BR>      <BR>      <CODE>flags</CODE> An integer that specifies which modifier keys   were pressed, the unmodified key value, and the keycode. The   modifier key constants are shown in the section "Keyboard Modifier   Keys".<BR>      <BR>      <B>Keyboard Flags Integer<BR>      </B><BR>      Bits Description<BR>      0 to 7 The keycode.<BR>      8 to 23 Original keycode. The 16-bit character that would result   if none of the<BR>      modifier keys were pressed.<BR>      24 Indicates that the key was from an on-screen keyboard.   (kIsSoftKeyboard)<BR>      25 Indicates that the Command key was in effect.   (kCommandModifier)<BR>      26 Indicates that the Shift key was in effect.   (kShiftModifier)<BR>      27 Indicates that the Caps Lock key was in effect.   (kCapsLockModifier)<BR>      28 Indicates that the Option key was in effect.   (kOptionsModifier)<BR>      29 Indicates that the Control key was in effect.   (kControlModifier)<BR>      <BR>      <BR>      <B>Keyboard Modifier Keys<BR>      </B><BR>      You use the keyboard modifier key constants to determine which   modifier keys were in effect when a keyboard event occurs.<BR>      Constant Value<BR>      <CODE>kIsSoftKeyboard</CODE> (1 &lt;&lt; 24)<BR>      <CODE>kCommandModifier</CODE> (1 &lt;&lt; 25)<BR>      <CODE>kShiftModifier</CODE> (1 &lt;&lt; 26)<BR>      <CODE>kCapsLockModifier</CODE> (1 &lt;&lt; 27)<BR>      <CODE>kOptionsModifier</CODE> (1 &lt;&lt; 28)<BR>      <CODE>kControlModifier</CODE> (1 &lt;&lt; 29)</P></DL><P><A NAME="How_to_Keep_Multiple_Keyboards_Open"></A></P><H3><HR>How to Keep Multiple Keyboards Open (8/30/96)</H3><DL>   <DD>Q: I want my <CODE>protoKeyboard</CODE>-based keyboard to be   open at the same time as other keyboards. When my keyboard opens,   it seems like any other keyboard closes. How do I keep multiple   keyboards open?<BR>      <BR>      A: When a <CODE>protoKeyboard</CODE>-based view opens, it closes   the last-opened <CODE>protoKeyboard</CODE>-based view. However,   you need not use <CODE>protoKeyboard</CODE>.<BR>      <BR>      Instead, you can base your keyboard on a different view type (for   instance, <CODE>protoDragger</CODE>) and use the   <CODE>RegisterOpenKeyboard</CODE> view message to register the   keyboard with the system. Using <CODE>RegisterOpenKeyboard</CODE>   will ensure that the caret is set up properly and allows you to   track the caret changes with the   <CODE>viewCaretChangedScript</CODE> view message if desired.<BR>   </DL><P><A NAME="Adding_a_Local_Keyboard_to_a_ProtoKeyboardButton-based_Button"></A></P><H3><HR>Adding a Local Keyboard to a ProtoKeyboardButton-based Button(1/14/97)</H3><DL>   <DD>Q: I have an application-specific keyboard that I would like   to have appear only in my application's   <CODE>protoKeyboardButton</CODE>-based keyboard list. Is this   possible?<BR>      <BR>      A: Yes, <CODE>protoKeyboardButton</CODE> has a method called   <CODE>SetKeyboardList</CODE> that lets you do this.   <CODE>SetKeyboardList</CODE> takes two arguments. The first   argument is an array of keyboard symbols to add to the list. The   second argument is an array of keyboard symbols to remove from the   list. Note that the keyboard symbols of the built-in keyboards are   listed on pages pages 8-26 and 8-27 of the Newton Programmer's   Guide.<BR>      <BR>      To create a local keyboard, your keyboard view must be declared   either to the keyboard button view or to a view within in its   parent view chain. It is common to declare the keyboard view in   your application's base view. When you declare the keyboard view,   it must be declared using the keyboard's   <CODE>keyboardSymbol</CODE>.<BR>      <BR>      There are three additional slots that your keyboard template must   have:<BR>      1) a <CODE>preallocatedContext</CODE> slot with the symbol of the   keyboard<BR>      2) a <CODE>userName</CODE> slot with the name that will appear in   the <CODE>protoKeyboardButton</CODE> popup<BR>      3) a <CODE>keyboardSymbol</CODE> slot with your keyboard's   symbol<BR>      <BR>      The <CODE>preallocatedContext</CODE> slot and the   <CODE>keyboardSymbol</CODE> slot must be the same symbol. Note   that the <CODE>keyboardSymbol</CODE> slot is required, but the   <CODE>preallocatedContext</CODE> slot is additionally necessary to   avoid exceptions on devices prior to Newton 2.1 OS.<BR>      <BR>      Next, in the <CODE>viewSetupDoneScript</CODE> of the   <CODE>protoKeyboardButton</CODE>-based view, send the button a   <CODE>SetKeyboardList</CODE> message with your keyboard's symbol.   For instance, you might have the following   <CODE>viewSetupDoneScript</CODE>:<BR>      <BR>            <PRE><CODE>viewSetupDoneScript: func()    begin        :SetKeyboardList( [kMyKeyboardSymbol], nil );&nbsp;        // Be sure to call the inherited viewSetupDoneScript method!        inherited:?viewSetupDoneScript();</CODE></PRE>      <P><CODE><BR>      end;</CODE><BR>      <BR>      If you want to dynamically change the keyboard list, you can also   override the <CODE>buttonClickScript</CODE>. You must first call   <CODE>SetKeyboardList</CODE>, then call the inherited   <CODE>buttonClickScript</CODE>.<BR>      <BR>      All additions and subtractions are removed from the list when your   <CODE>protoKeyboardButton</CODE>-based view is closed.</P></DL><P><A NAME="Getting_Digital_Ink_to_the_Desktop"></A></P><H3><HR>Getting Digital Ink to the Desktop (1/17/97)</H3><DL>   <DD>Q: I want to get ink (for instance, a signature) from my   Newton device to a desktop machine. How do I do that?<BR>      <BR>      A: The easiest way to get digital ink to the desktop is to convert   it into a bitmap on the Newton device, and send the bitmap up to   the desktop via the Desktop Integration Libraries (DILs). Another   common technique is to convert the ink into an array of (x,y)   points and send that array to the desktop for it to convert into   whatever format is suitable.<BR>      <BR>      Take a look at the DTS Sample Code projects, "InkForm" and   "InkTranslate". They offer some pointers on how to do this.   Depending on how and when you want to do the translation, you'll   either want to use the view method <CODE>ViewIntoBitmap</CODE>, or   the global function <CODE>GetPointsArray</CODE>, or a set of   functions from the Recognition chapter, particularly   <CODE>GetStroke</CODE> and <CODE>GetStrokePointsArray</CODE>.<BR>      <BR>      If you need DIL sample code, the DTS Sample Code project   "SoupDrink" may be helpful to you.</DL><P><A NAME="Constraints_on_Keyboards_Sizing_to_the_View"></A></P><H3><HR>Constraints on Keyboards Sizing to the View (4/7/97)</H3><DL>   <DD>Q: I am having a problem with dynamically adjusting the size   of keyboards. According to the documentation, adjusting the size   of my keyboard view should cause the keys to size correctly to the   bounds of the view. This does not happen. If I set the viewbounds   of the keyboard (a full alphanumeric keyboard) to anything less   than 224x80, the keys scrunch up only taking up about half the   view (horizontally). They seem to size fine vertically. This   happens even if I set the viewbounds to 222 (only 2 pixels   shorter.) What is going on?<BR>      <BR>      A: It turns out the the documentation does not give the full   story. The final size of the keys in a keyboard is constrained by   the smallest fractional key unit width you specify in the   keyboard. To understand key units and key dimensions, read the   "Key Dimensions" section of the Newton Programmer's Guide (pages   8-35,6). You can also find this information in the "Key Descriptor   Constants" section of the Newton Programmer's Reference.<BR>      <BR>      In addition to calculating the size (in key units) of the longest   key row, the <CODE>clKeyboardView</CODE> also finds the smallest   key unit specified in the keyboard and uses this to constrain the   final horizontal size. It calculates a minimal pixel size for the   keyboard and makes sure that the final keyboard size is an   integral multiple of this value. For example, if the smallest size   is 10 pixels, then the final keyboard can be 10 pixels or 20   pixels, but not 15 pixels. If the view is 15 pixels, the keyboard   will be 10 pixels.<BR>      <BR>      The calculation for this minimal size is:<BR>            <PRE><CODE>    m = w * (1/s)</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      </P>      <PRE><CODE>m - minimal sizew - width of the longest keyboard row in key unitss   - numeric equivelent for smallest keyboard unit specified in the keyboard:    (keyHUnit = 1,  keyHHalf = 0.5, keyHQuarter = 0.25, keyHEighth = 0.125)</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      For the built-in ASCII keyboard in current ROMs, the longest row   is 14 key units, the smallest key unit used is   <CODE>keyHQuarter</CODE>, so the minimal width for the ASCII   keyboard is:<BR>      <BR>      </P>      <PRE><CODE>    m = 14 * (1 / 0.25) = 14 * 4 = 56 pixels.</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The keyboard will always be an integral multiple of 56 pixels in   width. Note that 224 pixels is exactly 4 * 56. By changing the   width to 223, the keyboard now becomes 168 pixels wide.</P></DL><P><A NAME="Using_a_Keyboard_Equivalent_to_Close_a_Subview"></A></P><H3><HR><B>NEW: </B>Using a Keyboard Equivalent to Close a Subview (5/12/97)</H3><DL>   <DD>Q: In my application, I have a linked subview that is linked   to a floater view. If I open that linked subview, then use a key   command to close the view (on current devices, command-W), my   application closes instead of the floater. How do I make the   floater respond to a "close" key command?<BR>      <BR>      A: There is a very subtle implementation detail of key-closing a   view that is causing your problem. If you close a view using the   keyboard, the following algorithm is used.<BR>      <BR>      The children of each view, starting at the root view, are searched   in reverse order for a close box.<BR>      <BR>      The order of your base view's children can affect which view is   first closed. If your close box or status bar child is after the   linked layout child, then your application will be closed instead   of the linked layout. If your close box or status bar child is   before the linked layout child, then the linked layout will be   closed first.<BR>      <BR>      You can override this behavior by adding a   <CODE>_DoCloseButton</CODE> method to your application's base   view. The <CODE>_DoCloseButton</CODE> method is called when a   keyboard equivalent is used to close a view. This method takes no   arguments and must return <CODE>true</CODE> if you handled the   close, or return <CODE>nil</CODE> to let the system continue to   search for a close box in other applications.<BR>      <BR>      Alternately, instead of creating your child as a linked subview,   you could create it using the global function   <CODE>BuildContext</CODE>. This guarantees that it will be   searched for a close box before your application is searched.</DL><P><A NAME="Finding_a_KeyCommand_by_KeyMessage"></A></P><H3><HR><B>NEW: </B>Finding a KeyCommand by KeyMessage (6/16/97)</H3><DL>   <DD>Q: How do I find a <CODE>keyCommand</CODE> if all I have is   the <CODE>keyMessage</CODE> symbol?<BR>      <BR>      A: There is a global function called <CODE>MatchKeyMessage</CODE>   that will do what you want. However, the documentation was   inadvertently left out of the current version of the Newton   Programmers Guide for Newton 2.1 OS. The documentation should   be:<BR>            <PRE><CODE>    MatchKeyMessage(startView, keyMessage)</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Finds the <CODE>keyCommand</CODE> frame for the specified message   starting with the specified view.<BR>      <BR>      <CODE>startView</CODE> - The view from which to start searching   for the message<BR>      <CODE>keyMessage</CODE> - A symbol for the command message that   will be searched for. This must be the same message that is   specified in the <CODE>keyMessage</CODE> slot of the   <CODE>keyCommand</CODE> frame<BR>      <BR>      return value - Either <CODE>nil</CODE> or a   <CODE>keyCommand</CODE> frame<BR>      <BR>      The <CODE>MatchKeyMessage</CODE> function searches for the message   using the same lookup rules that are used when the system handles   a key command.</P></DL><H2>Transports</H2><P><A NAME="Adding_Child_Views_to_a_ProtoTransportHeader-based_View"></A></P><H3><HR>Adding Child Views to a ProtoTransportHeader-based View (1/19/96)</H3><DL>   <DD>Q: How can I add child views to a   <CODE>protoTransportHeader</CODE>-based view?<BR>      <BR>      A: First, you need to specify an <CODE>addedHeight </CODE>slot.   The height of the transport header will be increased by this   amount.<BR>      <BR>      Next, add the following code to the <CODE>viewSetupFormScript   </CODE>method of your <CODE>protoTransportHeader </CODE>view. This   works around a bug with <CODE>protoTransportHeader:<BR>      </CODE><BR>            <PRE><CODE>        self.stepChildren := SetUnion( self._proto.stepChildren,           self._proto._proto.stepChildren, true );</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Finally, use NTK as you normally would to create the child   views.<BR>      </P></DL><P><A NAME="How_to_Omit_Default_Transport_Preference_Views"></A></P><H3><HR>How to Omit Default Transport Preference Views (5/6/96)</H3><DL>   <DD>Q: I want to omit some transport preferences that appear   automatically. If I specify <CODE>nil </CODE>for the   <CODE>sendPrefs</CODE>, <CODE>outboxPrefs</CODE>, or   <CODE>inboxPrefs </CODE>slots in my transport preferences   template, opening the slip throws -48204. What is going wrong?<BR>      <BR>      A: The documentation states if you don't want to include   <CODE>sendPrefs</CODE>, <CODE>outboxPrefs</CODE>, or   <CODE>inboxPrefs </CODE>in your preferences dialog to set those   slot to <CODE>nil</CODE>. Due to a bug in the cooresponding views   for those preference items, -48204 is thrown when an attempt is   made to open the views. This will be fixed in a future ROM.</DL><P><A NAME="How_to_Stop_ProtoAddressPicker_Memory"></A></P><H3><HR>How to Stop ProtoAddressPicker Memory (9/20/96)</H3><DL>   <DD>Q: How do I stop <CODE>protoAddressPicker</CODE> from   remembering the last people picked?<BR>      <BR>      A: <CODE>protoAddressPicker</CODE> has a slot called   <CODE>useMemory</CODE> that was left out of the documentation. If   this slot is set to <CODE>nil</CODE>, the memory mechanism will be   disabled.</DL><P><A NAME="ReceiveRequest_Requests_Incorrect_After_Using_RemoveTempItems"></A></P><H3><HR>ReceiveRequest Requests Incorrect After Using RemoveTempItems(10/1/96)</H3><DL>   <DD>Q: If my transport calls the owner method   <CODE>RemoveTempItems</CODE> when items are selected, the   <CODE>ReceiveRequest</CODE> message sometimes has bogus request   arguments (for instance, the <CODE>cause</CODE> is set to   <CODE>'remote</CODE>). Is this a known bug?<BR>      <BR>      A: Yes, this is a known bug in <CODE>RemoveTempItems</CODE>. The   call to <CODE>RemoveTempItems</CODE> does not clear out the cache   of selected items correctly. This will be fixed in a future   version of the Newton OS.<BR>      <BR>      To workaround the problem, assume the following: If your   transport's communications channel is not currently connected and   you receive a request with its cause slot set to   <CODE>'remote</CODE>, assume that the cause slot is actually   <CODE>'user</CODE> and act accordingly. If you receive a request   with its <CODE>'cause</CODE> slot set to <CODE>'remote </CODE>and   your transport's communications channel is connected then perform   the appropriate action for receiving remote items.<BR>   </DL><P><A NAME="Filing_Sent_Entries_in_the_Out_Box"></A></P><H3><HR>Filing Sent Entries in the Out Box (1/14/97)</H3><DL>   <DD>Q: If a user has selected to file sent entries into a folder   that has been deleted, my transport throws an exception when it   calls <CODE>ItemCompleted</CODE>. Why is this problem   occuring?<BR>      <BR>      A: This is caused by a bug in <CODE>ItemCompleted</CODE>. To work   around this, you should check to make sure the folder exists   before calling <CODE>ItemCompleted</CODE>. If it does not exist,   then set the transport's <CODE>'outboxFiling</CODE> preference to   <CODE>nil</CODE>. Here is a code example:<BR>            <PRE><CODE>// This code assumes that the current receiver (self) is your transportif NOT GetFolderStr( :GetConfig( 'outboxFiling ) ) then    :SetConfig( 'outboxFiling, nil );</CODE></PRE></DL><P><A NAME="Documentation_on_the_InboxFiling_Preference"></A></P><H3><HR>Documentation on the InboxFiling Preference (1/15/97)</H3><DL>   <DD>Q: The documentation on In Box filing appears to be incorrect.   It says that incoming items will be filed when they are received,   however it appears that they are actually filed when they are   read. Is the documentation incorrect?<BR>      <BR>      A: Yes, the documentation is incorrect. Items are filed when they   have been read, not when they have been received. The default for   <CODE>inboxFiling</CODE> is <CODE>nil</CODE>.<BR>      <BR>      Note that if the In/Out Box is not the backdrop application,   filing does not occur until you close the In/Out Box. If the   In/Out Box is the backdrop application, filing occurs when the   user switches between the overview and the main view.</DL><P><A NAME="Adding_an_Auto_Put_Away_Transport_Preference"></A></P><H3><HR><B>NEW: </B>Adding an Auto Put Away Transport Preference (5/14/97)</H3><DL>   <DD>Q: How do I add a transport preference to control whether   received items are automatically put away?<BR>      <BR>      A: For the item to be automatically put away, two conditions must   exist. First, the application to which the item is put away must   implement the <CODE>AutoPutAway</CODE> method. Second, the   transport configuration slot <CODE>'dontAutoPutAway</CODE> must be   set to <CODE>nil</CODE> (or not be present). This configuration   slot is new to Newton 2.1 OS and must contain the value nil or the   value <CODE>'never</CODE>. If <CODE>nil</CODE>, items will be put   away automatically provided the application defined by the item's   <CODE>appSymbol</CODE> slot has the <CODE>AutoPutAway</CODE>   method. If <CODE>'never</CODE>, items will not be automatically   put away regardless of whether the application defined by the   item's <CODE>appSymbol</CODE> slot implements the   <CODE>AutoPutaway</CODE> method.<BR>      <BR>      This new configuration preference is only used on Newton 2.1 OS   and higher.</DL><H2>Utility Functions</H2><P><A NAME="What_Happened_to_FormattedNumberStr"></A></P><H3><HR>What Happened to FormattedNumberStr (2/12/96)</H3><DL>   <DD>Q: The Newton 1.x documentation and OS included a   <CODE>sprintf</CODE>-like function for formatting numbers called   <CODE>FormattedNumberStr</CODE>. The Newton Programmer's Guide 2.0   First Edition (beta) says this function is no longer supported.   How do I format my numbers?<BR>      <BR>      A: You may continue to use <CODE>FormattedNumberStr</CODE>. Here   is the <CODE>FormattedNumberStr</CODE>API that is supported.   <CODE>FormattedNumberStr</CODE> should be considered to have   undefined results if passed arguments other than those specified   here.<BR>      <BR>            <PRE><CODE>FormattedNumberStr(number, formatString)</CODE></PRE>      <P><CODE><BR>      </CODE>Returns a formatted string representation of a real   number.<BR>      <BR>      <CODE>number</CODE> A real number.<BR>      <CODE>formatString</CODE> A string specifying how the number   should be formatted.<BR>      <BR>      This function works similar to the C function   <CODE>sprintf</CODE>. The <CODE>formatString</CODE> specifies how   the real number should be formatted; that is, whether to use   decimal or exponential notation and how many places to include   after the decimal point. It accepts the following format   specifiers:<BR>      <CODE>%f</CODE> Use decimal notation (such as   "123,456.789000").<BR>      <CODE>%e</CODE> Use exponential notation (such as   "1.234568e+05").<BR>      <CODE>%E</CODE> Use exponential notation (such as   "1.234568E+05").<BR>      <BR>      You can also specify a period followed by a number after the %   symbol to indicate how many places to show following the decimal   point. (<CODE>"%.3f"</CODE> yields <CODE>"123,456.789"</CODE> for   example.)<BR>      <BR>      Note:<CODE> FormattedNumberStr</CODE> uses the current values of   <CODE>GetLocale().numberFormat</CODE> to get the separator and   decimal characters and settings. The example strings above are for   the US English locale.<BR>      <BR>      <B>Known Problems<BR>      </B><I>Other specifiers<BR>      </I>Do <I>not</I> use other <CODE>formatStrings</CODE>. Previous   releases of the documentation listed <CODE>%g</CODE> and   <CODE>%G</CODE> as supported specifiers. The behavior of these   specifiers has changed with the Newton 2.0 OS. Given the   similarities to the<CODE> sprintf</CODE> function, it may occur to   you to try other sprintf formatting characters. Specifiers other   than above have an undefined result and should be considered   undocumented and unsupported.<BR>      <BR>      <I>Large numbers<BR>      </I><CODE>FormattedNumberStr</CODE> does not work properly for   numbers larger than <CODE>1.0e24</CODE>. If the number is very   large the function can cause the Newton device to hang.<BR>      <BR>      <I>Small numbers or long numbers<BR>      </I>If more than 15 characters of output would be generated, for   example because you are using <CODE>%f</CODE> with large number or   a large number of digits following the decimal,   <CODE>FormattedNumberStr</CODE> has undefined results, and can   cause the Newton device to hang.<BR>      <I><BR>      Rounding<BR>      </I><CODE>FormattedNumberStr</CODE> does not guarantee which   direction it will round. In the Newton 2.0 OS, it rounds half   cases down rather than up or to an even digit. If you need a   precisely rounded number you should use the math functions   <CODE>Ceiling</CODE>, <CODE>Floor</CODE>, <CODE>NearbyInt</CODE>,   or <CODE>Round</CODE> with suitable math.<BR>      <BR>      <I>Trailing decimals<BR>      </I>In early releases of the Newton 1.0 OS, there was a bug in   <CODE>FormattedNumberStr</CODE> that caused a trailing decimal   character to be added when zero decimal positions was specified.   That is, <CODE>FormattedNumberStr(3.0, "%.0f")</CODE> resulted in   <CODE>"3."</CODE> not <CODE>"3"</CODE>. To properly test for and   remove this unwanted extra character you must be sure to use the   character specified in the Locale settings and not assume the   decimal character will be a period.</P></DL><P><A NAME="Backlight_API"></A></P><H3><HR>Backlight API (4/19/96)</H3><DL>   <DD>Q: What is the API to check for and use the backlight?<BR>      <BR>      A: There are three relevant pieces of information:<BR>      <BR>      <B>Checking for the backlight<BR>      </B><BR>      To check if the backlight is there, use the <CODE>Gestalt</CODE>   function as follows:<BR>      <BR>            <PRE><CODE>// define this somewhere in your project// until the platform file defines it (not in 1.2d2)constant kGestalt_BackLight := '[0x02000007, [struct, boolean], 1];&nbsp;local isBacklight := Gestalt(kGestalt_BackLight);&nbsp;if isBacklight AND isBacklight[0] then   // has a backlightelse   // has not got one&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE><B>Status of the backlight<BR>      </B><BR>      To find the current state of the backlight, use the following   function:<BR>      </P>      <PRE><CODE>    BackLightStatus()</CODE></PRE>      <P><CODE><BR>      </CODE>return value = nil (backlight is off) or non-nil (backlight   is on)<BR>      <BR>      <B>Changing backlight status<BR>      </B><BR>      To turn the backlight on or off, use:<BR>      <BR>      </P>      <PRE><CODE>    BackLight(state)</CODE></PRE>      <P><CODE><BR>      </CODE>return value - unspecified<BR>      state - nil (turn backlight off) or non-nil (turn backlight   on)<BR>      </P></DL><P><A NAME="Unusual_Sort_Order/Case_Sensitivity_in_Swedish_Locale_"></A></P><H3><HR>Unusual Sort Order/Case Sensitivity in Swedish Locale (1/16/97)</H3><DL>   <DD>Q: When I set the unit to the Swedish locale and use the   <CODE>StrPos</CODE> global function to search for a ':' character,   it finds other characters such as '.' or ';'. Isn't that a bug?   How can I reliably search for these characters in any locale?<BR>      <BR>      A: The global function <CODE>StrPos</CODE> and many of the other   string functions are case insensitive - they treat upper and   lowercase letters as being identical. In other languages,   characters such as accented letters may be considered as different   cases of the base letter, so they are treated as identical as   well. In the Newton OS model, the concepts 'same case' and 'same   position in the sorting order' are not distinguished, so all cases   of a letter will sort to the same position. Going backwards, all   characters that sort identically are considered to be different   cases of the same letter. Well, in the Swedish sort order, many   punctuation characters are defined to sort to the same place, and   so the case insensitive functions in the Newton device treat the   characters as identical. Many special and punctuation characters   are grouped this way, but perhaps the most surprising set is ?   &#161; : , . ; &#191; and !, which all sort to the same position   and so are treated as identical in Swedish by <CODE>StrPos</CODE>   and other case insensitive functions.<BR>      <BR>      To search a string for a particular character using a case   sensitive search, use the <CODE>CharPos</CODE> function instead of   <CODE>StrPos</CODE>.</DL><P><A NAME="Time_Zones,_GMT,_Daylight_Savings,_and_Newton_Time"></A></P><H3><HR>Time Zones, GMT, Daylight Savings, and Newton Time (3/4/97)</H3><DL>   <DD>Q: There don't seem to be any functions in the Newton OS for   converting between standard time values, such as finding the time   in a different time zone, or GMT time. I know it's possible   because the built in Time Zones application does it. How can I do   this in my own application?<BR>      <BR>      A: The Newton OS doesn't actually have the concept of time zones.   Instead, for each city if keeps track of the offset (in seconds)   from GMT for that city. You can find this in the <CODE>'gmt</CODE>   slot of a city entry, which can be gotten with the   <CODE>GetCityEntry</CODE> global function. See the "Built In Apps   and System Data" chapter of the Newton Programmers Guide for   details. Note that the docs incorrectly say the <CODE>gmt</CODE>   slot contains the offset in minutes, when it is actually specified   in seconds. The current location is available in the   <CODE>'location</CODE> slot of the user configuration frame. Use   <CODE>GetUserConfig('location)</CODE> to access it. The global   function <CODE>LocalTime</CODE> can be used to convert a time to   the local time in a distant city.<BR>      <BR>      A simple way to get the local time from a GMT time would be to   create a city entry representing GMT (gmt offset 0, no daylight   savings) and then use <CODE>LocalTime</CODE> to compute the delta   between the current city and the GMT city, then add the delta to   the given GMT time. <CODE>LocalTime</CODE> can be used directly to   go the other way--getting the GMT time from the local time.<BR>      <BR>      <CODE>LocalTime</CODE>(<I><CODE>time</CODE></I>,   <I><CODE>where</CODE></I>)<BR>      <I><CODE>time</CODE></I> - a time in minutes in the local (Newton   device) zone, for example as returned from the <CODE>Time</CODE>   function<BR>      <I><CODE>where</CODE></I> - a city entry, as returned from   <CODE>GetCityEntry</CODE><BR>      <I><CODE>result</CODE></I> - a time in minutes in the <I>where</I>   city, adjusted as necessary for time zone and daylight   savings.<BR>      <BR>      <CODE>LocalTime</CODE> tells you the local time for the distant   city, given a time in the current city. For example, to find out   the time in Tokyo:<BR>      <BR>            <PRE><CODE>    Date(LocalTime(time(), GetCityEntry("Tokyo")[0]))    #C427171  {year: 1997, month: 2, Date: 22, dayOfWeek: 6,           hour: 8, minute: 1, second: 0, daysInMonth: 28}</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      <BR>      Because the Newton OS doesn't have time zones, it can't keep track   of daylight savings time by changing zones (for example, from   Pacific Standard Time to Pacific Daylight Time). Instead, it uses   a bunch of rules that tell it when to set the time ahead or back,   and by how much. The global function <CODE>DSTOffset</CODE> can be   used to find out how much these daylight savings time rules have   adjusted a given time for a given city.<BR>      <BR>      <CODE>DSTOffset(</CODE><I><CODE>time</CODE></I><CODE>,   </CODE><I><CODE>where</CODE></I><CODE>)</CODE><BR>      <I><CODE>time</CODE></I> - a time in minutes in the where city<BR>      <I><CODE>where</CODE></I> - a city entry, as returned from   <CODE>GetCityEntry</CODE><BR>      <I><CODE>result</CODE></I> - an integer, number of minutes that   daylight savings adjusted that time in that city.<BR>      <BR>      <CODE>DSTOffset</CODE> tells you what the daylight savings   component is of a given time in a given location. This component   would need to be subtracted from the result of the global function   <CODE>Time</CODE> to get a non-daylight-adjusted time for the   current location.<BR>      </P>      <PRE><CODE>    // it's currently 2:52 PM on 3/4/97, no DST adjustment    DSTOffset(Time(), GetCityEntry("Cupertino")[0]);    #0        0&nbsp;    // but during the summer, DST causes the clocks to "spring forward" an hour.    DSTOffset(StringToDate("6/6/97 12:34"), GetCityEntry("Cupertino")[0]);    #F0       60&nbsp;&nbsp;</CODE>&nbsp;</PRE></DL><P><A NAME="Square_Root_of_Negative_Number_Bug"></A></P><H3><HR>Square Root of Negative Number Bug (3/4/97)</H3><DL>   <DD>Q: When I call <CODE>Sqrt</CODE> with a negative number on the   Newton, or use <CODE>Compile</CODE> in the NTK Inspector, I get a   strange result. However, if I just type <CODE>sqrt(-2)</CODE> into   the listener I get a different strange result. What's going   on?<BR>      <BR>            <PRE><CODE>    call compile("sqrt(-2)") with ()    #4412F2D  -1.79769e+308&nbsp;    sqrt(-2)    #440DE05  1.00000e+999</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      A: There is a floating point library bug in <CODE>Sqrt</CODE> on   the Newton OS. When passed a negative number, the large positive   value is returned instead of a not-a-number value. You can work   around it using <CODE>Pow(x, 0.5)</CODE> instead of   <CODE>Sqrt(x)</CODE> if there is no way to guarantee that the   value passed to <CODE>Sqrt</CODE> is non-negative, or simply check   and see if the argument is less than 0 and return a not-a-number   constant.<BR>      <BR>      The reason <CODE>sqrt(-2)</CODE> works differently when you type   it into the NTK Inspector is because of a compiler process known   as constant folding. <CODE>Sqrt</CODE> can be evaluated at compile   time if you pass it a constant argument. So what's really   happening is that NTK is evaluating the <CODE>Sqrt</CODE> function   during the compile phase and passing the resulting floating point   number (or rather, not-a-number) to the Newton device where it's   promptly returned. An NTK real number formatting limitation   displays non-a-number values and infinities as   <CODE>1.00000e+999</CODE> rather than as some other string. You   can use <CODE>IsNAN</CODE> to determine if a real number is a   not-a-number value.<BR>      <BR>      You can avoid constant folding and force evaluation on the Newton   device by using a variable. For instance:<BR>      </P>      <PRE><CODE>    x := -2;    y := sqrt(x);    #C4335B1  -1.79769e+308</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      Also, note that <CODE>FormattedNumberStr</CODE> does not properly   handle not-a-number values. (it returns "Number too small.")<BR>      </P></DL><P><A NAME="Making_Use_of_the_Serial_Number_Chip"></A></P><H3><HR>Making Use of the Serial Number Chip (4/3/97)</H3><DL>   <DD>Q: I would like to get the serial number from the units that   support it, as either an integer or real number. How can I do   this?<BR>      <BR>      A: You probably don't really want to do this. The serial number is   an 8-byte binary object, so you could use <CODE>ExtractByte</CODE>   or <CODE>ExtractWord</CODE> or possibly <CODE>ExtractLong</CODE>   to get the bytes out in integer form, then do something with them.   However, keep in mind that NewtonScript integers are only 30 bits   wide, whereas the serial number is 64 bits wide, so you'll never   be able to put all the information contained in the serial number   into a single integer. (3 integers would be required.)<BR>      <BR>      That is, let us suppose you added up the value of all the bytes in   a serial number. You would get a single NewtonScript integer, but   it would also be possible for a different serial number to produce   the same integer. (Just swap the positions of two of the bytes.)   Same goes for XOR or any checksumming scheme. There's just no way   to reduce 64 bits of information to 30 bits without allowing loss   of uniqueness. (If you come up with a way, let us know, it'd make   a great compression algorithm!)<BR>      <BR>      Real numbers aren't suitable either, for much the same reason.   It's true that in NewtonScript reals are 8 bytes wide, but they   use the IEEE 64-bit real number specification, and so not all   combinations of 8 bytes are considered unique. That is, you might   think about taking the serial number result and using   <CODE>SetClass</CODE> to change it's class to <CODE>'real</CODE>,   which would effectively "cast" the 8-byte object to a real number.   This is a bad idea, because real numbers are interpreted using   bitfields with special meanings, and it's possible for two real   numbers to have different binary representations and still   evaluate as equal using the '=' operator. (Any two not-a-number   values will do this.)<BR>      <BR>      Serial numbers are best treated as strings or as 8-byte binary   objects, so that no data is lost. <CODE>StrHexDump</CODE> is the   best way to format the serial number object for humans to read. If   you want to break it up to make it more easily readable, you could   do something like this:<BR>            <PRE><CODE>    local s := StrHexDump(call ROM_GetSerialNumber with (), 2);    StrReplace(s, " ", "-", 3);</CODE></PRE>      <P><CODE><BR>      </CODE>Which produces this string (on my unit):<BR>      </P>      <PRE><CODE>    "0000-0000-0154-8423 "&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>Please note that the serial number provided by the chip   does NOT match the serial number that Apple Computer and other   Newton device manufacturers may put on the outside of the case.   When supporting a device, Apple and its licensees will most likely   request the user-visible serial number, typically found on a   sticker on the case. Please be sure that you present data from the   internal chip-based serial number in such a way as to ensure the   user will not be confused. (This is the reason the chip-based   serial number is not displayed by any software built into the   device.)</P></DL><P><A NAME="Programmatically_Cancelling_a_Confirm_Slip"></A></P><H3><HR>Programmatically Cancelling a Confirm Slip (4/3/97)</H3><DL>   <DD>Q: During an operation, I bring up a slip to ask the user if   they really want to abort the operation. Before they answer, the   operation may complete or be aborted anyway. I would like to   remove the slip if this happens, much like the "Remount" slip is   removed when a gripped card is ejected, reinserted, and then   re-ejected.<BR>      <BR>      A: There's no way to dismiss a <CODE>ModalConfirm</CODE> slip,   because your code is paused waiting for the result. You can,   however, remove an <CODE>AsyncConfirm</CODE> slip. The return   value from <CODE>AsyncConfirm</CODE> (which is documented in the   Newton Programmer's Guide as "unspecified") is actually a   reference to the confirm view. Sending that view a   <CODE>Close</CODE> message dismisses the slip. The callback   function will not be called if this slip is removed in this way,   so make sure your program handles that case.<BR>   </DL><H2>Views</H2><P><A NAME="How_to_Save_the_Contents_of_clEditView"></A></P><H3><HR>How to Save the Contents of clEditView (10/4/93)</H3><DL>   <DD>Q: How can I save the contents of a <CODE>clEditView</CODE>   (the children paragraph, polygon, and picture views containing   text, shapes, and ink) to a soup and restore it later?<BR>      <BR>      A: Simply save the <CODE>viewChildren</CODE> array for the   <CODE>clEditView</CODE>, probably in the   <CODE>viewQuitScript</CODE>. To restore, assign the array from the   soup to the <CODE>viewChildren</CODE> slot, either at   <CODE>viewSetupFormScript</CODE> or   <CODE>viewSetupChildrenScript</CODE> time; or later followed by   <CODE>RedoChildren</CODE>.<BR>      <BR>      You shouldn't try to know "all" the slots in a template in the   <CODE>viewChildren</CODE> array. (For example, text has optional   slots for fonts and tabs, shapes have optional slots for pen   width, and new optional slots may be added in future versions.)   Saving the whole array also allows you to gracefully handle   templates in the <CODE>viewChildren</CODE> array that don't have   an ink, points, or text slot. In the future, there may be children   that represent other data types.</DL><P><A NAME="Adding_Editable_Text_to_clEditViews"></A></P><H3><HR>Adding Editable Text to clEditViews (6/9/94)</H3><DL>   <DD>Q: How can I add editable text to a <CODE>clEditView</CODE>?   If I drag out a <CODE>clParagraphView</CODE> child in NTK, the   text is not selectable even if I turn on   <CODE>vGesturesAllowed</CODE>.<BR>      <BR>      A: <CODE>clEditViews</CODE> have special requirements. To create a   text child of a <CODE>clEditView</CODE> that can be selected and   modified by the user (as if it had been created by the user) you   need to do the following:<BR>      <BR>            <PRE><CODE>    textTemplate := {        viewStationery: 'para,        viewBounds: RelBounds(20, 20, 100, 20),        text: "Demo Text",    };    AddView(self, textTemplate);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>The view must be added dynamically (with   <CODE>AddView</CODE>), because the <CODE>clEditView</CODE> expects   to be able to modify the contents as the user edits this item. The   template (<CODE>textTemplate</CODE> above) should also be created   at run time, because the <CODE>clEditView</CODE> adds some slots   to this template when creating the view. (Specifically it fills in   the <CODE>_proto</CODE> slot based on the   <CODE>viewStationery</CODE> value. The <CODE>_proto</CODE> slot   will be set to <CODE>protoParagraph</CODE>) If you try to create   too much at compile time, you will get -48214 (object is read   only) errors when opening the edit view.<BR>      <BR>      The minimum requirements for the template are a   <CODE>viewStationery</CODE> of <CODE>'para</CODE>, a   <CODE>text</CODE> slot, and a <CODE>viewBounds</CODE> slot. You   can also set <CODE>viewFont</CODE>, <CODE>styles</CODE>,   <CODE>tabs</CODE>, and other slots to make the text look as you   would like.</P></DL><P><A NAME="TieViews_and_Untying_Them"></A></P><H3><HR>TieViews and Untying Them (6/9/94)</H3><DL>   <DD>Q: What triggers the pass of a message to a tied view? If I   want to "untie" two views that have been tied with   <CODE>TieViews</CODE>, do I simply remove the appropriate slots   from the <CODE>viewTie</CODE> array?<BR>      <BR>      A: The tied view's method will be executed as a result of the same   actions that cause the main view's <CODE>viewChangedScript</CODE>   to be called. This can happen without calling   <CODE>SetValue</CODE>, for example, when the user writes into a   view that has recognition enabled, the   <CODE>viewChangedScript</CODE> will get called.<BR>      <BR>      As of Newton 2.1 OS, there is no API for untying tied views. It   may be wise to first check for the existance of an   <CODE>UntieViews</CODE> function, and call it if it exists, but if   it does not, removing the pair of elements from the tied view's   <CODE>viewTie</CODE> array is fine.</DL><P><A NAME="Immediate_Children_of_the_Root_View_Are_Special"></A></P><H3><HR>Immediate Children of the Root View Are Special (11/17/94)</H3><DL>   <DD>Q: In trying to make a better "modal" dialog, I am attempting   to create a child of the root view that is full-screen and   transparent. When I do this, the other views always disappear, and   reappear when the window is closed. Why?<BR>      <BR>      A: Immediate children of the root view are handled differently by   the view system. They cannot be transparent, and will be filled   white unless otherwise specified. Also, unlike other views in   Newton 2.0 OS, their borders are considered part of the view and   so taps in the borders will be sent to them.<BR>      <BR>      This was done deliberately to discourage tap-stealing and other   unusual view interaction. Each top level view (usually one   application) is intended to stand on its own and operate   independently of other applications.<BR>      <BR>      So-called "application modal" dialogs can and should be   implemented using the technique you describe with the transparent   window as a child of the application's base view.<BR>      <BR>      You can make system modal dialogs with the view methods   <CODE>FilterDialog</CODE> and <CODE>ModalDialog</CODE>. (See the   Q&amp;A "FilterDialog and ModalDialog Limitations" for important   information on those methods.)</DL><P><A NAME="ViewIdleScripts_and_clParagraphViews"></A></P><H3><HR>ViewIdleScripts and clParagraphViews (8/1/95)</H3><DL>   <DD>Q: Sometimes a <CODE>clParagraphView</CODE>'s   <CODE>viewIdleScript</CODE> is fired off automatically. (For   example, an operation which results in the creation or changing of   a keyboard's input focus within the view will trigger the   viewIdleScript.) Why does this happen and what can I do about   it?<BR>      <BR>      A: The <CODE>clParagraphView</CODE> class internally uses the idle   event mechanism to implement some of its features. Unfortunately,   any <CODE>viewIdleScript</CODE>s provided by developers also   execute when the system idle events are processed. Only the   "heavyweight" views do this, "lightweight" paragraph views (in   other words, simple static text views) do not.<BR>      <BR>      There is no workaround in the Newton 1.x OS or Newton 2.0 OS while   using clParagraphView <CODE>viewIdleScript</CODE>. You can either   accept the extra idle script calls, or use another   non-<CODE>clParagraphView</CODE> based view to implement your idle   functions.<BR>   </DL><P><A NAME="FilterDialog_and_ModalDialog_Limitations"></A></P><H3><HR>FilterDialog and ModalDialog Limitations (2/5/96)</H3><DL>   <DD>Q: After closing a view that was opened with   <CODE>theView:FilterDialog()</CODE>, the part of the screen that   was not covered by the <CODE>theView </CODE>no longer accepts any   pen input. <CODE>theView </CODE>is a <CODE>protoFloatNGo</CODE>.   Is there some trick?<BR>      <BR>      A: There is a problem with <CODE>FilterDialog </CODE>and   <CODE>ModalDialog </CODE>when used to open views that are not   immediate children of the root view. At this point we're not sure   if we'll be able to fix the problem.<BR>      <BR>      You must not use <CODE>FilterDialog </CODE>or <CODE>ModalDialog   </CODE>to open more than one non-child-of-root view at a time.   Opening more than one at a time with either of these messages   causes the state information from the first to be overwritten with   the state information from the second. The result will be a   failure to exit the modality when the views are closed.<BR>      <BR>      Here are some things you can do to avoid or fix the problem with   <CODE>FilterDialog</CODE>.<BR>      <BR>      Redesign your application so that your modal slips are all   children of the root view, created with <CODE>BuildContext</CODE>.   This is the best solution because it avoids awkward situations   when the child of an application is system-modal. (Application   subviews should normally be only application-modal.)<BR>      <BR>      Use the <CODE>ModalDialog </CODE>message instead of   <CODE>FilterDialog</CODE>. <CODE>ModalDialog </CODE>does not have   the child-of-root bug. (<CODE>FilterDialog </CODE>is preferred,   since it uses fewer system resources and is faster.)<BR>      <BR>      Here is some code you can use to work around the problem much like   a potential patch would. (This code should be safe if a patch is   madethe body of the if statement should not execute on a corrected   system.)<BR>      <BR>            <PRE><CODE>view:FilterDialog();if view.modalState then    begin        local childOfRoot := view;        while childOfRoot:Parent() &lt;&gt; GetRoot() do            childOfRoot := childOfRoot:Parent();        childOfRoot.modalState := view.modalState;    end;&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>This only needs to be done if the view that you send the   <CODE>FilterDialog </CODE>message to is not an immediate child of   the root. You can probably improve the efficiency in your   applications, since the root child is ususally your application's   base view, which is a "well known" view. That is, you may be able   to re-write the code as follows:<BR>      <BR>      </P>      <PRE><CODE>view:FilterDialog();if view.modalState then    base.modalState := view.modalState;</CODE></PRE></DL><P><A NAME="Using_Proportional_View_Alignment_Correctly"></A></P><H3><HR>Using Proportional View Alignment Correctly (6/20/96)</H3><DL>   <DD>Q: I am trying to use proportional view alignment but things   don't seem to be working correctly. For instance, if I have a view   which is full justified or center justified, proportional view   alignment doesn't seem to work at all. Whats wrong?<BR>      <BR>      A: Proportional justification only works if you are using left,   right, top, or bottom justification. This is true for both sibling   and parent justification.<BR>      <BR>      Proportional justification is very similar to full justification.   The view system needs some reference point at which to position   the view. If you specify full or center justification, and you are   also using proportional justification, the reference point is   undefined.<BR>      <BR>      Additionally, if you are using right or bottom justification, you   will need to specify negative values for your proportional bounds.   For instance, if you want a view to take up the right 30 percent   of its parent, you would specify the following view bounds:<BR>            <PRE><CODE>    {left: -30, top: &lt;top&gt;, right: 0, bottom: &lt;bottom&gt;}</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      and the following view justification:<BR>      </P>      <PRE><CODE>    vjParentRightH + vjLeftRatio</CODE>&nbsp;</PRE></DL><P><A NAME="Drag_and_Drop_Caches_the_Background_Bitmap"></A></P><H3><HR>Drag and Drop Caches the Background Bitmap (7/15/96)</H3><DL>   <DD>Q: I am trying to implement drag scrolling. Although I can   scroll the contents of the window, when I drag the item back into   the window, it strips away the updated (scrolled) contents and   leaves the original (unscrolled) contents behind. How can I get   this to work?<BR>      <BR>      A: Unfortunately, you have hit a design limitation of the Drag and   Drop implementation. When you send the <CODE>DragAndDrop</CODE>   message to a view, the bitmap for the pre-drag state is cached.   Once the drag loop starts, you can not update that cached bitmap.   When you "scroll" the view (probably using   <CODE>RefreshViews</CODE>), you update the screen, but the cached   bitmap is still there and is used by the <CODE>DragAndDrop</CODE>   routine to update the screen as the dragged item is moved.</DL><P><A NAME="Default_and_Close_Keys_in_Confirm_Slips"></A></P><H3><HR>Default and Close Keys in Confirm Slips (2/28/97)</H3><DL>   <DD>Q: Is there any way to put a keyboard default on a confirm   dialog?<BR>      <BR>      A: Yes. For both <CODE>ModalConfirm</CODE> and   <CODE>AsyncConfirm</CODE>, the 2.0 Newton Programmer's Reference   says you may pass three types of things as the buttonList   argument: a symbol (<CODE>'okCancel</CODE> or   <CODE>'yesNo</CODE>), and array of strings, or an array of frames   with <CODE>'value</CODE> and <CODE>'text</CODE> slots.<BR>      <BR>      In the Newton 2.1 OS, this API has been extended to allow for   default key and close key behavior. There are four new symbols   that are allowed: <CODE>'okCancelDefaultOk</CODE>,   '<CODE>okCancelDefaultCancel</CODE>,   <CODE>'yesNoDefaultYes</CODE>, and <CODE>'yesNoDefaultN</CODE>o.   They do the obvious thing, setting the default key as specified   and the close key to Cancel or No if those aren't the default.   However, using these symbols on a Newton 2.0 OS device will result   in the "OK" and "Cancel" buttons always being displayed, even if   you specify <CODE>'yesNoDefaultYes</CODE> or   <CODE>'yesNoDefaultNo</CODE>.<BR>      <BR>      The array-of-frames flavor for the <CODE>buttonList</CODE>   argument allows an additional slot, called <CODE>'keyValue</CODE>.   Supported values for this slot are the symbols   <CODE>'default</CODE> and <CODE>'close</CODE>, or NIL/not present.   <CODE>'default</CODE> makes the button the default key, and   <CODE>'close</CODE> makes the button activate with the close key.   Any other value will cause a problem in the current Newton 2.1   implementation. The <CODE>keyValue</CODE> slot is ignored on the   Newton 2.0 OS.<BR>      <BR>      For compatibility, we recommend avoiding the   <CODE>'yesNoDefaultYes</CODE> and <CODE>'yesNoDefaultNo</CODE>   symbols if you intend to run on both Newton 2.0 and 2.1 devices.   Instead, use one of these specifiers:<BR>            <PRE><CODE>    '[{text: "Yes", value: TRUE, keyValue: default}, {text: "No", value: NIL, keyValue: close}]</CODE></PRE>      <P><CODE><BR>      </CODE></P>      <PRE><CODE>    '[{text: "Yes", value: TRUE}, {text: "No", value: NIL, keyValue: default}]</CODE>&nbsp;</PRE></DL><P><A NAME="Screen_Rotation_and_Linked_Views_or_BuildContext_Slips"></A></P><H3><HR>Screen Rotation and Linked Views or BuildContext Slips (3/10/97)</H3><DL>   <DD>Q: I've got a linked view open, and I'm trying have it rotate   with <CODE>ROM_DefRotateFunc</CODE>. When I rotate the screen the   base view rotates properly, but the linked view closes. Do I need   to add a <CODE>ReorientToScreen</CODE> slot to the linked   view?<BR>      <BR>      A: When the user requests a screen rotation, the OS first checks   each immediate child of the root view to see if it will still   operate on the rotated screen. Having a   <CODE>ReorientToScreen</CODE> slot in the view tells the OS that   this view is OK, so the slot is used first as a token ("magic   cookie") to tell the OS that this view knows about rotation. Later   during the rotation operation, the <CODE>ReorientToScreen</CODE>   message is sent to your application's base view and to other views   that are immediate children of the root view. That method then   performs its second function, which is to completely handle   resizing the view and its children for the new screen size. (Even   views which are small enough so that no resizing is necessary need   a <CODE>ReorientToScreen</CODE> method. That method may need to   move the base view to ensure that it remains on-screen after   rotation.)<BR>      <BR>      It's convenient to use the <CODE>ROM_DefRotateFunc</CODE> for this   script, since it fills the magic cookie requirement and handles   resizing for most views. <CODE>ROM_DefRotateFunc</CODE> is very   simple: it send a close and then an open message to the view.   Since well-written applications take screen size into account when   they open, this works fine in most cases. However, applications   that keep track of internal state that isn't preserved when the   app is closed can't use <CODE>ROM_DefRotateFunc</CODE>, because   when the app reopens on the rotated screen, it will look   different. Opening a linked subview is one example of this; it   doesn't usually make sense to remember that a slip is open, since   it's usually closed when your application is closed.<BR>      <BR>      Adding a <CODE>ReorientToScreen</CODE> method to your linked views   wouldn't help; since they are descendents of your base view and   not children of the root view, the OS wouldn't handle these views.   (It's up to your application to keep its kids under control.) You   could change your application so that it kept track of whether the   linked views were open or closed, and restored them to the same   state when it was reopened. However, this might be confusing to   users who closed your app and then opened it again much later.<BR>      <BR>      A better workaround is to implement your own   <CODE>ReorientToScreen</CODE> method, which either resizes the   views so they fit on the new screen, or which closes and reopens   the views such that the floaters also re-open. By using the   <CODE>ReorientToScreen</CODE> message to handle the special case,   you get to do something different during rotation versus during   opening at the user request (for example, after tapping on the   Extras icon.)<BR>      <BR>      Slips created with <CODE>BuildContext</CODE> also must be handled   carefully during rotation. Because they are themselves children of   the root view, they'll each need their own   <CODE>ReorientToScreen</CODE> method or the screen may not be   rotatable when they are open or they won't reopen after rotation.   If you use <CODE>ROM_DefRotateFunc</CODE>, the slip itself will be   closed and reopened, and care may need to be taken to ensure the   slip properly handles being reopened, and that its connection to   its controlling application is not lost.<BR>   </DL><P><A NAME="How_to_Get_Data_From_a_ProtoTXView_Externalized_Data"></A></P><H3><HR>How to Get Data From a ProtoTXView Externalized Data (4/3/97)</H3><DL>   <DD>Q: I'm using the <CODE>protoTXView</CODE> text engine in   Newton 2.1 OS. How can I get text, styles, pictures, etc. out of   the object returned by <CODE>protoTXView</CODE>'s   <CODE>Externalize</CODE> method without either a) instantiating a   <CODE>protoTXView</CODE> or b) digging in the data structure?<BR>      <BR>      A: You must instantiate a view to get data from the externalized   object that <CODE>protoTXView</CODE> produces. The data structures   in that object are not documented or supported. You may be tempted   to do this anyway, since it looks as though the data structure is   obvious. Don't, it isn't. <CODE>ProtoTXView</CODE> actually uses   several different data formats depending on the complexity and   storage destination for the data.<BR>      <BR>      It's actually very easy to instantiate a view based on   <CODE>protoTXView</CODE> to get at the data. Here's one way:<BR>            <PRE><CODE>    local textView := BuildContext(        {            _proto: protoTXView,            viewBounds: SetBounds(0, 0, 0, 0),            viewFlags: 0,            ReorientToScreen: ROM_DefRotateFunc,        });    textView:Open();    textView:Internalize(myExternalizedData);&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>You can now use all the <CODE>protoTXView</CODE> APIs to   get the data from the <CODE>textView</CODE> object. Don't forget   to clean up with <CODE>textView:Close()</CODE> when you're   done.<BR>      </P></DL><P><A NAME="Extracting_All_Text_from_a_ProtoTXView_Object"></A></P><H3><HR>Extracting All Text from a ProtoTXView Object (4/3/97)</H3><DL>   <DD>Q: How can I get all the text out of the   <CODE>protoTXView</CODE> data stored in a soup entry, for example   to get the text for sending in email?<BR>      <BR>      A: First, instantiate a dummy view with the data from the soup, as   described in the Q&amp;A "How to Get Data From a ProtoTXView   Externalized Data". The <CODE>protoTXView</CODE> method   <CODE>GetRangeData</CODE> always allocates its storage from the   NewtonScript heap, so you will need to copy the data into a   destination VBO in chunks. Here's some code to do that. (This code   uses a 4K block size, you may wish to adjust that as necessary,   add error checking, etc.) <CODE>StringFilter</CODE> is used to   remove the <CODE>protoTXView</CODE> graphic indicator.<BR>      <BR>            <PRE><CODE>    constant kChunkSize := 0x1000; // 4K chunks    local start := 0;    local theText := GetDefaultStore():NewVBO('string, length(""));&nbsp;    // make VBO into a proper string    BinaryMunger(theText,0,nil, "", 0, nil);    &nbsp;    while numChars-start &gt; kChunkSize do        // strip out graphics characters        StrMunger(theText,start, nil,                    StringFilter(                        textView:GetRangeData(                            {                            first: start,                             last: start := start + kChunkSize                            }, 'text),                        "\u2206\u", 'rejectAll),                    0, nil);    // copy remainder    if start &lt; numChars then        StrMunger(theText,start,nil,                    StringFilter(                        textView:GetRangeData(                            {first: start, last: numChars}, 'text),                        "\u2206\u", 'rejectAll),            0, nil);    // theText now holds plain text from the protoTXView&nbsp;</CODE></PRE>      <P><CODE><BR>      </CODE>For clarity, the code above does not use   <CODE>ClearVBOCache</CODE> as mentioned in the Q&amp;A, "How to   Avoid Resets When Using VBOs". If you are having problems with   large VBOs during code like that mentioned above, see that Q&amp;A   for more information.</P></DL><P><A NAME="Finding_the_Caret_In_a_clParagraphView-based_View"></A></P><H3><HR><B>NEW: </B>Finding the Caret In a clParagraphView-based View(5/12/97)</H3><DL>   <DD>Q: I have a view based on <CODE>clParagraphView</CODE> and   would like to find the current position of the caret within that   view so that I can scroll to it. Is there a way to do this?<BR>      <BR>      A: Yes, there is a <CODE>clParagraphView</CODE> method called   <CODE>caretRelativeToVisibleRect</CODE> that you can use.<BR>      <BR>      This method takes the global coordinates of the visible region of   the paragraph view as an argument. It returns either   <CODE>'inbox,</CODE> <CODE>'top</CODE>, <CODE>'left</CODE>,   <CODE>'bottom</CODE>, <CODE>'right</CODE>, or <CODE>nil</CODE>.   Below is a list of what each return value signifies.<BR>      <BR>      <CODE>paragraphView:CaretRelativeToVisibleRect( visibleBox   )</CODE><BR>      <BR>      Return Value Meaning<BR>      ---------------------------------------------------<BR>      <CODE>'inbox</CODE> The caret is positioned inside the visible   region.<BR>      <CODE>'top</CODE> The caret is above the visible region.<BR>      <CODE>'bottom</CODE> The caret is below the visible region.<BR>      <CODE>'left</CODE> The caret is to the left of the visible   region.<BR>      <CODE>'right</CODE> The caret is to the right of the visible   region.<BR>      <CODE>nil </CODE> The view has no caret.<BR>   </DL><P><A NAME="Scrollers_Sometimes_Go_Too_Fast"></A></P><H3><HR><B>NEW: </B>Scrollers Sometimes Go Too Fast (6/9/97)</H3><DL>   <DD>Q: When using <CODE>protoUpDownScroller</CODE> on an Apple   MessagePad 2000 , tapping on the scroller once calls the   <CODE>viewScroll2DScript</CODE> two or three times. Shouldn't the   scroller call the script only once per tap?<BR>      <BR>      A: The problem happens because the processor in the MessagePad   2000 is so fast. The scroller doesn't call the   <CODE>viewScroll2DScript</CODE> once per tap, but rather calls it   repeatedly while the pen is held down over the scroll arrow. This   is normal scroller behavior, and has in fact been there all along.   with the MP2000, the processor is so much faster that it can chug   through many scroll operations before the pen is released.<BR>      <BR>      That is, the scrolling code in the scroller itself does the   equivalent of a "<CODE>while not StrokeDone(unit) do   targetView:viewScroll2dscript(....)"</CODE>. If it takes even 1   tick for the <CODE>StrokeDone</CODE> function to report true, it's   possible that the <CODE>viewScroll2DScript</CODE> might have been   called more than once.<BR>      <BR>      If you need to slow down scrolling, add a delay in your   <CODE>viewScroll2DScript</CODE>. Use the global function   <CODE>Sleep</CODE> for this, as that call will yeild the   NewtonScript task and let other parts of the OS work (or sleep the   processor, saving battery power.)<BR>      <BR>      A simple delay after each scroll event will work fine, and is   probably the best solution overall. If you want to have the   function operate consistently on all processors, you might do   something like this;<BR>      <BR>            <PRE><CODE>    constant kMaxScrollSpeed := 60;  // ticks    viewScroll2DScript: func(...)        begin            local t := ticks();            ... // do scrolling stuff            RefreshViews(); // show scrolled result            Sleep(MAX(kMaxScrollSpeed - (ticks() - t), 0));        end;</CODE></PRE>      <P><CODE><BR>      </CODE><BR>      The above code should have the unit scrolling at a fairly   consistent one-scroll-per-second unless the time it takes to do   the scrolling stuff is more than 1 second, in which case it'll   just go as fast as it can. The drawback to this approach is that   the script will always delay for at least a second, so if for   example the user taps the up arrow then the down arrow in less   than a second, there will seem to be a delay between the up scroll   and down scroll that would not necessarily need to be there.<BR>      <BR>      You could certainly be more clever with your delays by counting   ticks and watching the count paramater to your scroll script. This   might even result in a better performing delay. However, it's   probably not worth the effort it would take to implement this. The   one-scroll-per-second approach works well, is simple, and it's   unlikely that the user will ever notice the small extra delay.   (Don't try to do one-scroll-every-5-seconds using this method   though, your users may quickly grow annoyed at the extra   delay!)<BR>      </P></DL></BODY></HTML>