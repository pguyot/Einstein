protoEditor.newGlobalFunctions :=	{	BinEqual: 2,		StrTokenize: 2,		InetDisplayStatus: 3,		TotalTextBounds: 2,		InetGetErrorString: 1,		InetOpenConnectionSlip: 3,		InetGrabLink: 3,		InetCancelLink: 3,		InetReleaseLink: 3,		DNSCancelRequests: 2,		DNSGetAddressFromName: 3,		RegSound: 2,		UnRegSound: 1,		GetFolderList: 2,		GetRegisteredSound: 1,		SoundList: 0,		GetLayout: 1,		IsPrimShape: 1,		SaveAutoAddDictionary: 0,		};                                           		protoProtoEditor.SpaceBar := protoEditor.SpaceBar;protoEditor.SpaceBar := func(a,b) 	begin		if length(protoEditor.newGlobalFunctions) > 0 then			begin				foreach slot,value in protoEditor.newGlobalFunctions do					vars.knownGlobalFunctions.(slot) := value;				//protoEditor.newGlobalFunctions := {};			end;		inherited:?SpaceBar(a,b);	end;protoEditor.NSDebugHelp_Tactile := func(off, len) 	begin		write("\n");		write("---------------------------\n");		write(" Tactile NSDebug Shortcuts \n");		write("---------------------------\n");		:NSDebugShrtCtsHelp_Tactile(0,0);		:NSDebugCntExeHelp_Tactile(0,0);		:NSDebugVarSlfHelp_Tactile(0,0);		:NSDebugStClrBPHelp_Tactile(0,0);		:NSDebugEnDisBPHelp_Tactile(0,0);		:NSDebugExBPHelp_Tactile(0,0);		:NSDebugPCHelp_Tactile(0,0);		:NSDebugDisasmHelp_Tactile(0,0);	end;AddArraySlot(protoEditor.keys, {key: $1, option: true});AddArraySlot(protoEditor.keys, 'NSDebugHelp_Tactile);protoEditor.NSDebugShrtCtsHelp_Tactile := func(off, len) 	begin		write("\n// Shortcuts to Normal Functions\n");				write("e()					// ExitBreakLoop()\n");		write("s()					// Step()\n");		write("si()				// StepIn()\n");		write("so()				// StepOut()\n");		write("qs()				// QuickStackTrace()\n");		write("w()					// Where()\n");		write("st()				// StackTraceOld()\n");	end;AddArraySlot(protoEditor.keys, {key: $2, option: true});AddArraySlot(protoEditor.keys, 'NSDebugShrtCtsHelp_Tactile);protoEditor.NSDebugCntExeHelp_Tactile := func(off, len) 	begin		write("\n// Functions for continuing execution\n");		write("\n");		write("contto(pc)			// Sets a breakpoint at pc in the current function and exits breakpoint\n");		write("runto(pc)			// Sets a breakpoint at pc in the current function and exits breakpoint\n");		write("cont()				// Exits Current breakpoint\n");		write("Contat(pc)			// Sets a breakpoint at pc and exits current breakpoint.\n");	end;AddArraySlot(protoEditor.keys, {key: $3, option: true});AddArraySlot(protoEditor.keys, 'NSDebugCntExeHelp_Tactile);protoEditor.NSDebugVarSlfHelp_Tactile := func(off, len) 	begin		write("\n// Functions for looking at variables (and self) from the stack\n");		write("\n");		write("gett(i,var)			// Get Temp Variable (var) at depth (i)\n");		write("sett(i,var,val) 	// Set Temp Variable (var) at depth (i) to (val)\n");		write("getn(i, var) 		// Get Named Variable (var) at depth (i)\n");		write("setn(i,var,val) 	// Set Named Variable (var) at depth (i) to (val)\n");		write("getself()			// Gets the current receiver layout (depth 0)\n");		write("focus(level) 		// Memorizes the Level and returns the current receiver\n");		write("glf(var)			// Returns the Temp Var from the Memorized Level\n");		write("gvf(var)			// Searches the Current Receiver's Tree for the Variable (GetVariable)\n");	end;AddArraySlot(protoEditor.keys, {key: $4, option: true});AddArraySlot(protoEditor.keys, 'NSDebugVarSlfHelp_Tactile);	protoEditor.NSDebugStClrBPHelp_Tactile := func(off, len) 	begin		write("\n// Functions for setting and clearing breakpoints\n");		write("\n");		write("stop(func,pc) 		// Sets a breakpoint in the function at the program counter		\n");		write("stopat(pc)			// Sets a breakpoint in the current function at pc\n");		write("stopatend(pc)		// Sets a breakpoint at the end of the current function\n");		write("stopend(func)		// Sets a breakpoint at the end of the func\n");		write("stophere()			// Sets a breakpoint at the current PC\n");		write("clearbp(pos)		// Removes breakpoint at pos position in AllBreakPoints List\n");		write("clearat(pc)			// Removes breakpoint at PC\n");		write("clearhere()			// Removes breakpoint at current PC\n");		write("clearallbps()		// Removes all breakpoints\n");	end;AddArraySlot(protoEditor.keys, {key: $5, option: true});AddArraySlot(protoEditor.keys, 'NSDebugStClrBPHelp_Tactile);	protoEditor.NSDebugEnDisBPHelp_Tactile := func(off, len) 	begin		write("\n// Functions for enabling and disabling breakpoints\n");		write("\n");		write("disablebp(pc)		// Disable the breakpoint at pc\n");		write("enablebp(pc)		// Enable the breakpoint at pc\n");		write("disableallbps()		// Sets GloballyEnableBreakPoints to Nil,  Disables all breakpoints\n");		write("enableallbps()		// Sets GloballyEnableBreakPoints to True,  Enables all breakpoints\n");	end;AddArraySlot(protoEditor.keys, {key: $6, option: true});AddArraySlot(protoEditor.keys, 'NSDebugEnDisBPHelp_Tactile);	protoEditor.NSDebugExBPHelp_Tactile := func(off, len) 	begin		write("\n// Functions for examining breakpoints\n");		write("\n");		write("allbps()			// Returns an array of the Current Breakpoints\n");		write("listbps()			// Prints a list of breakpoints with their func names\n");		write("findbp(func,pc)		// Returns the breakpoint info for the breakpoint in func at pc\n");		write("findbpat(pc)		// Returns first breakpoint at pc\n");		write("getbp(pos)			// Returns pos breakpoint in respect to all breakpoints (1 would give you the first one)\n");		write("listdisabledbps()	// Prints all disabled breakpoints\n");		write("listenabledbps()	// Prints all enabled breakpoints\n");	end;AddArraySlot(protoEditor.keys, {key: $7, option: true});AddArraySlot(protoEditor.keys, 'NSDebugExBPHelp_Tactile);protoEditor.NSDebugPCHelp_Tactile := func(off, len) 	begin		write("\n// Functions for looking the program counter\n");		write("\n");		write("cpc()				// Returns the Current Program Counter\n");		write("pc() 				// Returns the Current Program Counter\n");		write("setcpc(pc) 			// Sets the Current Program Counter to PC\n");		write("cf() 				// Returns the Current Function\n");		write("getcpc(level) 		// Returns the Program Counter at Level\n");		write("getcf(level)		// Returns the Current Function at Level\n");		write("endfn(func)			// Returns the Last Counter Position for a function\n");	end;AddArraySlot(protoEditor.keys, {key: $8, option: true});AddArraySlot(protoEditor.keys, 'NSDebugPCHelp_Tactile);	protoEditor.NSDebugDisasmHelp_Tactile := func(off, len) 	begin		write("\n// Functions for disassembing functions\n");		write("\n");		write("dis(func,start,end)	// Disasms the func from start to end\n");		write("dischunk(pc) 		// Disasms the current func from the PC to PC + 50\n");		write("dishere()			// Disasms the current func from Current PC - 30 to Current PC + 10\n");		write("disnext() 			// Disasms the current func from Current PC - 10 to Current PC + 30\n");		write("disbp(pc)			// Disasms the function at breakpoint pc from PC - 10 to PC + 20;\n");		write("disend()			// Disasms the last 10 instructions of the current function\n");		write("disendfn(func)		// Disasms the last 10 instructions of the func\n");	end;AddArraySlot(protoEditor.keys, {key: $9, option: true});AddArraySlot(protoEditor.keys, 'NSDebugDisasmHelp_Tactile);protoEditor.vfNewEval_Tactile := func(off, len) 	begin		:ReplaceSelection("\ngetroot().|ViewFrame:JRH|:newEval(\""&(:Selection())&"\");\ngetroot().|ViewFrame:JRH|:debugPrintAction(nil,nil);");	end;AddArraySlot(protoEditor.keys, {key: $e, control: true});AddArraySlot(protoEditor.keys, 'vfNewEval_Tactile);protoEditor.quickStackTrace_Tactile := func(off, len) 	begin		:ReplaceSelection("quickStackTrace()");	end;AddArraySlot(protoEditor.keys, {key: $q, control: true});AddArraySlot(protoEditor.keys, 'quickStackTrace_Tactile);protoEditor.getNamedVar_Tactile := func(off, len) 	begin		:ReplaceSelection("getNamedVar(0, (:Selection()))");	end;AddArraySlot(protoEditor.keys, {key: $v, control: true});AddArraySlot(protoEditor.keys, 'getNamedVar_Tactile);protoEditor.where_Tactile := func(off, len) 	begin		:ReplaceSelection("where()");	end;AddArraySlot(protoEditor.keys, {key: $w, control: true, option: true});AddArraySlot(protoEditor.keys, 'where_Tactile);protoEditor.EditorHelp_Tactile := func(len) begin	write("\n");	write("---------------------------\n");	write("Tactile Editor Keys Display\n");	write("---------------------------\n");	local keyFinder := func(key)		begin			local keys :=  [[0x33,"Backspace"],[0x75,"Delete"],[0x31,"Space"],[0x47,"Clear"],[0x4C,"Enter"],							[0x7E,"Up Arrow"],[0x7D,"Down Arrow"],[0x7B,"Right Arrow"],[0x7C,"Left Arrow"],							[0x74,"Page Up"],[0x79,"Page Down"],[0x77,"End"],[0x73,"Home"],[0x24,"Return"],							[0x37,"Command"],[0x3A,"Option"],[0x3B,"Control"],[0x38,"Shift"],[0x35,"Esc"],						   ];			local pos := arrayPos(keys,key,0,func(v,e) e[0]=v);			if pos then				keys[pos][1];			else				"Key - "&key;		end;	local array := array(0,nil);	for i := len to length(self.keys)-1 by 2 do		begin			text := capitalize(keys[i+1]&"");			text := text & subStr("                         ",0,25-strLen(text));			if classof(keys[i]) = 'frame then				begin					foreach slot,val in keys[i] do						if not slot = 'key and val then							text := text &" "& slot;								if classof(keys[i].key) = 'int then						text := text &" - "& call (keyFinder) with (keys[i].key);					else						text := text &" - "& keys[i].key;				end;			else if classof(keys[i]) = 'int then				text := text & " "& call (keyFinder) with (keys[i]);			else				text := text & " "& keys[i];			addArraySlot(array,text&unicodeCR);		end;	sort(array,'|str<|,nil);	foreach item in array do		write(item);end;protoEditor.EditorHelpLong_Tactile := func(off, len) begin	:editorHelp_Tactile(0);end;protoEditor.EditorHelpShort_Tactile := func(off, len) begin	:editorHelp_Tactile(150);end;AddArraySlot(protoEditor.keys, {key: $/, command:true});AddArraySlot(protoEditor.keys, 'EditorHelpShort_Tactile);AddArraySlot(protoEditor.keys, {key: $/, command:true, shift:true});AddArraySlot(protoEditor.keys, 'EditorHelpLong_Tactile);protoEditor.vfDecompile_Tactile := func(off, len) 	begin		:ReplaceSelection("\ngetroot().|ViewFrame:JRH|:open();\ngetroot().|ViewFrame:JRH|:decompile(self._implementor."&(:Selection())&",0);\n");	end;AddArraySlot(protoEditor.keys, {key: $v, option: true});AddArraySlot(protoEditor.keys, 'vfDecompile_Tactile);protoEditor.callWithFunc_Tactile := func(off, len) 	begin		:ReplaceSelection("call (func()\nbegin\n"&(:Selection())&"\nend;) with ();\n");	end;AddArraySlot(protoEditor.keys, {key: $c, option: true});AddArraySlot(protoEditor.keys, 'callWithFunc_Tactile);protoEditor.zapGremlins_Tactile := func(off, len) 	begin		:ReplaceSelection(stringFilter(:selection(),"¨©ª²³ÖÉ Ž`1234567890-=qwertyuiop[]\\asdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?\t\n",'passAll));	end;AddArraySlot(protoEditor.keys, {key: $z, option: true});AddArraySlot(protoEditor.keys, 'zapGremlins_Tactile);protoEditor.prettyPrint_Tactile := func(off, len) 	begin		local text := "";		local src := " "&:Selection()&unicodeCR;		if strLen(src) = 2 then			begin				:tellUser("Please select the function you wish to format.");				return;			end;		else			:tellUser("");		local comments := [];		local commLen;		local positions;		local objects;		local begPos := strPos(src,"/*",0);		local endPos := 0;		local index := 0;		local nextObj;				// zap deviant characters				repeat until strReplace(src,""&$\A0," ",nil) = 0; //viewframe's leading char		repeat until strReplace(src,"\n ","\n",nil) = 0;		repeat until strReplace(src,"\n\t","\n",nil) = 0;				// move comments away from direct contact with code		strReplace(src,"//"," //",nil);		strReplace(src,"/*"," /*",nil);				repeat until strReplace(src,unicodeHT&""," ",nil) = 0;		repeat until strReplace(src,"  "," ",nil) = 0;		while (begPos := strPos(src,"/",endPos+1)) do			begin				if src[begPos-2]  = unicodeCR then					nextObj := "!";				else					nextObj := "";									if src[begPos+1]  = $/ then					begin						endpos := strPos(src,"\n",begPos+1);						commLen := endPos-begpos;					end;				else if src[begPos+1]  = $* then					begin						endPos := strPos(src,"/",begPos+1);						commLen := endPos-begpos+1;					end;				else					endPos := begPos;				if not endPos = begPos then					begin						addArraySlot(comments,["!@#*#@!"&nextObj,subStr(src,begPos,commLen)]);						strReplace(src,comments[index][1],unicodeCR&comments[index][0],1);							endPos := 0;									index := index + 1;					end;			end;		begPos := 0;    //reset variables used above		endpos := nil;		positions := [nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil];		objects := ["\nbegin\n","\nend;","\nif ","\nelse\n","\nrepeat\n",							"\nuntil ","\nwhile ","\nfor ",							"\nloop\n","\ntry\n","\nonexception ","\n!@#$$#@!","\nforeach ",];		nextObj := nil;		local direction :=  [1,-1,2,-2,1,-1,3,3,3,4,-4,-3,3];		local indent := 0;		local lastIndent :=0;		local indents := [[0,'b]];				local type := 'begins;				foreach item in ["if","until","while","for","foreach","onexception"] do			strReplace(src," "&item&" ", unicodeCR&item&" ",nil);					foreach item in ["begin","end","else","loop","try"] do			begin				strReplace(src," "&item&" ", unicodeCR&item&unicodeCR,nil);				strReplace(src,unicodeCR&item&" ", unicodeCR&item&unicodeCR,nil);				strReplace(src," "&item&unicodeCR, unicodeCR&item&unicodeCR,nil);			end;							strReplace(src,"; ",";\n",nil);		strReplace(src," end;","\nend;\n",nil);		strReplace(src,"end\n","\nend;\n",nil);				foreach item in ["if","then","else","not","or","and","begin","end","for","foreach","while","do","repeat","until","loop","try","onexeption"] do			strReplace(src,item,item,nil);			strReplace(src,"\nthen"," then",nil);		strReplace(src,"then ","then\n",nil);		strReplace(src,"\ndo"," do",nil);		strReplace(src,"else\nif ", "!@#$$#@!", nil);			repeat until strReplace(src,"\n\n","\n",nil) = 0;		local minObj := func(arr) 			begin				num := [99999999,-1];				for i := 0 to length(arr) - 1 do					if arr[i] then						if arr[i] < num[0] then							num := [arr[i],i];				num;			end;				for i := 0 to length(objects)-1 do			positions[i] := strPos(src,objects[i],0);		nextObj := call (minObj) with (positions);		local useBack := 1;				while (endpos := strPos(src,"\n",begPos+1)) do			if beginsWith(subStr(src,begPos+1,endPos-begPos),"!@#*#@!") then				begin					text := text & subStr(src,begPos+1,endPos-begPos);					begPos := endPos;				end;			else			begin				local prettySpace := nil;												if nextObj[0] >= begPos and nextObj[0] < endPos then					begin						if direction[nextObj[1]] > 0 then 							begin								if not direction[nextObj[1]] = 1 then 									if not setContains(['ifs, 'elses, 'fors, 'onexcept,'begins], (type)) then										text := text &unicodeCR;																				if direction[nextObj[1]] = 2 then  // if									begin										if not setContains(['ifs, 'elses, 'fors, 'onexcept], (type)) then											begin												while (indents[length(indents)-1][1] = 'w) do													arrayRemoveCount(indents,length(indents)-1,1);												indent := indents[length(indents)-1][0]+1;											end;										else											indent := indent;										type := 'ifs;																				nextIndent := indent + 1;										addArraySlot(indents,[indent,'w]);									end;								else if direction[nextObj[1]] = 3 then  // for, loop, while									begin										type := 'fors;										indent := indent;										nextIndent := indent + 1;									end;								else if direction[nextObj[1]] = 4 then  // try									begin										type := 'trys;										indent := indent;										nextIndent := indent + 1;										addArraySlot(indents,[indent,'t]);									end;								else									begin  // begin, repeat										if not setContains(['ifs, 'elses, 'fors, 'onexcept], (type)) then											begin												while (indents[length(indents)-1][1] = 'w) do													arrayRemoveCount(indents,length(indents)-1,1);												indent := indents[length(indents)-1][0]+1;											end;										type := 'begins;										indent := indent;										nextIndent := indent + 1;										addArraySlot(indents,[indent,'s]);									end;							end;						else 							if direction[nextObj[1]] = -1 then //end								begin									if not setContains(['ifs, 'elses, 'fors, 'onexcept], (type)) then										while (indents[length(indents)-1][1] = 'w) do											arrayRemoveCount(indents,length(indents)-1,1);																				indent := indents[length(indents)-1][0];																			if (indents[length(indents)-1][1] = 's) then										arrayRemoveCount(indents,length(indents)-1,1);																			nextIndent := indents[length(indents)-1][0]+1;																		type := 'ends;								end;							else if direction[nextObj[1]] = -3 then // else if								begin									type :='elses;									indent := indents[length(indents)-1][0];																	nextIndent := indent + 1;								end;							else if direction[nextObj[1]] = -4 then // onexception								begin									type :='onexcept;									indent := indents[length(indents)-1][0];									// if you're the first onexcept after the try then..										if indents[length(indents)-1][1] = 't then										indents[length(indents)-1][1] := 'w;																		nextIndent := indent + 1;								end;							else // else								begin									indent := indents[length(indents)-1][0];									if type = 'stmt then										if text[strLen(text)-2] = unicodeCR then //take off extra return after if statement combo because of prettySpace											text[strLen(text)-2] := $ ;																			if (indents[length(indents)-1][1] = 'w) then										arrayRemoveCount(indents,length(indents)-1,1);																		type :='elses;									nextIndent := indent + 1;								end;						positions[nextObj[1]] := strPos(src,objects[nextObj[1]],nextObj[0]+strLen(objects[nextObj[1]]));						nextObj := call (minObj) with (positions);					end;					else // statements					begin						if not setContains(['ifs, 'elses, 'fors, 'onexcept], (type)) then							begin								while (indents[length(indents)-1][1] = 'w) do									arrayRemoveCount(indents,length(indents)-1,1);																indent := indents[length(indents)-1][0] + 1;								nextIndent := indent;							end;						else if setContains(['ifs, 'elses,'fors,], (type)) then							prettySpace := true;													if setContains(['ends], (type)) then							text := text & unicodeCR;						nextIndent := indents[length(indents)-1][0] + 1;						type := 'stmt;					end;									for i := 2 to indent do					text := text & unicodeHT;				text := text & subStr(src,begPos+1,endPos-begPos);								if prettySpace then					text := text & unicodeCR;									indent := nextIndent;				begPos := endPos;			end;	strReplace(text, "\n\n\n", "\n\n", nil);	strReplace(text, "!@#$$#@!", "else if ", nil);	strReplace(text, "!@#*#@!else", "!@#*#@!\nelse", nil);		foreach item in comments do		if strEqual(item[0],"!@#*#@!!") then			strReplace(text,item[0],item[1],1);		else			begin				strReplace(text,unicodeCR&item[0],"!@#$##@$#@!",1);				repeat until strReplace(text,unicodeCR&"!@#$##@$#@!","!@#$##@$#@!",1) = 0;				strReplace(text,"!@#$##@$#@!"," "&item[1],1);			end;	:ReplaceSelection(text);end;AddArraySlot(protoEditor.keys, {key: $p, option: true});AddArraySlot(protoEditor.keys, 'prettyPrint_Tactile);// Use this command to evaluate stuff without being connected to the inspector.// It's better than Apple's Evaluate Because it has a self context// And it has a nice Apple - Enter Interface, Similar to Newton EvaluatesprotoEditor.JustDoIt_Tactile := func(off, len) 	begin		local text := :Selection();		if strLen(text) = 0 then			begin				local currentLine := :FindLine(off);				local start := :lineStart(currentLine);				local ends := :lineStart(currentLine+1);				:SetSelection(start,ends-start);				text := :selection();				off := ends-len-1;			end;		self.tactile := compile(text);				:SetSelection(off+len+1, 0);		if (:TextLength() = off+len+1) then			begin				:ReplaceSelection("\n");							:SetSelection(:SelectionOffset()+1, 0);			end;		else			begin				:ReplaceSelection("\n");							:SetSelection(:SelectionOffset(), 0);			end;		print(:tactile());		removeSlot(self,'tactile);	end;AddArraySlot(protoEditor.keys, {key: 76, command: true});AddArraySlot(protoEditor.keys, 'JustDoIt_Tactile);//doesn't work right.protoEditor.fancyRBracket_Tactile := func(off, len) 	begin		local text := :textString();		local j := 0;		:replaceSelection("]");		for i := 0 to off -1 do			if text[off-i-1] = $] then				j := j + 1;			else if text[off-i-1] = $[ then				if j = 0 then					begin						:setSelection(off-i-1,1);						break;					end;					else					j := j - 1;			// some delay for user to see the effect		for i := 0 to 100 do			begin			end;					// move selection back to where you were.		//:setSelection(off+1,0);	end;//AddArraySlot(protoEditor.keys, {key: $]});//AddArraySlot(protoEditor.keys, 'fancyRBracket_Tactile);protoEditor.commenting := func( offset, len ) begin	local text := :selection();	local pos := strPos( text, "/*" & chr(13), 0 );	if pos then		begin			text := subStr( text, 0, pos ) & subStr( text, pos + 3, nil );			local nextPos := pos;			repeat				pos := strPos( text, "*/", nextPos );							if pos then					nextPos := strPos( text, "*/", pos + 3 );			until not pos or not nextPos;			if pos then				begin					local pos2 := pos + 2;								if pos2 < strlen( text ) and text[ pos2 ] = chr(13) then						pos2 := pos + 3;								text := subStr( text, 0, pos ) & subStr( text, pos2, nil );				end;		end;	else		begin			text := "/*" & chr(13 ) & text;			if not endsWith( text, "" & chr(13) ) then				text := text & chr(13);			text := text & "*/" & chr(13);		end;	:replaceSelection( text );end;protoEditor:defineKey( { key : $c, command : true, option : true }, 'commenting );// option-, : evaluate select and spew text at eofprotoEditor.SpewEndVtHick :=func(off, len)begin	local tempStr;	if len = 0 then		begin			local line := :FindLine(off);			local off1 := :LineStart(line);			local off2 := :LineStart(line+1);			:SetSelection(off1, off2-off1);		end;	tempStr := Clone(:Selection()&$\n);	:SetSelection(:TextLength(),0);	:ReplaceSelection(tempStr);	 // :EvaluateSelection();end;AddArraySlot(protoEditor.keys, {key: $, , control: true});AddArraySlot(protoEditor.keys, 'SpewEndVtHick);// get statsprotoEditor.GCStatsVtHick :=func(off, len)begin	:ReplaceSelection("gc();stats();");end;AddArraySlot(protoEditor.keys, {key: $g, control: true});AddArraySlot(protoEditor.keys, 'GCStatsVtHick);//tab selection rightprotoEditor.rightShiftSelectionVtHick :=func(off, len)begin	local tempStr := :Selection();	if endsWith(tempStr,"\n") then		begin			local times := StrReplace(Clone(tempStr),"\n","",nil);			StrReplace(tempStr,"\n","\n\t",times-1);		end;	else		StrReplace(tempStr,"\n","\n\t",nil);	:ReplaceSelection("\t"&tempStr);end;AddArraySlot(protoEditor.keys, {key: $>, control: true});AddArraySlot(protoEditor.keys, 'rightShiftSelectionVtHick);//AddArraySlot(protoEditor.keys, {key: $], command: true});//AddArraySlot(protoEditor.keys, 'rightShiftSelectionVtHick); //tab selection leftprotoEditor.leftShiftSelectionVtHick :=func(off, len)begin	local tempStr := :Selection();	StrReplace(tempStr,"\n\t","\n",nil);	if beginsWith(tempStr,"\t") then		StrReplace(tempStr,"\t","",1);	:ReplaceSelection(tempStr);end;AddArraySlot(protoEditor.keys, {key: $<, control: true});AddArraySlot(protoEditor.keys, 'leftShiftSelectionVtHick);//AddArraySlot(protoEditor.keys, {key: $[, command: true});//AddArraySlot(protoEditor.keys, 'leftShiftSelectionVtHick);// find the line numberprotoEditor.vtLineNumberVtHick :=	func(off, len) begin		:TellUser("Line #"&NumberStr(:FindLine(off)));		end;AddArraySlot(protoEditor.keys, {key: $i, command: true});AddArraySlot(protoEditor.keys, 'vtLineNumberVthick);AddArraySlot(protoEditor.keys, {key: $i, control: true});AddArraySlot(protoEditor.keys, 'vtLineNumberVtHick);protoEditor.fancyRParen := func(off, len) begin	if self.lastRParenVtHick	then	begin		:setSelection(lastRParenVtHick,0);		lastRParenVtHick := nil;	end	else	begin		if StrEqual(:Selection(),"(")		then		begin			:TellUser("You can replace the selection '(' with ')'");		end		else		begin			local text := :textString();			local j := 0;			:replaceSelection(")");			for i := 0 to off -1 do				if text[off-i-1] = $) then					j := j + 1;				else if text[off-i-1] = $( then					if j = 0 then						begin							:setSelection(off-i-1,1);							break;						end;						else						j := j - 1;								self.lastRParenVtHick := off+1;	// save place to go back to		end;	end;end;AddArraySlot(protoEditor.keys, {key: $),option:true});AddArraySlot(protoEditor.keys, 'fancyRParen);protoEditor.getrootEstimate_Tactile := func(off, len) 	begin		:ReplaceSelection("\ngetroot().|EstiMATE:Tactile|."&(:selection())&"\n");	end;AddArraySlot(protoEditor.keys, {key: $e, option: true});AddArraySlot(protoEditor.keys, 'getrootEstimate_Tactile);/***	===================================================================================****		Project:		Newton Toolkit**		Filename:		GlobalData****					Copyright © 1993-1998, Lunatech Research.**					All right reserved.**		****		Revision history:**			Date		Who	Changes**			----------	---	-----------------------------------------------------------**			1997-11-29	PAK	Initial release**			1997-12-11	PAK	Added balancing******		Codes used:**			*** CHK:		Check whether assumption is correct**			*** REV:		Possible revision**			*** TBD:		Still to be done****	===================================================================================*/protoEditor:DefineKey({key: 65}, 'EvaluateSelection);protoEditor.Sleep	:= func(inTicks)	begin		inTicks := Ticks() + inTicks;				while (inTicks > Ticks()) do			nil;	end;protoEditor.match	:= func(inOffset, inChar, inCharRev)	begin		local theMatches	:= 1;		local theChar;		local theCharPrev;		local theOffset		:= inOffset - 1;				while (theOffset >= 0) do			begin				theChar		:= :Peek(theOffset);				theCharPrev	:= :Peek(theOffset - 1);								if theCharPrev = chr(92) then					theOffset := theOffset - 1;				else if theCharPrev = $$ then					theOffset := theOffset - 1;				else if theChar = $" then					begin						theOffset := theOffset - 1;						while (theOffset >= 0) do							begin								theChar		:= :Peek(theOffset);								theCharPrev	:= :Peek(theOffset - 1);																if theCharPrev = chr(92) then									theOffset := theOffset - 1;								else if theChar = $" then									break;																	theOffset := theOffset - 1;							end;					end;				else if theChar = inChar then					theMatches := theMatches + 1;				else if theChar = inCharRev then					begin						theMatches := theMatches - 1;												if theMatches = 0 then							return(theOffset);					end;								theOffset := theOffset - 1;			end;		return(nil);	end;protoEditor.balanceX		:= func(inOffset, inChar, inCharRev, inLength)	begin		:ReplaceSelection("" & inChar);				local theOffset := :match(inOffset, inChar, inCharRev);				if theOffset then			begin				:SetSelection(theOffset, 1);								:Sleep(10);				:ReplaceSelection(" ");				:Sleep(10);				:ReplaceSelection("" & inCharRev);				:Sleep(10);				:ReplaceSelection(" ");				:Sleep(10);				:ReplaceSelection("" & inCharRev);				:TellUser("");			end;		else			:TellUser("Beep, left " & inCharRev & " not found!");					:SetSelection(inOffset + 1, 0);	end;protoEditor.balanceSelect	:= func(inOffset, inLength)	begin		local theOffset		:= inOffset + inLength;		local theOffsetEnd	:= :TextLength();		local theChar;		local theCharPrev	:= nil;		local theCharRev	:= nil;				while (theOffset < theOffsetEnd) do			begin				theChar := :Peek(theOffset);								if theCharPrev = $$ then					nil;				else if theChar = $) then					theCharRev := $(;				else if theChar = $} then					theCharRev := ${;				else if theChar = $] then					theCharRev := $[;									if theCharRev then					begin						local theOffsetRev := :match(theOffset, theChar, theCharRev);												if theOffsetRev then							if theOffsetRev < inOffset then								begin									:SetSelection(theOffsetRev, theOffset - theOffsetRev + 1);									break;								end;														theCharRev := nil;					end;									theOffset	:= theOffset + 1;				theCharPrev	:= theChar;			end;				if not theCharRev then			:TellUser("Beep, nothing to balance!");	end;protoEditor.rpar			:= func(inOffset, inLength)	:balanceX(inOffset, $), $(, inLength);protoEditor.racc			:= func(inOffset, inLength)	:balanceX(inOffset, $}, ${, inLength);protoEditor.rsqr			:= func(inOffset, inLength)	:balanceX(inOffset, $], $[, inLength);protoEditor:DefineKey($}, 'racc);protoEditor:DefineKey($], 'rsqr);protoEditor:DefineKey({control: true, key: $b}, 'balanceSelect);